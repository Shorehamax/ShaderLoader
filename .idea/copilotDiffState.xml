<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.16)&#10;project(ShaderLoader)&#10;&#10;set(CMAKE_CXX_STANDARD 17)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;# Find required packages&#10;find_package(Vulkan REQUIRED)&#10;find_package(glfw3 REQUIRED)&#10;&#10;# Include directories&#10;include_directories(src)&#10;&#10;# ShaderLoader library sources&#10;set(SHADER_LOADER_SOURCES&#10;    src/ShaderLoader/Private/ShaderLoader.cpp&#10;    src/ShaderLoader/Private/ShaderCompiler.cpp&#10;)&#10;&#10;# Create ShaderLoader library&#10;add_library(ShaderLoaderLib STATIC ${SHADER_LOADER_SOURCES})&#10;target_include_directories(ShaderLoaderLib PUBLIC src/ShaderLoader/Public)&#10;&#10;# FileWatcher library sources (optional - only if needed)&#10;set(FILE_WATCHER_SOURCES&#10;    src/FileWatcher/Private/FileWatcher.cpp&#10;    src/FileWatcher/Private/InotifyWatcher.cpp&#10;)&#10;&#10;# Create FileWatcher library&#10;add_library(FileWatcherLib STATIC ${FILE_WATCHER_SOURCES})&#10;target_include_directories(FileWatcherLib PUBLIC src/FileWatcher/Public)&#10;&#10;# Main application&#10;add_executable(app src/Private/main_triangle_fixed.cpp)&#10;&#10;# Link libraries to the main application&#10;target_link_libraries(app&#10;    Vulkan::Vulkan&#10;    glfw&#10;)&#10;&#10;# Set output directory&#10;set_target_properties(app PROPERTIES&#10;    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}&#10;)&#10;" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.16)&#10;project(ShaderLoader)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;# Find required packages&#10;find_package(Vulkan REQUIRED)&#10;find_package(glfw3 REQUIRED)&#10;&#10;# Main application&#10;add_executable(app src/Private/main_triangle_fixed.cpp)&#10;&#10;# Link libraries to the main application&#10;target_link_libraries(app&#10;    Vulkan::Vulkan&#10;    glfw&#10;)&#10;&#10;# Set output directory&#10;set_target_properties(app PROPERTIES&#10;    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="#  Vulkan Shader Loader&#10;&#10;A powerful, easy-to-use Vulkan application for loading and testing custom shaders in real-time. Perfect for shader developers, graphics programmers, and anyone wanting to experiment with beautiful visual effects.&#10;&#10;![Shader Demo](https://img.shields.io/badge/Graphics-Vulkan-red) ![Platform](https://img.shields.io/badge/Platform-Linux-blue) ![License](https://img.shields.io/badge/License-MIT-green)&#10;&#10;##  Features&#10;&#10;- ** Real-time Shader Loading** - Load and test vertex, fragment, and compute shaders instantly&#10;- ** Easy Template System** - Pre-made shader templates with clear instructions&#10;- **⚡ Hot Reload** - Edit shaders and see changes immediately&#10;- **️ Cross-Platform** - Built with modern Vulkan API&#10;- ** Beautiful Samples** - Includes stunning example shaders to get you started&#10;- ** Simple File Structure** - Just edit files and run!&#10;&#10;##  What's Included&#10;&#10;```&#10;ShaderLoader/&#10;├── app                          # Main executable&#10;├── shaders/                     # Shader templates directory&#10;│   ├── custom_vertex.vert       # ✏️ Edit this for vertex shaders&#10;│   ├── custom_fragment.frag     # ✏️ Edit this for fragment shaders&#10;│   ├── custom_compute.comp      # ✏️ Edit this for compute shaders&#10;│   ├── *.spv                    # Compiled SPIR-V files (auto-generated)&#10;└── README.md                    # This file&#10;```&#10;&#10;## ️ Requirements&#10;&#10;- **Linux** (Ubuntu/Debian/Fedora/Arch)&#10;- **Vulkan drivers** installed for your GPU&#10;- **GLFW** and **Vulkan SDK** (for compiling custom shaders)&#10;&#10;### Quick Install Dependencies (Ubuntu/Debian):&#10;```bash&#10;sudo apt update&#10;sudo apt install vulkan-tools vulkan-validationlayers-dev libglfw3-dev glslc&#10;```&#10;&#10;### Quick Install Dependencies (Arch):&#10;```bash&#10;sudo pacman -S vulkan-tools vulkan-validation-layers glfw-wayland shaderc&#10;```&#10;&#10;##  How to Use&#10;&#10;### 1. **Run the App**&#10;```bash&#10;./app&#10;```&#10;You should see a colorful triangle with smooth color gradients!&#10;&#10;### 2. **Edit Custom Shaders**&#10;Open the shader files in your favorite text editor:&#10;&#10;**For Vertex Shaders:**&#10;```bash&#10;nano shaders/custom_vertex.vert&#10;# Or use any editor: code, vim, gedit, etc.&#10;```&#10;&#10;**For Fragment Shaders:**&#10;```bash&#10;nano shaders/custom_fragment.frag&#10;```&#10;&#10;### 3. **Compile Your Changes**&#10;```bash&#10;cd shaders&#10;glslc custom_vertex.vert -o custom_vertex.vert.spv&#10;glslc custom_fragment.frag -o custom_fragment.frag.spv&#10;```&#10;&#10;### 4. **See Your Results**&#10;```bash&#10;./app&#10;```&#10;Your custom shaders will be loaded automatically!&#10;&#10;##  Example Workflow&#10;&#10;Let's create a pulsing red triangle:&#10;&#10;**1. Edit the vertex shader:**&#10;```glsl&#10;// In custom_vertex.vert&#10;vec3 colors[3] = vec3[](&#10;    vec3(1.0, 0.0, 0.0),  // All red&#10;    vec3(1.0, 0.0, 0.0),  // All red  &#10;    vec3(1.0, 0.0, 0.0)   // All red&#10;);&#10;```&#10;&#10;**2. Edit the fragment shader:**&#10;```glsl&#10;// In custom_fragment.frag&#10;void main() {&#10;    float pulse = sin(gl_FragCoord.x * 0.01) * 0.5 + 0.5;&#10;    outColor = vec4(fragColor * pulse, 1.0);&#10;}&#10;```&#10;&#10;**3. Compile and run:**&#10;```bash&#10;cd shaders&#10;glslc custom_vertex.vert -o custom_vertex.vert.spv&#10;glslc custom_fragment.frag -o custom_fragment.frag.spv&#10;cd ..&#10;./app&#10;```&#10;&#10;You'll see a pulsing red triangle! &#10;&#10;##  Shader Templates Explained&#10;&#10;### Vertex Shader Template (`custom_vertex.vert`)&#10;```glsl&#10;#version 450&#10;&#10;// Define vertex positions&#10;vec2 positions[3] = vec2[](&#10;    vec2(0.0, 0.5),   // top&#10;    vec2(-0.5, -0.5), // bottom left&#10;    vec2(0.5, -0.5)   // bottom right&#10;);&#10;&#10;// Define colors for each vertex&#10;vec3 colors[3] = vec3[](&#10;    vec3(1.0, 0.0, 0.0),  // red&#10;    vec3(0.0, 1.0, 0.0),  // green&#10;    vec3(0.0, 0.0, 1.0)   // blue&#10;);&#10;&#10;layout(location = 0) out vec3 fragColor;&#10;&#10;void main() {&#10;    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);&#10;    fragColor = colors[gl_VertexIndex];&#10;}&#10;```&#10;&#10;**Key Points:**&#10;- Change `positions[]` to modify shape&#10;- Change `colors[]` to modify vertex colors&#10;- Add animations using `gl_VertexIndex` as time&#10;- Output `fragColor` to pass data to fragment shader&#10;&#10;### Fragment Shader Template (`custom_fragment.frag`)&#10;```glsl&#10;#version 450&#10;&#10;layout(location = 0) in vec3 fragColor;&#10;layout(location = 0) out vec4 outColor;&#10;&#10;void main() {&#10;    outColor = vec4(fragColor, 1.0);&#10;}&#10;```&#10;&#10;**Key Points:**&#10;- `fragColor` comes from vertex shader&#10;- `outColor` is the final pixel color&#10;- Use `gl_FragCoord` for screen position effects&#10;- Add noise, patterns, or animations here&#10;&#10;##  Advanced Examples&#10;&#10;### Animated Rotating Triangle&#10;```glsl&#10;// In vertex shader main()&#10;float time = float(gl_VertexIndex) * 0.1;&#10;float angle = time;&#10;mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));&#10;vec2 pos = rotation * positions[gl_VertexIndex];&#10;gl_Position = vec4(pos, 0.0, 1.0);&#10;```&#10;&#10;### Psychedelic Fragment Effect&#10;```glsl&#10;// In fragment shader main()&#10;vec2 uv = gl_FragCoord.xy * 0.01;&#10;float wave = sin(uv.x * 10.0) * sin(uv.y * 10.0);&#10;vec3 color = fragColor + wave * 0.5;&#10;outColor = vec4(color, 1.0);&#10;```&#10;&#10;### Pulsing Colors&#10;```glsl&#10;// In fragment shader main()&#10;float pulse = sin(gl_FragCoord.x * 0.05 + gl_FragCoord.y * 0.03) * 0.5 + 0.5;&#10;outColor = vec4(fragColor * pulse, 1.0);&#10;```&#10;&#10;##  Troubleshooting&#10;&#10;### Black Screen?&#10;1. **Check compilation:** Make sure your shaders compile without errors&#10;   ```bash&#10;   glslc custom_vertex.vert -o custom_vertex.vert.spv&#10;   ```&#10;2. **Check file paths:** Ensure `.spv` files are in the `shaders/` directory&#10;3. **Try simple shaders:** Use the default templates first&#10;&#10;### Compilation Errors?&#10;1. **Check GLSL syntax:** Make sure your shader code is valid GLSL 4.5&#10;2. **Match interfaces:** Vertex shader outputs must match fragment shader inputs&#10;3. **Use layout locations:** Always specify `layout(location = N)`&#10;&#10;### App Won't Start?&#10;1. **Check Vulkan:** Run `vulkaninfo` to verify Vulkan is installed&#10;2. **Update drivers:** Make sure your GPU drivers support Vulkan&#10;3. **Install dependencies:** See requirements section above&#10;&#10;##  Shader Resources&#10;&#10;### Learning Resources&#10;- [Learn OpenGL - Shaders](https://learnopengl.com/Getting-started/Shaders)&#10;- [Shadertoy](https://shadertoy.com) - Online shader editor&#10;- [The Book of Shaders](https://thebookofshaders.com/)&#10;- [Vulkan Tutorial](https://vulkan-tutorial.com/)&#10;&#10;### Useful GLSL Functions&#10;```glsl&#10;// Math&#10;sin(), cos(), tan()          // Trigonometry&#10;length(), distance()         // Vector operations&#10;mix(a, b, t)                // Linear interpolation&#10;smoothstep(edge0, edge1, x) // Smooth transitions&#10;fract(), floor(), ceil()    // Number manipulation&#10;&#10;// Graphics&#10;gl_FragCoord                // Screen position&#10;gl_VertexIndex             // Current vertex number&#10;texture()                  // Sample textures&#10;normalize()                // Normalize vectors&#10;```&#10;&#10;## ️ Building from Source&#10;&#10;If you want to modify the application itself:&#10;&#10;```bash&#10;# Clone and build&#10;git clone &lt;your-repo&gt;&#10;cd ShaderLoader&#10;mkdir build &amp;&amp; cd build&#10;cmake ..&#10;make&#10;&#10;# Copy executable and shaders&#10;cp app ../release/ShaderLoader/&#10;cp -r ../shaders ../release/ShaderLoader/&#10;```&#10;&#10;##  License&#10;&#10;MIT License - Feel free to use this for learning, projects, or commercial work!&#10;&#10;##  Contributing&#10;&#10;Found a bug? Want to add features? Pull requests welcome!&#10;&#10;##  Gallery&#10;&#10;Try these shader combinations for stunning effects:&#10;&#10;- ** Rainbow Triangle:** Cycle colors over time&#10;- **⚡ Electric Effect:** Add noise and lightning patterns  &#10;- ** Wave Distortion:** Animate vertex positions with sine waves&#10;- ** Particle System:** Use fragment shader for particle effects&#10;- ** Fire Simulation:** Combine noise with color gradients&#10;&#10;---&#10;&#10;**Happy Shader Coding!** ✨&#10;&#10;*Made with ❤️ for the graphics programming community*&#10;" />
              <option name="updatedContent" value="#  Vulkan Shader Loader&#10;&#10;A powerful, easy-to-use Vulkan application for loading and testing custom shaders in real-time. Perfect for shader developers, graphics programmers, and anyone wanting to experiment with beautiful visual effects.&#10;&#10;![Shader Demo](https://img.shields.io/badge/Graphics-Vulkan-red) ![Platform](https://img.shields.io/badge/Platform-Linux-blue) ![License](https://img.shields.io/badge/License-MIT-green)&#10;&#10;##  Features&#10;&#10;- ** Real-time Shader Loading** - Load and test vertex, fragment, and compute shaders instantly&#10;- ** Easy Template System** - Pre-made shader templates with clear instructions&#10;- **⚡ Hot Reload** - Edit shaders and see changes immediately&#10;- **️ Cross-Platform** - Built with modern Vulkan API&#10;- ** Beautiful Samples** - Includes stunning example shaders to get you started&#10;- ** Simple File Structure** - Just edit files and run!&#10;&#10;##  What's Included&#10;&#10;```&#10;ShaderLoader/&#10;├── app                          # Main executable&#10;├── shaders/                     # Shader templates directory&#10;│   ├── custom_vertex.vert       # ✏️ Edit this for vertex shaders&#10;│   ├── custom_fragment.frag     # ✏️ Edit this for fragment shaders&#10;│   ├── custom_compute.comp      # ✏️ Edit this for compute shaders&#10;│   ├── *.spv                    # Compiled SPIR-V files (auto-generated)&#10;└── README.md                    # This file&#10;```&#10;&#10;## ️ Requirements&#10;&#10;- **Linux** (Ubuntu/Debian/Fedora/Arch)&#10;- **Vulkan drivers** installed for your GPU&#10;- **GLFW** and **Vulkan SDK** (for compiling custom shaders)&#10;&#10;### Quick Install Dependencies (Ubuntu/Debian):&#10;```bash&#10;sudo apt update&#10;sudo apt install vulkan-tools vulkan-validationlayers-dev libglfw3-dev glslc&#10;```&#10;&#10;### Quick Install Dependencies (Arch):&#10;```bash&#10;sudo pacman -S vulkan-tools vulkan-validation-layers glfw-wayland shaderc&#10;```&#10;&#10;##  How to Use&#10;&#10;### 1. **Run the App**&#10;```bash&#10;./run_shader_loader.sh&#10;```&#10;**Note:** Use the launcher script instead of running `./app` directly - this ensures shader files are found correctly.&#10;&#10;You should see a colorful triangle with smooth color gradients!&#10;&#10;### 2. **Edit Custom Shaders**&#10;Open the shader files in your favorite text editor:&#10;&#10;**For Vertex Shaders:**&#10;```bash&#10;nano shaders/custom_vertex.vert&#10;# Or use any editor: code, vim, gedit, etc.&#10;```&#10;&#10;**For Fragment Shaders:**&#10;```bash&#10;nano shaders/custom_fragment.frag&#10;```&#10;&#10;### 3. **Compile Your Changes**&#10;```bash&#10;cd shaders&#10;glslc custom_vertex.vert -o custom_vertex.vert.spv&#10;glslc custom_fragment.frag -o custom_fragment.frag.spv&#10;```&#10;&#10;### 4. **See Your Results**&#10;```bash&#10;./app&#10;```&#10;Your custom shaders will be loaded automatically!&#10;&#10;##  Example Workflow&#10;&#10;Let's create a pulsing red triangle:&#10;&#10;**1. Edit the vertex shader:**&#10;```glsl&#10;// In custom_vertex.vert&#10;vec3 colors[3] = vec3[](&#10;    vec3(1.0, 0.0, 0.0),  // All red&#10;    vec3(1.0, 0.0, 0.0),  // All red  &#10;    vec3(1.0, 0.0, 0.0)   // All red&#10;);&#10;```&#10;&#10;**2. Edit the fragment shader:**&#10;```glsl&#10;// In custom_fragment.frag&#10;void main() {&#10;    float pulse = sin(gl_FragCoord.x * 0.01) * 0.5 + 0.5;&#10;    outColor = vec4(fragColor * pulse, 1.0);&#10;}&#10;```&#10;&#10;**3. Compile and run:**&#10;```bash&#10;cd shaders&#10;glslc custom_vertex.vert -o custom_vertex.vert.spv&#10;glslc custom_fragment.frag -o custom_fragment.frag.spv&#10;cd ..&#10;./app&#10;```&#10;&#10;You'll see a pulsing red triangle! &#10;&#10;##  Shader Templates Explained&#10;&#10;### Vertex Shader Template (`custom_vertex.vert`)&#10;```glsl&#10;#version 450&#10;&#10;// Define vertex positions&#10;vec2 positions[3] = vec2[](&#10;    vec2(0.0, 0.5),   // top&#10;    vec2(-0.5, -0.5), // bottom left&#10;    vec2(0.5, -0.5)   // bottom right&#10;);&#10;&#10;// Define colors for each vertex&#10;vec3 colors[3] = vec3[](&#10;    vec3(1.0, 0.0, 0.0),  // red&#10;    vec3(0.0, 1.0, 0.0),  // green&#10;    vec3(0.0, 0.0, 1.0)   // blue&#10;);&#10;&#10;layout(location = 0) out vec3 fragColor;&#10;&#10;void main() {&#10;    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);&#10;    fragColor = colors[gl_VertexIndex];&#10;}&#10;```&#10;&#10;**Key Points:**&#10;- Change `positions[]` to modify shape&#10;- Change `colors[]` to modify vertex colors&#10;- Add animations using `gl_VertexIndex` as time&#10;- Output `fragColor` to pass data to fragment shader&#10;&#10;### Fragment Shader Template (`custom_fragment.frag`)&#10;```glsl&#10;#version 450&#10;&#10;layout(location = 0) in vec3 fragColor;&#10;layout(location = 0) out vec4 outColor;&#10;&#10;void main() {&#10;    outColor = vec4(fragColor, 1.0);&#10;}&#10;```&#10;&#10;**Key Points:**&#10;- `fragColor` comes from vertex shader&#10;- `outColor` is the final pixel color&#10;- Use `gl_FragCoord` for screen position effects&#10;- Add noise, patterns, or animations here&#10;&#10;##  Advanced Examples&#10;&#10;### Animated Rotating Triangle&#10;```glsl&#10;// In vertex shader main()&#10;float time = float(gl_VertexIndex) * 0.1;&#10;float angle = time;&#10;mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));&#10;vec2 pos = rotation * positions[gl_VertexIndex];&#10;gl_Position = vec4(pos, 0.0, 1.0);&#10;```&#10;&#10;### Psychedelic Fragment Effect&#10;```glsl&#10;// In fragment shader main()&#10;vec2 uv = gl_FragCoord.xy * 0.01;&#10;float wave = sin(uv.x * 10.0) * sin(uv.y * 10.0);&#10;vec3 color = fragColor + wave * 0.5;&#10;outColor = vec4(color, 1.0);&#10;```&#10;&#10;### Pulsing Colors&#10;```glsl&#10;// In fragment shader main()&#10;float pulse = sin(gl_FragCoord.x * 0.05 + gl_FragCoord.y * 0.03) * 0.5 + 0.5;&#10;outColor = vec4(fragColor * pulse, 1.0);&#10;```&#10;&#10;##  Troubleshooting&#10;&#10;### Black Screen?&#10;1. **Check compilation:** Make sure your shaders compile without errors&#10;   ```bash&#10;   glslc custom_vertex.vert -o custom_vertex.vert.spv&#10;   ```&#10;2. **Check file paths:** Ensure `.spv` files are in the `shaders/` directory&#10;3. **Try simple shaders:** Use the default templates first&#10;&#10;### Compilation Errors?&#10;1. **Check GLSL syntax:** Make sure your shader code is valid GLSL 4.5&#10;2. **Match interfaces:** Vertex shader outputs must match fragment shader inputs&#10;3. **Use layout locations:** Always specify `layout(location = N)`&#10;&#10;### App Won't Start?&#10;1. **Check Vulkan:** Run `vulkaninfo` to verify Vulkan is installed&#10;2. **Update drivers:** Make sure your GPU drivers support Vulkan&#10;3. **Install dependencies:** See requirements section above&#10;&#10;##  Shader Resources&#10;&#10;### Learning Resources&#10;- [Learn OpenGL - Shaders](https://learnopengl.com/Getting-started/Shaders)&#10;- [Shadertoy](https://shadertoy.com) - Online shader editor&#10;- [The Book of Shaders](https://thebookofshaders.com/)&#10;- [Vulkan Tutorial](https://vulkan-tutorial.com/)&#10;&#10;### Useful GLSL Functions&#10;```glsl&#10;// Math&#10;sin(), cos(), tan()          // Trigonometry&#10;length(), distance()         // Vector operations&#10;mix(a, b, t)                // Linear interpolation&#10;smoothstep(edge0, edge1, x) // Smooth transitions&#10;fract(), floor(), ceil()    // Number manipulation&#10;&#10;// Graphics&#10;gl_FragCoord                // Screen position&#10;gl_VertexIndex             // Current vertex number&#10;texture()                  // Sample textures&#10;normalize()                // Normalize vectors&#10;```&#10;&#10;## ️ Building from Source&#10;&#10;If you want to modify the application itself:&#10;&#10;```bash&#10;# Clone and build&#10;git clone &lt;your-repo&gt;&#10;cd ShaderLoader&#10;mkdir build &amp;&amp; cd build&#10;cmake ..&#10;make&#10;&#10;# Copy executable and shaders&#10;cp app ../release/ShaderLoader/&#10;cp -r ../shaders ../release/ShaderLoader/&#10;```&#10;&#10;##  License&#10;&#10;MIT License - Feel free to use this for learning, projects, or commercial work!&#10;&#10;##  Contributing&#10;&#10;Found a bug? Want to add features? Pull requests welcome!&#10;&#10;##  Gallery&#10;&#10;Try these shader combinations for stunning effects:&#10;&#10;- ** Rainbow Triangle:** Cycle colors over time&#10;- **⚡ Electric Effect:** Add noise and lightning patterns  &#10;- ** Wave Distortion:** Animate vertex positions with sine waves&#10;- ** Particle System:** Use fragment shader for particle effects&#10;- ** Fire Simulation:** Combine noise with color gradients&#10;&#10;---&#10;&#10;**Happy Shader Coding!** ✨&#10;&#10;*Made with ❤️ for the graphics programming community*" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/create_release.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/create_release.sh" />
              <option name="originalContent" value="#!/bin/bash&#10;&#10;# Vulkan Shader Loader - Release Package Creator&#10;# Creates a distributable package with all necessary files&#10;&#10;echo &quot; Creating Shader Loader Release Package...&quot;&#10;&#10;# Create release directory&#10;mkdir -p release/ShaderLoader&#10;&#10;# Copy essential files - use RELEASE build instead of debug&#10;echo &quot; Copying executable (Release build)...&quot;&#10;cp cmake-build-release/app release/ShaderLoader/&#10;&#10;echo &quot; Copying shader templates...&quot;&#10;cp -r shaders release/ShaderLoader/&#10;&#10;echo &quot; Copying documentation...&quot;&#10;cp README.md release/ShaderLoader/&#10;&#10;# Make executable&#10;chmod +x release/ShaderLoader/app&#10;&#10;# Create archive&#10;echo &quot; Creating distributable archive...&quot;&#10;cd release&#10;tar -czf ShaderLoader-v1.0-linux.tar.gz ShaderLoader/&#10;cd ..&#10;&#10;echo &quot;✅ Release package created!&quot;&#10;echo &quot;&quot;&#10;echo &quot; Your release package is ready:&quot;&#10;echo &quot;    release/ShaderLoader/           - Complete package directory&quot;&#10;echo &quot;    release/ShaderLoader-v1.0-linux.tar.gz - Distributable archive&quot;&#10;echo &quot;&quot;&#10;echo &quot; To distribute:&quot;&#10;echo &quot;   1. Share the .tar.gz file&quot;&#10;echo &quot;   2. Users extract and run: ./app&quot;&#10;echo &quot;   3. Users edit shaders in shaders/ directory&quot;&#10;echo &quot;&quot;&#10;echo &quot; Package contents:&quot;&#10;ls -la release/ShaderLoader/&#10;" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;# Vulkan Shader Loader - Release Package Creator&#10;# Creates a distributable package with all necessary files&#10;&#10;echo &quot; Creating Shader Loader Release Package...&quot;&#10;&#10;# Create release directory&#10;mkdir -p release/ShaderLoader&#10;&#10;# Copy essential files - use RELEASE build instead of debug&#10;echo &quot; Copying executable (Release build)...&quot;&#10;cp cmake-build-release/app release/ShaderLoader/&#10;&#10;echo &quot; Copying shader templates...&quot;&#10;cp -r shaders release/ShaderLoader/&#10;&#10;echo &quot; Copying documentation...&quot;&#10;cp README.md release/ShaderLoader/&#10;&#10;echo &quot; Copying launcher script...&quot;&#10;cp run_shader_loader.sh release/ShaderLoader/&#10;&#10;# Make executables&#10;chmod +x release/ShaderLoader/app&#10;chmod +x release/ShaderLoader/run_shader_loader.sh&#10;&#10;# Create archive&#10;echo &quot; Creating distributable archive...&quot;&#10;cd release&#10;tar -czf ShaderLoader-v1.0-linux.tar.gz ShaderLoader/&#10;cd ..&#10;&#10;echo &quot;✅ Release package created!&quot;&#10;echo &quot;&quot;&#10;echo &quot; Your release package is ready:&quot;&#10;echo &quot;    release/ShaderLoader/           - Complete package directory&quot;&#10;echo &quot;    release/ShaderLoader-v1.0-linux.tar.gz - Distributable archive&quot;&#10;echo &quot;&quot;&#10;echo &quot; To distribute:&quot;&#10;echo &quot;   1. Share the .tar.gz file&quot;&#10;echo &quot;   2. Users extract and run: ./app&quot;&#10;echo &quot;   3. Users edit shaders in shaders/ directory&quot;&#10;echo &quot;&quot;&#10;echo &quot; Package contents:&quot;&#10;ls -la release/ShaderLoader/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/run_shader_loader.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/run_shader_loader.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;# Vulkan Shader Loader Launcher&#10;# This script ensures the app finds the shader files correctly&#10;&#10;# Get the directory where this script is located&#10;SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;&#10;&#10;# Create a temporary symlink to fix the path issue&#10;# The app expects shaders in ../shaders/ but we have them in ./shaders/&#10;cd &quot;$SCRIPT_DIR&quot;&#10;&#10;# Create parent directory structure if it doesn't exist&#10;mkdir -p ../&#10;&#10;# Create symlink to shaders directory&#10;ln -sf &quot;$SCRIPT_DIR/shaders&quot; &quot;../shaders&quot; 2&gt;/dev/null&#10;&#10;# Run the application&#10;echo &quot; Starting Vulkan Shader Loader...&quot;&#10;echo &quot; Shaders directory: $SCRIPT_DIR/shaders/&quot;&#10;echo &quot; Edit shaders in the shaders/ folder and recompile to see changes!&quot;&#10;echo &quot;&quot;&#10;&#10;./app&#10;&#10;# Clean up symlink&#10;rm -f &quot;../shaders&quot; 2&gt;/dev/null" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shaders/custom_compute.comp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shaders/custom_compute.comp" />
              <option name="updatedContent" value="#version 450&#10;&#10;// ============================================================&#10;// CUSTOM COMPUTE SHADER - PASTE YOUR CODE BELOW THIS LINE&#10;// ============================================================&#10;// Instructions:&#10;// 1. Replace the code below with your custom compute shader&#10;// 2. This runs on the GPU for parallel computation&#10;// 3. Use layout(local_size_x, y, z) to define work group size&#10;// 4. Save this file and the app will compile it automatically!&#10;// ============================================================&#10;&#10;layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;&#10;&#10;// Example: Simple buffer for demonstration&#10;layout(std430, binding = 0) buffer DataBuffer {&#10;    float data[];&#10;};&#10;&#10;void main() {&#10;    // Get current thread index&#10;    uint index = gl_GlobalInvocationID.x;&#10;    &#10;    // Example: Square each value in the buffer&#10;    if (index &lt; data.length()) {&#10;        data[index] = data[index] * data[index];&#10;    }&#10;}&#10;&#10;// ============================================================&#10;// END OF CUSTOM COMPUTE SHADER CODE&#10;// ============================================================" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shaders/custom_fragment.frag">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shaders/custom_fragment.frag" />
              <option name="originalContent" value="#version 450&#10;&#10;// ============================================================&#10;// CUSTOM FRAGMENT SHADER - PASTE YOUR CODE BELOW THIS LINE&#10;// ============================================================&#10;// Instructions:&#10;// 1. Replace the code below with your custom fragment shader&#10;// 2. Input: fragColor from vertex shader&#10;// 3. Output: outColor (final pixel color)&#10;// 4. Save this file and run the app - it will auto-reload!&#10;// ============================================================&#10;&#10;layout(location = 0) in vec3 fragColor;&#10;&#10;layout(location = 0) out vec4 outColor;&#10;&#10;// Simple hash function for noise&#10;float hash(vec2 p) {&#10;    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);&#10;}&#10;&#10;// Smooth noise function&#10;float noise(vec2 p) {&#10;    vec2 i = floor(p);&#10;    vec2 f = fract(p);&#10;    f = f * f * (3.0 - 2.0 * f);&#10;&#10;    float a = hash(i);&#10;    float b = hash(i + vec2(1.0, 0.0));&#10;    float c = hash(i + vec2(0.0, 1.0));&#10;    float d = hash(i + vec2(1.0, 1.0));&#10;&#10;    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);&#10;}&#10;&#10;void main() {&#10;    // Get screen coordinates and center&#10;    vec2 uv = gl_FragCoord.xy * 0.003;&#10;    vec2 center = vec2(400.0, 300.0) * 0.003;&#10;&#10;    // Distance from center&#10;    float dist = length(uv - center);&#10;    float angle = atan(uv.y - center.y, uv.x - center.x);&#10;&#10;    // Create time using screen position and vertex color&#10;    float time = dot(fragColor, vec3(1.0)) + uv.x + uv.y;&#10;&#10;    // Base color from vertex&#10;    vec3 color = fragColor;&#10;&#10;    // Add noise texture&#10;    float noiseValue = noise(uv * 10.0 + time * 0.5);&#10;    color = mix(color, color * 1.5, noiseValue * 0.3);&#10;&#10;    // Animated rings&#10;    float rings = sin(dist * 20.0 - time * 8.0) * 0.5 + 0.5;&#10;    rings = smoothstep(0.3, 0.7, rings);&#10;    color = mix(color, vec3(1.0, 0.9, 0.8), rings * 0.25);&#10;&#10;    // Spiral pattern&#10;    float spiral = sin(angle * 6.0 + dist * 12.0 - time * 6.0);&#10;    spiral = spiral * 0.5 + 0.5;&#10;    spiral = smoothstep(0.2, 0.8, spiral);&#10;&#10;    vec3 spiralColor = vec3(&#10;        0.9 + sin(time) * 0.1,&#10;        0.7 + sin(time + 2.0) * 0.1,&#10;        1.0 + sin(time + 4.0) * 0.1&#10;    );&#10;    color = mix(color, spiralColor, spiral * 0.3);&#10;&#10;    // Electric field effect&#10;    float electric = abs(sin(uv.x * 12.0 + time * 6.0)) *&#10;                    abs(sin(uv.y * 10.0 + time * 5.0));&#10;    electric = pow(electric, 3.0);&#10;&#10;    vec3 electricColor = vec3(0.5, 0.9, 1.0) * electric;&#10;    color += electricColor * 0.4;&#10;&#10;    // Central glow&#10;    float glow = exp(-dist * 4.0) * (sin(time * 10.0) * 0.3 + 0.7);&#10;    vec3 glowColor = vec3(1.0, 0.7, 0.9) * glow;&#10;    color += glowColor * 0.3;&#10;&#10;    // Color shifting&#10;    float hueShift = sin(time * 0.5 + dist * 3.0) * 0.2;&#10;    color = vec3(&#10;        color.r + hueShift,&#10;        color.g - hueShift * 0.5,&#10;        color.b + hueShift * 0.8&#10;    );&#10;&#10;    // Vignette&#10;    float vignette = 1.0 - smoothstep(0.4, 1.2, dist);&#10;    color *= vignette;&#10;&#10;    // Final brightness modulation&#10;    color *= 0.9 + 0.2 * sin(time * 3.0);&#10;&#10;    outColor = vec4(color, 1.0);&#10;}&#10;&#10;// ============================================================&#10;// END OF CUSTOM SHADER CODE&#10;// ============================================================&#10;" />
              <option name="updatedContent" value="#version 450&#10;&#10;// ============================================================&#10;// CUSTOM FRAGMENT SHADER - PASTE YOUR CODE BELOW THIS LINE&#10;// ============================================================&#10;// Instructions:&#10;// 1. Replace the code below with your custom fragment shader&#10;// 2. Input: fragColor from vertex shader&#10;// 3. Output: outColor (final pixel color)&#10;// 4. Save this file and run the app - it will auto-reload!&#10;// ============================================================&#10;&#10;layout(location = 0) in vec3 fragColor;&#10;&#10;layout(location = 0) out vec4 outColor;&#10;&#10;void main() {&#10;    // Simply output the interpolated vertex color&#10;    outColor = vec4(fragColor, 1.0);&#10;}&#10;&#10;// ============================================================&#10;// END OF CUSTOM SHADER CODE&#10;// ============================================================" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shaders/custom_vertex.vert">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shaders/custom_vertex.vert" />
              <option name="originalContent" value="#version 450&#10;&#10;// ============================================================&#10;// CUSTOM VERTEX SHADER - PASTE YOUR CODE BELOW THIS LINE&#10;// ============================================================&#10;// Instructions:&#10;// 1. Replace the code below with your custom vertex shader&#10;// 2. Make sure to keep the same output interface (fragColor)&#10;// 3. Save this file and run the app - it will auto-reload!&#10;// ============================================================&#10;&#10;// Animated hexagon with rotating vertices&#10;vec2 positions[6] = vec2[](&#10;    vec2(0.0, 0.6),      // top&#10;    vec2(0.52, 0.3),     // top-right&#10;    vec2(0.52, -0.3),    // bottom-right&#10;    vec2(0.0, -0.6),     // bottom&#10;    vec2(-0.52, -0.3),   // bottom-left&#10;    vec2(-0.52, 0.3)     // top-left&#10;);&#10;&#10;// Beautiful gradient colors&#10;vec3 colors[6] = vec3[](&#10;    vec3(1.0, 0.8, 0.3),  // Golden&#10;    vec3(0.8, 0.3, 1.0),  // Purple&#10;    vec3(0.3, 1.0, 0.8),  // Cyan&#10;    vec3(1.0, 0.3, 0.5),  // Pink&#10;    vec3(0.5, 1.0, 0.3),  // Lime&#10;    vec3(1.0, 0.5, 0.3)   // Orange&#10;);&#10;&#10;layout(location = 0) out vec3 fragColor;&#10;&#10;void main() {&#10;    // Create time-based animation using gl_VertexIndex&#10;    float time = float(gl_VertexIndex) * 0.2;&#10;&#10;    // Get base position&#10;    vec2 pos = positions[gl_VertexIndex];&#10;&#10;    // Add rotation animation&#10;    float angle = time + length(pos) * 3.0;&#10;    float cosA = cos(angle);&#10;    float sinA = sin(angle);&#10;&#10;    mat2 rotation = mat2(&#10;        cosA, -sinA,&#10;        sinA,  cosA&#10;    );&#10;&#10;    // Apply rotation&#10;    pos = rotation * pos;&#10;&#10;    // Add pulsing effect&#10;    float pulse = 0.8 + 0.3 * sin(time * 4.0);&#10;    pos *= pulse;&#10;&#10;    // Add wave motion&#10;    pos.x += 0.1 * sin(time * 5.0 + pos.y * 8.0);&#10;    pos.y += 0.1 * cos(time * 3.0 + pos.x * 6.0);&#10;&#10;    gl_Position = vec4(pos, 0.0, 1.0);&#10;&#10;    // Animated color mixing&#10;    vec3 baseColor = colors[gl_VertexIndex];&#10;    float colorShift = sin(time + float(gl_VertexIndex)) * 0.5 + 0.5;&#10;    fragColor = mix(baseColor, baseColor.zxy, colorShift * 0.4);&#10;}&#10;&#10;// ============================================================&#10;// END OF CUSTOM SHADER CODE&#10;// ============================================================&#10;" />
              <option name="updatedContent" value="#version 450&#10;&#10;// ============================================================&#10;// CUSTOM VERTEX SHADER - PASTE YOUR CODE BELOW THIS LINE&#10;// ============================================================&#10;// Instructions:&#10;// 1. Replace the code below with your custom vertex shader&#10;// 2. Make sure to keep the same output interface (fragColor)&#10;// 3. Save this file and run the app - it will auto-reload!&#10;// ============================================================&#10;&#10;// Simple triangle vertices&#10;vec2 positions[3] = vec2[](&#10;    vec2(0.0, 0.5),   // top&#10;    vec2(-0.5, -0.5), // bottom left&#10;    vec2(0.5, -0.5)   // bottom right&#10;);&#10;&#10;// Simple bright colors&#10;vec3 colors[3] = vec3[](&#10;    vec3(1.0, 0.0, 0.0),  // red&#10;    vec3(0.0, 1.0, 0.0),  // green&#10;    vec3(0.0, 0.0, 1.0)   // blue&#10;);&#10;&#10;layout(location = 0) out vec3 fragColor;&#10;&#10;void main() {&#10;    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);&#10;    fragColor = colors[gl_VertexIndex];&#10;}&#10;&#10;// ============================================================&#10;// END OF CUSTOM SHADER CODE&#10;// ============================================================" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shaders/triangle.frag">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shaders/triangle.frag" />
              <option name="updatedContent" value="#version 450&#10;&#10;layout(location = 0) in vec3 fragColor;&#10;&#10;layout(location = 0) out vec4 outColor;&#10;&#10;// Hash function for pseudo-random values&#10;float hash(vec2 p) {&#10;    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);&#10;}&#10;&#10;// Smooth noise function&#10;float noise(vec2 p) {&#10;    vec2 i = floor(p);&#10;    vec2 f = fract(p);&#10;    f = f * f * (3.0 - 2.0 * f);&#10;    &#10;    float a = hash(i);&#10;    float b = hash(i + vec2(1.0, 0.0));&#10;    float c = hash(i + vec2(0.0, 1.0));&#10;    float d = hash(i + vec2(1.0, 1.0));&#10;    &#10;    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);&#10;}&#10;&#10;// Multi-octave noise&#10;float fbm(vec2 p) {&#10;    float value = 0.0;&#10;    float amplitude = 0.5;&#10;    &#10;    for (int i = 0; i &lt; 3; i++) {&#10;        value += amplitude * noise(p);&#10;        p *= 2.0;&#10;        amplitude *= 0.5;&#10;    }&#10;    &#10;    return value;&#10;}&#10;&#10;void main() {&#10;    // Use fragment coordinates as UV&#10;    vec2 uv = gl_FragCoord.xy * 0.001; // Scale down for noise&#10;    &#10;    // Base color from vertex&#10;    vec3 color = fragColor;&#10;    &#10;    // Add animated noise pattern using fragment coordinates as time-like value&#10;    float time = gl_FragCoord.x * 0.01 + gl_FragCoord.y * 0.008;&#10;    float noiseValue = fbm(uv * 8.0 + time * 0.2);&#10;    &#10;    // Create swirling pattern&#10;    vec2 center = vec2(400.0, 300.0); // Approximate screen center&#10;    vec2 toCenter = gl_FragCoord.xy - center;&#10;    float dist = length(toCenter) * 0.005;&#10;    float angle = atan(toCenter.y, toCenter.x);&#10;    &#10;    // Spiral effect&#10;    float spiral = sin(angle * 4.0 + dist * 8.0 + time * 0.5);&#10;    spiral = spiral * 0.5 + 0.5;&#10;    &#10;    // Ring patterns&#10;    float rings = sin(dist * 15.0 + time * 2.0) * 0.5 + 0.5;&#10;    rings = smoothstep(0.3, 0.7, rings);&#10;    &#10;    // Combine effects&#10;    color = mix(color, color * 1.5, noiseValue * 0.3);&#10;    color = mix(color, vec3(1.0, 0.8, 0.6), spiral * 0.2);&#10;    color = mix(color, vec3(0.8, 1.0, 0.9), rings * 0.15);&#10;    &#10;    // Add color cycling based on position&#10;    float cycle = sin(time + dist * 5.0) * 0.5 + 0.5;&#10;    color = mix(color, color.gbr, cycle * 0.3);&#10;    &#10;    // Brightness modulation&#10;    float brightness = 0.7 + 0.3 * sin(time * 3.0 + dist * 10.0);&#10;    color *= brightness;&#10;    &#10;    // Vignette effect from center&#10;    float vignette = 1.0 - smoothstep(0.3, 1.5, dist);&#10;    color *= vignette;&#10;    &#10;    outColor = vec4(color, 1.0);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shaders/triangle.vert">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shaders/triangle.vert" />
              <option name="updatedContent" value="#version 450&#10;&#10;// Create a more complex shape - hexagon with 6 vertices&#10;vec2 positions[6] = vec2[](&#10;    vec2(0.0, 0.6),      // top&#10;    vec2(0.52, 0.3),     // top-right&#10;    vec2(0.52, -0.3),    // bottom-right&#10;    vec2(0.0, -0.6),     // bottom&#10;    vec2(-0.52, -0.3),   // bottom-left&#10;    vec2(-0.52, 0.3)     // top-left&#10;);&#10;&#10;// Rich gradient colors&#10;vec3 colors[6] = vec3[](&#10;    vec3(1.0, 0.3, 0.8),  // hot pink&#10;    vec3(0.3, 1.0, 0.4),  // bright green&#10;    vec3(0.4, 0.3, 1.0),  // bright blue&#10;    vec3(1.0, 0.9, 0.2),  // golden yellow&#10;    vec3(0.9, 0.2, 1.0),  // purple&#10;    vec3(0.2, 0.9, 1.0)   // cyan&#10;);&#10;&#10;layout(location = 0) out vec3 fragColor;&#10;&#10;void main() {&#10;    // Get base position and color&#10;    vec2 pos = positions[gl_VertexIndex];&#10;    vec3 color = colors[gl_VertexIndex];&#10;    &#10;    // Add some vertex animation using gl_VertexIndex as a time-like value&#10;    float vertexTime = float(gl_VertexIndex) * 0.5;&#10;    &#10;    // Add slight rotation based on vertex index&#10;    float angle = vertexTime * 0.3;&#10;    float cosA = cos(angle);&#10;    float sinA = sin(angle);&#10;    &#10;    mat2 rotation = mat2(&#10;        cosA, -sinA,&#10;        sinA,  cosA&#10;    );&#10;    &#10;    // Apply subtle rotation&#10;    pos = rotation * pos;&#10;    &#10;    // Add vertex-based scaling&#10;    float scale = 0.8 + 0.2 * sin(vertexTime * 2.0);&#10;    pos *= scale;&#10;    &#10;    gl_Position = vec4(pos, 0.0, 1.0);&#10;    &#10;    // Enhanced color mixing based on vertex position&#10;    float colorMix = sin(vertexTime + length(pos) * 3.0) * 0.5 + 0.5;&#10;    fragColor = mix(color, color.zxy, colorMix * 0.4);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Private/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Private/main.cpp" />
              <option name="originalContent" value="#include &lt;iostream&gt;&#10;#include &lt;QApplication&gt;&#10;#include &lt;QVulkanInstance&gt;&#10;#include &quot;../VulkanCore/Public/QtVulkanWindow.h&quot;&#10;#include &quot;../VulkanCore/Public/MainWindow.h&quot;&#10;&#10;int main(int argc, char** argv) {&#10;    QApplication app(argc, argv);&#10;&#10;    // No shader selection - just use default shaders automatically&#10;    // Users need to restart the app to change shaders&#10;&#10;    QVulkanInstance inst;&#10;    // Set the API version to avoid the &quot;apiVersion has value of 0&quot; error&#10;    inst.setApiVersion(QVersionNumber(1, 1, 0));&#10;    if (!inst.create()) {&#10;        qFatal(&quot;Failed to create Vulkan instance via Qt&quot;);&#10;        return -1;&#10;    }&#10;&#10;    VulkanCore::QtVulkanWindow window;&#10;    window.setVulkanInstance(&amp;inst);&#10;    window.setTitle(&quot;Shader Playground - Default Triangle&quot;);&#10;    window.resize(800, 600);&#10;&#10;    window.show();&#10;&#10;    MainWindow mainWindow;&#10;    mainWindow.show();&#10;&#10;    return app.exec();&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;iostream&gt;&#10;#include &lt;QApplication&gt;&#10;#include &lt;QVulkanInstance&gt;&#10;#include &quot;../VulkanCore/Public/QtVulkanWindow.h&quot;&#10;&#10;int main(int argc, char** argv) {&#10;    QApplication app(argc, argv);&#10;&#10;    // No shader selection - just use default shaders automatically&#10;    // Users need to restart the app to change shaders&#10;&#10;    QVulkanInstance inst;&#10;    // Set the API version to avoid the &quot;apiVersion has value of 0&quot; error&#10;    inst.setApiVersion(QVersionNumber(1, 1, 0));&#10;    if (!inst.create()) {&#10;        qFatal(&quot;Failed to create Vulkan instance via Qt&quot;);&#10;        return -1;&#10;    }&#10;&#10;    VulkanCore::QtVulkanWindow window;&#10;    window.setVulkanInstance(&amp;inst);&#10;    window.setTitle(&quot;Shader Playground - Default Triangle&quot;);&#10;    window.resize(800, 600);&#10;    window.show();&#10;&#10;    return app.exec();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Private/main_glfw.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Private/main_glfw.cpp" />
              <option name="originalContent" value="#include &lt;iostream&gt;&#10;#include &lt;fstream&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;cstdlib&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;limits&gt;&#10;#include &lt;array&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;set&gt;&#10;&#10;#define GLFW_INCLUDE_VULKAN&#10;#include &lt;GLFW/glfw3.h&gt;&#10;&#10;#include &quot;../ShaderLoader/Public/ShaderLoader.h&quot;&#10;#include &quot;../ShaderLoader/Public/IShaderCompiler.h&quot;&#10;&#10;constexpr uint32_t WIDTH = 800;&#10;constexpr uint32_t HEIGHT = 600;&#10;constexpr int MAX_FRAMES_IN_FLIGHT = 2;&#10;&#10;const std::vector&lt;const char*&gt; validationLayers = {&#10;    &quot;VK_LAYER_KHRONOS_validation&quot;&#10;};&#10;&#10;#ifdef NDEBUG&#10;constexpr bool enableValidationLayers = false;&#10;#else&#10;constexpr bool enableValidationLayers = true;&#10;#endif&#10;&#10;class ShaderPlaygroundApp {&#10;public:&#10;    void run() {&#10;        initWindow();&#10;        initVulkan();&#10;        mainLoop();&#10;        cleanup();&#10;    }&#10;&#10;private:&#10;    GLFWwindow* window = nullptr;&#10;&#10;    VkInstance instance = VK_NULL_HANDLE;&#10;    VkDebugUtilsMessengerEXT debugMessenger = VK_NULL_HANDLE;&#10;    VkSurfaceKHR surface = VK_NULL_HANDLE;&#10;&#10;    VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;&#10;    VkDevice device = VK_NULL_HANDLE;&#10;&#10;    VkQueue graphicsQueue = VK_NULL_HANDLE;&#10;    VkQueue presentQueue = VK_NULL_HANDLE;&#10;    uint32_t graphicsQueueFamily = UINT32_MAX;&#10;    uint32_t presentQueueFamily = UINT32_MAX;&#10;&#10;    VkSwapchainKHR swapChain = VK_NULL_HANDLE;&#10;    std::vector&lt;VkImage&gt; swapChainImages;&#10;    VkFormat swapChainImageFormat;&#10;    VkExtent2D swapChainExtent;&#10;    std::vector&lt;VkImageView&gt; swapChainImageViews;&#10;&#10;    VkRenderPass renderPass = VK_NULL_HANDLE;&#10;    VkPipelineLayout pipelineLayout = VK_NULL_HANDLE;&#10;    VkPipeline graphicsPipeline = VK_NULL_HANDLE;&#10;&#10;    std::vector&lt;VkFramebuffer&gt; swapChainFramebuffers;&#10;&#10;    VkCommandPool commandPool = VK_NULL_HANDLE;&#10;    std::vector&lt;VkCommandBuffer&gt; commandBuffers;&#10;&#10;    std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;&#10;    std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;&#10;    std::vector&lt;VkFence&gt; inFlightFences;&#10;    uint32_t currentFrame = 0;&#10;&#10;    bool framebufferResized = false;&#10;&#10;    // Shader data&#10;    std::vector&lt;uint32_t&gt; vertexShaderCode;&#10;    std::vector&lt;uint32_t&gt; fragmentShaderCode;&#10;&#10;    void initWindow() {&#10;        glfwInit();&#10;        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);&#10;        glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);&#10;        window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Shader Playground - GLFW Triangle&quot;, nullptr, nullptr);&#10;        glfwSetWindowUserPointer(window, this);&#10;        auto app = reinterpret_cast&lt;ShaderPlaygroundApp*&gt;(glfwGetWindowUserPointer(window));&#10;        app-&gt;framebufferResized = true;&#10;        createSurface();&#10;        pickPhysicalDevice();&#10;        createLogicalDevice();&#10;        createSwapChain();&#10;        createImageViews();&#10;        createRenderPass();&#10;        createGraphicsPipeline();&#10;        createFramebuffers();&#10;        createCommandPool();&#10;        createCommandBuffers();&#10;        createSyncObjects();&#10;    }&#10;&#10;    void loadShaders() {&#10;        std::cout &lt;&lt; &quot;Loading shaders...&quot; &lt;&lt; std::endl;&#10;&#10;        auto compiler = ShaderLoader::createDefaultCompiler();&#10;        ShaderLoader::ShaderLoader loader(std::move(compiler));&#10;&#10;        // Load vertex shader&#10;        std::string vertexPath = &quot;/home/charlie/CLionProjects/ShaderLoader/shaders/triangle.vert.spv&quot;;&#10;        if (loader.loadShader(vertexPath)) {&#10;            auto* vertexModule = loader.getModule(vertexPath);&#10;            if (vertexModule &amp;&amp; !vertexModule-&gt;spirv.empty()) {&#10;                vertexShaderCode = vertexModule-&gt;spirv;&#10;                std::cout &lt;&lt; &quot;Successfully loaded vertex shader (&quot; &lt;&lt; vertexShaderCode.size() &lt;&lt; &quot; words)&quot; &lt;&lt; std::endl;&#10;            }&#10;        }&#10;&#10;        // Load fragment shader&#10;        std::string fragmentPath = &quot;/home/charlie/CLionProjects/ShaderLoader/shaders/triangle.frag.spv&quot;;&#10;        if (loader.loadShader(fragmentPath)) {&#10;            auto* fragmentModule = loader.getModule(fragmentPath);&#10;            if (fragmentModule &amp;&amp; !fragmentModule-&gt;spirv.empty()) {&#10;                fragmentShaderCode = fragmentModule-&gt;spirv;&#10;                std::cout &lt;&lt; &quot;Successfully loaded fragment shader (&quot; &lt;&lt; fragmentShaderCode.size() &lt;&lt; &quot; words)&quot; &lt;&lt; std::endl;&#10;            }&#10;        }&#10;&#10;        if (vertexShaderCode.empty() || fragmentShaderCode.empty()) {&#10;            throw std::runtime_error(&quot;Failed to load shaders!&quot;);&#10;        }&#10;    }&#10;&#10;    void createInstance() {&#10;        if (enableValidationLayers &amp;&amp; !checkValidationLayerSupport()) {&#10;            throw std::runtime_error(&quot;validation layers requested, but not available!&quot;);&#10;        }&#10;&#10;        VkApplicationInfo appInfo{};&#10;        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;&#10;        appInfo.pApplicationName = &quot;Shader Playground&quot;;&#10;        appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);&#10;        appInfo.pEngineName = &quot;No Engine&quot;;&#10;        appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);&#10;        // Change to Vulkan 1.1 to support SPIR-V 1.3&#10;        appInfo.apiVersion = VK_API_VERSION_1_1;&#10;&#10;        VkInstanceCreateInfo createInfo{};&#10;        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;&#10;        createInfo.pApplicationInfo = &amp;appInfo;&#10;&#10;        auto extensions = getRequiredExtensions();&#10;        createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size());&#10;        createInfo.ppEnabledExtensionNames = extensions.data();&#10;&#10;        VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo{};&#10;        if (enableValidationLayers) {&#10;            createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;(validationLayers.size());&#10;            createInfo.ppEnabledLayerNames = validationLayers.data();&#10;&#10;            populateDebugMessengerCreateInfo(debugCreateInfo);&#10;            createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &amp;debugCreateInfo;&#10;        } else {&#10;            createInfo.enabledLayerCount = 0;&#10;            createInfo.pNext = nullptr;&#10;        }&#10;&#10;        if (vkCreateInstance(&amp;createInfo, nullptr, &amp;instance) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create instance!&quot;);&#10;        }&#10;    }&#10;&#10;    void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp; createInfo) {&#10;        createInfo = {};&#10;        createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;&#10;        createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;&#10;        createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;&#10;        createInfo.pfnUserCallback = debugCallback;&#10;    }&#10;&#10;    void setupDebugMessenger() {&#10;        if (!enableValidationLayers) return;&#10;&#10;        VkDebugUtilsMessengerCreateInfoEXT createInfo;&#10;        populateDebugMessengerCreateInfo(createInfo);&#10;&#10;        if (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, nullptr, &amp;debugMessenger) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to set up debug messenger!&quot;);&#10;        }&#10;    }&#10;&#10;    void createSurface() {&#10;        if (glfwCreateWindowSurface(instance, window, nullptr, &amp;surface) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create window surface!&quot;);&#10;        }&#10;    }&#10;&#10;    void pickPhysicalDevice() {&#10;        uint32_t deviceCount = 0;&#10;        vkEnumeratePhysicalDevices(instance, &amp;deviceCount, nullptr);&#10;&#10;        if (deviceCount == 0) {&#10;            throw std::runtime_error(&quot;failed to find GPUs with Vulkan support!&quot;);&#10;        }&#10;&#10;        std::vector&lt;VkPhysicalDevice&gt; devices(deviceCount);&#10;        vkEnumeratePhysicalDevices(instance, &amp;deviceCount, devices.data());&#10;&#10;        for (const auto&amp; device : devices) {&#10;            if (isDeviceSuitable(device)) {&#10;                physicalDevice = device;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (physicalDevice == VK_NULL_HANDLE) {&#10;            throw std::runtime_error(&quot;failed to find a suitable GPU!&quot;);&#10;        }&#10;    }&#10;&#10;    void createLogicalDevice() {&#10;        QueueFamilyIndices indices = findQueueFamilies(physicalDevice);&#10;&#10;        std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;&#10;        std::set&lt;uint32_t&gt; uniqueQueueFamilies = {indices.graphicsFamily.value(), indices.presentFamily.value()};&#10;&#10;        float queuePriority = 1.0f;&#10;        for (uint32_t queueFamily : uniqueQueueFamilies) {&#10;            VkDeviceQueueCreateInfo queueCreateInfo{};&#10;            queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;&#10;            queueCreateInfo.queueFamilyIndex = queueFamily;&#10;            queueCreateInfo.queueCount = 1;&#10;            queueCreateInfo.pQueuePriorities = &amp;queuePriority;&#10;            queueCreateInfos.push_back(queueCreateInfo);&#10;        }&#10;&#10;        VkPhysicalDeviceFeatures deviceFeatures{};&#10;&#10;        VkDeviceCreateInfo createInfo{};&#10;        createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;&#10;&#10;        createInfo.queueCreateInfoCount = static_cast&lt;uint32_t&gt;(queueCreateInfos.size());&#10;        createInfo.pQueueCreateInfos = queueCreateInfos.data();&#10;&#10;        createInfo.pEnabledFeatures = &amp;deviceFeatures;&#10;&#10;        const std::vector&lt;const char*&gt; deviceExtensions = {&#10;            VK_KHR_SWAPCHAIN_EXTENSION_NAME&#10;        };&#10;&#10;        createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(deviceExtensions.size());&#10;        createInfo.ppEnabledExtensionNames = deviceExtensions.data();&#10;&#10;        if (enableValidationLayers) {&#10;            createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;(validationLayers.size());&#10;            createInfo.ppEnabledLayerNames = validationLayers.data();&#10;        } else {&#10;            createInfo.enabledLayerCount = 0;&#10;        }&#10;&#10;        if (vkCreateDevice(physicalDevice, &amp;createInfo, nullptr, &amp;device) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create logical device!&quot;);&#10;        }&#10;&#10;        vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &amp;graphicsQueue);&#10;        vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &amp;presentQueue);&#10;    }&#10;&#10;    void createSwapChain() {&#10;        SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice);&#10;&#10;        VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);&#10;        VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);&#10;        VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);&#10;&#10;        uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1;&#10;        if (swapChainSupport.capabilities.maxImageCount &gt; 0 &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) {&#10;            imageCount = swapChainSupport.capabilities.maxImageCount;&#10;        }&#10;&#10;        VkSwapchainCreateInfoKHR createInfo{};&#10;        createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;&#10;        createInfo.surface = surface;&#10;&#10;        createInfo.minImageCount = imageCount;&#10;        createInfo.imageFormat = surfaceFormat.format;&#10;        createInfo.imageColorSpace = surfaceFormat.colorSpace;&#10;        createInfo.imageExtent = extent;&#10;        createInfo.imageArrayLayers = 1;&#10;        createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;&#10;&#10;        QueueFamilyIndices indices = findQueueFamilies(physicalDevice);&#10;        uint32_t queueFamilyIndices[] = {indices.graphicsFamily.value(), indices.presentFamily.value()};&#10;&#10;        if (indices.graphicsFamily != indices.presentFamily) {&#10;            createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;&#10;            createInfo.queueFamilyIndexCount = 2;&#10;            createInfo.pQueueFamilyIndices = queueFamilyIndices;&#10;        } else {&#10;            createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;&#10;        }&#10;&#10;        createInfo.preTransform = swapChainSupport.capabilities.currentTransform;&#10;        createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;&#10;        createInfo.presentMode = presentMode;&#10;        createInfo.clipped = VK_TRUE;&#10;&#10;        if (vkCreateSwapchainKHR(device, &amp;createInfo, nullptr, &amp;swapChain) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create swap chain!&quot;);&#10;        }&#10;&#10;        vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, nullptr);&#10;        swapChainImages.resize(imageCount);&#10;        vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, swapChainImages.data());&#10;&#10;        swapChainImageFormat = surfaceFormat.format;&#10;        swapChainExtent = extent;&#10;    }&#10;&#10;    void createImageViews() {&#10;        swapChainImageViews.resize(swapChainImages.size());&#10;&#10;        for (size_t i = 0; i &lt; swapChainImages.size(); i++) {&#10;            VkImageViewCreateInfo createInfo{};&#10;            createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;&#10;            createInfo.image = swapChainImages[i];&#10;            createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;&#10;            createInfo.format = swapChainImageFormat;&#10;            createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;&#10;            createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;&#10;            createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;&#10;            createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;&#10;            createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;&#10;            createInfo.subresourceRange.baseMipLevel = 0;&#10;            createInfo.subresourceRange.levelCount = 1;&#10;            createInfo.subresourceRange.baseArrayLayer = 0;&#10;            createInfo.subresourceRange.layerCount = 1;&#10;&#10;            if (vkCreateImageView(device, &amp;createInfo, nullptr, &amp;swapChainImageViews[i]) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to create image views!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void createRenderPass() {&#10;        VkAttachmentDescription colorAttachment{};&#10;        colorAttachment.format = swapChainImageFormat;&#10;        colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;&#10;        colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;&#10;        colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;&#10;        colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;&#10;        colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;&#10;        colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;&#10;        colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;&#10;&#10;        VkAttachmentReference colorAttachmentRef{};&#10;        colorAttachmentRef.attachment = 0;&#10;        colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;&#10;&#10;        VkSubpassDescription subpass{};&#10;        subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;&#10;        subpass.colorAttachmentCount = 1;&#10;        subpass.pColorAttachments = &amp;colorAttachmentRef;&#10;&#10;        VkSubpassDependency dependency{};&#10;        dependency.srcSubpass = VK_SUBPASS_EXTERNAL;&#10;        dependency.dstSubpass = 0;&#10;        dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;&#10;        dependency.srcAccessMask = 0;&#10;        dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;&#10;        dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;&#10;&#10;        VkRenderPassCreateInfo renderPassInfo{};&#10;        renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;&#10;        renderPassInfo.attachmentCount = 1;&#10;        renderPassInfo.pAttachments = &amp;colorAttachment;&#10;        renderPassInfo.subpassCount = 1;&#10;        renderPassInfo.pSubpasses = &amp;subpass;&#10;        renderPassInfo.dependencyCount = 1;&#10;        renderPassInfo.pDependencies = &amp;dependency;&#10;&#10;        if (vkCreateRenderPass(device, &amp;renderPassInfo, nullptr, &amp;renderPass) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create render pass!&quot;);&#10;        }&#10;    }&#10;&#10;    void createGraphicsPipeline() {&#10;        // Create shader modules&#10;        VkShaderModule vertShaderModule = createShaderModule(vertexShaderCode);&#10;        VkShaderModule fragShaderModule = createShaderModule(fragmentShaderCode);&#10;&#10;        VkPipelineShaderStageCreateInfo vertShaderStageInfo{};&#10;        vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;&#10;        vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;&#10;        vertShaderStageInfo.module = vertShaderModule;&#10;        vertShaderStageInfo.pName = &quot;main&quot;;&#10;&#10;        VkPipelineShaderStageCreateInfo fragShaderStageInfo{};&#10;        fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;&#10;        fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;&#10;        fragShaderStageInfo.module = fragShaderModule;&#10;        fragShaderStageInfo.pName = &quot;main&quot;;&#10;&#10;        VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};&#10;&#10;        // IMPORTANT: No vertex input for hardcoded triangle&#10;        VkPipelineVertexInputStateCreateInfo vertexInputInfo{};&#10;        vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;&#10;        vertexInputInfo.vertexBindingDescriptionCount = 0;&#10;        vertexInputInfo.vertexAttributeDescriptionCount = 0;&#10;&#10;        VkPipelineInputAssemblyStateCreateInfo inputAssembly{};&#10;        inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;&#10;        inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;&#10;        inputAssembly.primitiveRestartEnable = VK_FALSE;&#10;&#10;        VkPipelineViewportStateCreateInfo viewportState{};&#10;        viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;&#10;        viewportState.viewportCount = 1;&#10;        viewportState.scissorCount = 1;&#10;&#10;        VkPipelineRasterizationStateCreateInfo rasterizer{};&#10;        rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;&#10;        rasterizer.depthClampEnable = VK_FALSE;&#10;        rasterizer.rasterizerDiscardEnable = VK_FALSE;&#10;        rasterizer.polygonMode = VK_POLYGON_MODE_FILL;&#10;        rasterizer.lineWidth = 1.0f;&#10;        rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;&#10;        rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE; // Match shader triangle winding&#10;        rasterizer.depthBiasEnable = VK_FALSE;&#10;&#10;        VkPipelineMultisampleStateCreateInfo multisampling{};&#10;        multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;&#10;        multisampling.sampleShadingEnable = VK_FALSE;&#10;        multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;&#10;&#10;        VkPipelineColorBlendAttachmentState colorBlendAttachment{};&#10;        colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;&#10;        colorBlendAttachment.blendEnable = VK_FALSE;&#10;&#10;        VkPipelineColorBlendStateCreateInfo colorBlending{};&#10;        colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;&#10;        colorBlending.logicOpEnable = VK_FALSE;&#10;        colorBlending.logicOp = VK_LOGIC_OP_COPY;&#10;        colorBlending.attachmentCount = 1;&#10;        colorBlending.pAttachments = &amp;colorBlendAttachment;&#10;&#10;        VkDynamicState dynamicStates[] = {&#10;            VK_DYNAMIC_STATE_VIEWPORT,&#10;            VK_DYNAMIC_STATE_SCISSOR&#10;        };&#10;&#10;        VkPipelineDynamicStateCreateInfo dynamicState{};&#10;        dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;&#10;        dynamicState.dynamicStateCount = 2;&#10;        dynamicState.pDynamicStates = dynamicStates;&#10;&#10;        VkPipelineLayoutCreateInfo pipelineLayoutInfo{};&#10;        pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;&#10;        pipelineLayoutInfo.setLayoutCount = 0;&#10;        pipelineLayoutInfo.pushConstantRangeCount = 0;&#10;&#10;        if (vkCreatePipelineLayout(device, &amp;pipelineLayoutInfo, nullptr, &amp;pipelineLayout) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create pipeline layout!&quot;);&#10;        }&#10;&#10;        VkGraphicsPipelineCreateInfo pipelineInfo{};&#10;        pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;&#10;        pipelineInfo.stageCount = 2;&#10;        pipelineInfo.pStages = shaderStages;&#10;        pipelineInfo.pVertexInputState = &amp;vertexInputInfo;&#10;        pipelineInfo.pInputAssemblyState = &amp;inputAssembly;&#10;        pipelineInfo.pViewportState = &amp;viewportState;&#10;        pipelineInfo.pRasterizationState = &amp;rasterizer;&#10;        pipelineInfo.pMultisampleState = &amp;multisampling;&#10;        pipelineInfo.pColorBlendState = &amp;colorBlending;&#10;        pipelineInfo.pDynamicState = &amp;dynamicState;&#10;        pipelineInfo.layout = pipelineLayout;&#10;        pipelineInfo.renderPass = renderPass;&#10;        pipelineInfo.subpass = 0;&#10;        pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;&#10;&#10;        if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &amp;pipelineInfo, nullptr, &amp;graphicsPipeline) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create graphics pipeline!&quot;);&#10;        }&#10;&#10;        vkDestroyShaderModule(device, fragShaderModule, nullptr);&#10;        vkDestroyShaderModule(device, vertShaderModule, nullptr);&#10;&#10;        std::cout &lt;&lt; &quot;Successfully created graphics pipeline!&quot; &lt;&lt; std::endl;&#10;    }&#10;&#10;    void createFramebuffers() {&#10;        swapChainFramebuffers.resize(swapChainImageViews.size());&#10;&#10;        for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) {&#10;            VkImageView attachments[] = {&#10;                swapChainImageViews[i]&#10;            };&#10;&#10;            VkFramebufferCreateInfo framebufferInfo{};&#10;            framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;&#10;            framebufferInfo.renderPass = renderPass;&#10;            framebufferInfo.attachmentCount = 1;&#10;            framebufferInfo.pAttachments = attachments;&#10;            framebufferInfo.width = swapChainExtent.width;&#10;            framebufferInfo.height = swapChainExtent.height;&#10;            framebufferInfo.layers = 1;&#10;&#10;            if (vkCreateFramebuffer(device, &amp;framebufferInfo, nullptr, &amp;swapChainFramebuffers[i]) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to create framebuffer!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void createCommandPool() {&#10;        QueueFamilyIndices indices = findQueueFamilies(physicalDevice);&#10;&#10;        VkCommandPoolCreateInfo poolInfo{};&#10;        poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;&#10;        poolInfo.queueFamilyIndex = indices.graphicsFamily.value();&#10;        poolInfo.flags = 0; // Optional&#10;&#10;        if (vkCreateCommandPool(device, &amp;poolInfo, nullptr, &amp;commandPool) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create command pool!&quot;);&#10;        }&#10;    }&#10;&#10;    void createCommandBuffers() {&#10;        commandBuffers.resize(swapChainFramebuffers.size());&#10;&#10;        VkCommandBufferAllocateInfo allocInfo{};&#10;        allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;&#10;        allocInfo.commandPool = commandPool;&#10;        allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;&#10;        allocInfo.commandBufferCount = static_cast&lt;uint32_t&gt;(commandBuffers.size());&#10;&#10;        if (vkAllocateCommandBuffers(device, &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to allocate command buffers!&quot;);&#10;        }&#10;&#10;        for (size_t i = 0; i &lt; commandBuffers.size(); i++) {&#10;            VkCommandBufferBeginInfo beginInfo{};&#10;            beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;&#10;&#10;            if (vkBeginCommandBuffer(commandBuffers[i], &amp;beginInfo) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to begin recording command buffer!&quot;);&#10;            }&#10;&#10;            VkRenderPassBeginInfo renderPassInfo{};&#10;            renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;&#10;            renderPassInfo.renderPass = renderPass;&#10;            renderPassInfo.framebuffer = swapChainFramebuffers[i];&#10;            renderPassInfo.renderArea.offset = {0, 0};&#10;            renderPassInfo.renderArea.extent = swapChainExtent;&#10;&#10;            VkClearValue clearColor = {0.0f, 0.0f, 0.0f, 1.0f};&#10;            renderPassInfo.clearValueCount = 1;&#10;            renderPassInfo.pClearValues = &amp;clearColor;&#10;&#10;            vkCmdBeginRenderPass(commandBuffers[i], &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);&#10;&#10;            vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);&#10;&#10;            // Set dynamic viewport&#10;            VkViewport viewport{};&#10;            viewport.x = 0.0f;&#10;            viewport.y = 0.0f;&#10;            viewport.width = static_cast&lt;float&gt;(swapChainExtent.width);&#10;            viewport.height = static_cast&lt;float&gt;(swapChainExtent.height);&#10;            viewport.minDepth = 0.0f;&#10;            viewport.maxDepth = 1.0f;&#10;            vkCmdSetViewport(commandBuffers[i], 0, 1, &amp;viewport);&#10;&#10;            // Set dynamic scissor&#10;            VkRect2D scissor{};&#10;            scissor.offset = {0, 0};&#10;            scissor.extent = swapChainExtent;&#10;            vkCmdSetScissor(commandBuffers[i], 0, 1, &amp;scissor);&#10;&#10;            // IMPORTANT: No vertex buffer binding for hardcoded triangle&#10;            vkCmdDraw(commandBuffers[i], 3, 1, 0, 0);&#10;&#10;            vkCmdEndRenderPass(commandBuffers[i]);&#10;&#10;            if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to record command buffer!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void createSyncObjects() {&#10;        imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);&#10;        renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);&#10;        inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);&#10;&#10;        VkSemaphoreCreateInfo semaphoreInfo{};&#10;        semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;&#10;&#10;        for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;            if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS ||&#10;                vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to create semaphores!&quot;);&#10;            }&#10;&#10;            VkFenceCreateInfo fenceInfo{};&#10;            fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;&#10;            fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;&#10;&#10;            if (vkCreateFence(device, &amp;fenceInfo, nullptr, &amp;inFlightFences[i]) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to create fence!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void mainLoop() {&#10;        while (!glfwWindowShouldClose(window)) {&#10;            glfwPollEvents();&#10;&#10;            drawFrame();&#10;        }&#10;&#10;        vkDeviceWaitIdle(device);&#10;    }&#10;&#10;    void drawFrame() {&#10;        vkWaitForFences(device, 1, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);&#10;&#10;        uint32_t imageIndex;&#10;        VkResult result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);&#10;&#10;        // Only reset fence if we are about to submit work&#10;        vkResetFences(device, 1, &amp;inFlightFences[currentFrame]);&#10;&#10;        VkSubmitInfo submitInfo{};&#10;        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;&#10;&#10;        VkSemaphore waitSemaphores[] = {imageAvailableSemaphores[currentFrame]};&#10;        VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};&#10;&#10;        submitInfo.waitSemaphoreCount = 1;&#10;        submitInfo.pWaitSemaphores = waitSemaphores;&#10;        submitInfo.pWaitDstStageMask = waitStages;&#10;&#10;        submitInfo.commandBufferCount = 1;&#10;        submitInfo.pCommandBuffers = &amp;commandBuffers[imageIndex];&#10;&#10;        VkSemaphore signalSemaphores[] = {renderFinishedSemaphores[currentFrame]};&#10;&#10;        submitInfo.signalSemaphoreCount = 1;&#10;        submitInfo.pSignalSemaphores = signalSemaphores;&#10;&#10;        if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to submit draw command buffer!&quot;);&#10;        }&#10;&#10;        VkPresentInfoKHR presentInfo{};&#10;        presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;&#10;&#10;        presentInfo.waitSemaphoreCount = 1;&#10;        presentInfo.pWaitSemaphores = signalSemaphores;&#10;&#10;        VkSwapchainKHR swapChains[] = {swapChain};&#10;&#10;        presentInfo.swapchainCount = 1;&#10;        presentInfo.pSwapchains = swapChains;&#10;        presentInfo.pImageIndices = &amp;imageIndex;&#10;&#10;        vkQueuePresentKHR(presentQueue, &amp;presentInfo);&#10;&#10;        currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;&#10;    }&#10;&#10;    void cleanup() {&#10;        vkDeviceWaitIdle(device);&#10;&#10;        // Clean up synchronization objects&#10;        for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;            vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr);&#10;            vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr);&#10;            vkDestroyFence(device, inFlightFences[i], nullptr);&#10;        }&#10;&#10;        // Clean up command pool (this also frees command buffers)&#10;        vkDestroyCommandPool(device, commandPool, nullptr);&#10;&#10;        // Clean up framebuffers&#10;        for (size_t i = 0; i &lt; swapChainFramebuffers.size(); i++) {&#10;            vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr);&#10;        }&#10;&#10;        // Clean up pipeline&#10;        vkDestroyPipeline(device, graphicsPipeline, nullptr);&#10;        vkDestroyPipelineLayout(device, pipelineLayout, nullptr);&#10;&#10;        // Clean up render pass&#10;        vkDestroyRenderPass(device, renderPass, nullptr);&#10;&#10;        // Clean up image views&#10;        for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) {&#10;            vkDestroyImageView(device, swapChainImageViews[i], nullptr);&#10;        }&#10;&#10;        // Clean up swap chain&#10;        vkDestroySwapchainKHR(device, swapChain, nullptr);&#10;&#10;        // Clean up logical device&#10;        vkDestroyDevice(device, nullptr);&#10;&#10;        // Clean up debug messenger&#10;        if (enableValidationLayers) {&#10;            DestroyDebugUtilsMessengerEXT(instance, debugMessenger, nullptr);&#10;        }&#10;&#10;        // Clean up surface and instance&#10;        vkDestroySurfaceKHR(instance, surface, nullptr);&#10;        vkDestroyInstance(instance, nullptr);&#10;&#10;        // Clean up GLFW&#10;        glfwDestroyWindow(window);&#10;        glfwTerminate();&#10;    }&#10;&#10;    // Helper structures and methods&#10;    struct QueueFamilyIndices {&#10;        std::optional&lt;uint32_t&gt; graphicsFamily;&#10;        std::optional&lt;uint32_t&gt; presentFamily;&#10;&#10;        bool isComplete() {&#10;            return graphicsFamily.has_value() &amp;&amp; presentFamily.has_value();&#10;        }&#10;    };&#10;&#10;    struct SwapChainSupportDetails {&#10;        VkSurfaceCapabilitiesKHR capabilities;&#10;        std::vector&lt;VkSurfaceFormatKHR&gt; formats;&#10;        std::vector&lt;VkPresentModeKHR&gt; presentModes;&#10;    };&#10;&#10;    VkShaderModule createShaderModule(const std::vector&lt;uint32_t&gt;&amp; code) {&#10;        VkShaderModuleCreateInfo createInfo{};&#10;        createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;&#10;        createInfo.codeSize = code.size() * sizeof(uint32_t);&#10;        createInfo.pCode = code.data();&#10;&#10;        VkShaderModule shaderModule;&#10;        if (vkCreateShaderModule(device, &amp;createInfo, nullptr, &amp;shaderModule) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create shader module!&quot;);&#10;        }&#10;&#10;        return shaderModule;&#10;    }&#10;&#10;    bool checkValidationLayerSupport() {&#10;        uint32_t layerCount;&#10;        vkEnumerateInstanceLayerProperties(&amp;layerCount, nullptr);&#10;&#10;        std::vector&lt;VkLayerProperties&gt; availableLayers(layerCount);&#10;        vkEnumerateInstanceLayerProperties(&amp;layerCount, availableLayers.data());&#10;&#10;        for (const char* layerName : validationLayers) {&#10;            bool layerFound = false;&#10;&#10;            for (const auto&amp; layerProperties : availableLayers) {&#10;                if (strcmp(layerName, layerProperties.layerName) == 0) {&#10;                    layerFound = true;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            if (!layerFound) {&#10;                return false;&#10;            }&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    std::vector&lt;const char*&gt; getRequiredExtensions() {&#10;        uint32_t glfwExtensionCount = 0;&#10;        const char** glfwExtensions;&#10;        glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);&#10;&#10;        std::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);&#10;&#10;        if (enableValidationLayers) {&#10;            extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);&#10;        }&#10;&#10;        return extensions;&#10;    }&#10;&#10;    static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,&#10;                                                       VkDebugUtilsMessageTypeFlagsEXT messageType,&#10;                                                       const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,&#10;                                                       void* pUserData) {&#10;        std::cerr &lt;&lt; &quot;validation layer: &quot; &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;&#10;        return VK_FALSE;&#10;    }&#10;&#10;    bool isDeviceSuitable(VkPhysicalDevice device) {&#10;        QueueFamilyIndices indices = findQueueFamilies(device);&#10;&#10;        bool extensionsSupported = checkDeviceExtensionSupport(device);&#10;&#10;        bool swapChainAdequate = false;&#10;        if (extensionsSupported) {&#10;            SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);&#10;            swapChainAdequate = !swapChainSupport.formats.empty() &amp;&amp; !swapChainSupport.presentModes.empty();&#10;        }&#10;&#10;        return indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate;&#10;    }&#10;&#10;    bool checkDeviceExtensionSupport(VkPhysicalDevice device) {&#10;        uint32_t extensionCount;&#10;        vkEnumerateDeviceExtensionProperties(device, nullptr, &amp;extensionCount, nullptr);&#10;&#10;        std::vector&lt;VkExtensionProperties&gt; availableExtensions(extensionCount);&#10;        vkEnumerateDeviceExtensionProperties(device, nullptr, &amp;extensionCount, availableExtensions.data());&#10;&#10;        const std::vector&lt;const char*&gt; deviceExtensions = {&#10;            VK_KHR_SWAPCHAIN_EXTENSION_NAME&#10;        };&#10;&#10;        std::set&lt;std::string&gt; requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());&#10;&#10;        for (const auto&amp; extension : availableExtensions) {&#10;            requiredExtensions.erase(extension.extensionName);&#10;        }&#10;&#10;        return requiredExtensions.empty();&#10;    }&#10;&#10;    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {&#10;        QueueFamilyIndices indices;&#10;&#10;        uint32_t queueFamilyCount = 0;&#10;        vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, nullptr);&#10;&#10;        std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount);&#10;        vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data());&#10;&#10;        int i = 0;&#10;        for (const auto&amp; queueFamily : queueFamilies) {&#10;            if (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) {&#10;                indices.graphicsFamily = i;&#10;            }&#10;&#10;            VkBool32 presentSupport = false;&#10;            vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &amp;presentSupport);&#10;&#10;            if (presentSupport) {&#10;                indices.presentFamily = i;&#10;            }&#10;&#10;            if (indices.isComplete()) {&#10;                break;&#10;            }&#10;&#10;            i++;&#10;        }&#10;&#10;        return indices;&#10;    }&#10;&#10;    SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) {&#10;        SwapChainSupportDetails details;&#10;&#10;        vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &amp;details.capabilities);&#10;&#10;        uint32_t formatCount;&#10;        vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, nullptr);&#10;&#10;        if (formatCount != 0) {&#10;            details.formats.resize(formatCount);&#10;            vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, details.formats.data());&#10;        }&#10;&#10;        uint32_t presentModeCount;&#10;        vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, nullptr);&#10;&#10;        if (presentModeCount != 0) {&#10;            details.presentModes.resize(presentModeCount);&#10;            vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, details.presentModes.data());&#10;        }&#10;&#10;        return details;&#10;    }&#10;&#10;    VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats) {&#10;        for (const auto&amp; availableFormat : availableFormats) {&#10;            if (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {&#10;                return availableFormat;&#10;            }&#10;        }&#10;&#10;        return availableFormats[0];&#10;    }&#10;&#10;    VkPresentModeKHR chooseSwapPresentMode(const std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes) {&#10;        for (const auto&amp; availablePresentMode : availablePresentModes) {&#10;            if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) {&#10;                return availablePresentMode;&#10;            }&#10;        }&#10;&#10;        return VK_PRESENT_MODE_FIFO_KHR;&#10;    }&#10;&#10;    VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp; capabilities) {&#10;        if (capabilities.currentExtent.width != UINT32_MAX) {&#10;            return capabilities.currentExtent;&#10;        } else {&#10;            int width, height;&#10;            glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;&#10;            VkExtent2D actualExtent = {&#10;                static_cast&lt;uint32_t&gt;(width),&#10;                static_cast&lt;uint32_t&gt;(height)&#10;            };&#10;&#10;            actualExtent.width = std::clamp(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);&#10;            actualExtent.height = std::clamp(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);&#10;&#10;            return actualExtent;&#10;        }&#10;    }&#10;&#10;    // Debug extension function loaders&#10;    VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) {&#10;        auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkCreateDebugUtilsMessengerEXT&quot;);&#10;        if (func != nullptr) {&#10;            return func(instance, pCreateInfo, pAllocator, pDebugMessenger);&#10;        } else {&#10;            return VK_ERROR_EXTENSION_NOT_PRESENT;&#10;        }&#10;    }&#10;&#10;    void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) {&#10;        auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkDestroyDebugUtilsMessengerEXT&quot;);&#10;        if (func != nullptr) {&#10;            func(instance, debugMessenger, pAllocator);&#10;        }&#10;    }&#10;};&#10;&#10;int main() {&#10;    ShaderPlaygroundApp app;&#10;&#10;    try {&#10;        app.run();&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return EXIT_FAILURE;&#10;    }&#10;&#10;    return EXIT_SUCCESS;&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;iostream&gt;&#10;#include &lt;fstream&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;cstdlib&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;limits&gt;&#10;#include &lt;array&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;set&gt;&#10;&#10;#define GLFW_INCLUDE_VULKAN&#10;#include &lt;GLFW/glfw3.h&gt;&#10;&#10;#include &quot;../ShaderLoader/Public/ShaderLoader.h&quot;&#10;#include &quot;../ShaderLoader/Public/IShaderCompiler.h&quot;&#10;&#10;constexpr uint32_t WIDTH = 800;&#10;constexpr uint32_t HEIGHT = 600;&#10;constexpr int MAX_FRAMES_IN_FLIGHT = 2;&#10;&#10;const std::vector&lt;const char*&gt; validationLayers = {&#10;    &quot;VK_LAYER_KHRONOS_validation&quot;&#10;};&#10;&#10;#ifdef NDEBUG&#10;constexpr bool enableValidationLayers = false;&#10;#else&#10;constexpr bool enableValidationLayers = true;&#10;#endif&#10;&#10;class ShaderPlaygroundApp {&#10;public:&#10;    void run() {&#10;        initWindow();&#10;        initVulkan();&#10;        mainLoop();&#10;        cleanup();&#10;    }&#10;&#10;private:&#10;    GLFWwindow* window = nullptr;&#10;&#10;    VkInstance instance = VK_NULL_HANDLE;&#10;    VkDebugUtilsMessengerEXT debugMessenger = VK_NULL_HANDLE;&#10;    VkSurfaceKHR surface = VK_NULL_HANDLE;&#10;&#10;    VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;&#10;    VkDevice device = VK_NULL_HANDLE;&#10;&#10;    VkQueue graphicsQueue = VK_NULL_HANDLE;&#10;    VkQueue presentQueue = VK_NULL_HANDLE;&#10;    uint32_t graphicsQueueFamily = UINT32_MAX;&#10;    uint32_t presentQueueFamily = UINT32_MAX;&#10;&#10;    VkSwapchainKHR swapChain = VK_NULL_HANDLE;&#10;    std::vector&lt;VkImage&gt; swapChainImages;&#10;    VkFormat swapChainImageFormat;&#10;    VkExtent2D swapChainExtent;&#10;    std::vector&lt;VkImageView&gt; swapChainImageViews;&#10;&#10;    VkRenderPass renderPass = VK_NULL_HANDLE;&#10;    VkPipelineLayout pipelineLayout = VK_NULL_HANDLE;&#10;    VkPipeline graphicsPipeline = VK_NULL_HANDLE;&#10;&#10;    std::vector&lt;VkFramebuffer&gt; swapChainFramebuffers;&#10;&#10;    VkCommandPool commandPool = VK_NULL_HANDLE;&#10;    std::vector&lt;VkCommandBuffer&gt; commandBuffers;&#10;&#10;    std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;&#10;    std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;&#10;    std::vector&lt;VkFence&gt; inFlightFences;&#10;    uint32_t currentFrame = 0;&#10;&#10;    bool framebufferResized = false;&#10;&#10;    // Shader data&#10;    std::vector&lt;uint32_t&gt; vertexShaderCode;&#10;    std::vector&lt;uint32_t&gt; fragmentShaderCode;&#10;&#10;    void initWindow() {&#10;        glfwInit();&#10;        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);&#10;        glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);&#10;        glfwWindowHint(GLFW_VISIBLE, GLFW_TRUE);  // Ensure window is visible&#10;&#10;        window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Shader Playground - GLFW Triangle&quot;, nullptr, nullptr);&#10;        if (!window) {&#10;            throw std::runtime_error(&quot;Failed to create GLFW window!&quot;);&#10;        }&#10;        &#10;        glfwSetWindowUserPointer(window, this);&#10;        glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);&#10;        &#10;        // Show the window and bring it to front&#10;        glfwShowWindow(window);&#10;        glfwFocusWindow(window);&#10;        &#10;        std::cout &lt;&lt; &quot;Window created successfully!&quot; &lt;&lt; std::endl;&#10;    }&#10;&#10;    static void framebufferResizeCallback(GLFWwindow* window, int width, int height) {&#10;        auto app = reinterpret_cast&lt;ShaderPlaygroundApp*&gt;(glfwGetWindowUserPointer(window));&#10;        app-&gt;framebufferResized = true;&#10;    }&#10;&#10;    void initVulkan() {&#10;        loadShaders();&#10;        createInstance();&#10;        setupDebugMessenger();&#10;        createSurface();&#10;        pickPhysicalDevice();&#10;        createLogicalDevice();&#10;        createSwapChain();&#10;        createImageViews();&#10;        createRenderPass();&#10;        createGraphicsPipeline();&#10;        createFramebuffers();&#10;        createCommandPool();&#10;        createCommandBuffers();&#10;        createSyncObjects();&#10;    }&#10;&#10;    void loadShaders() {&#10;        std::cout &lt;&lt; &quot;Loading shaders...&quot; &lt;&lt; std::endl;&#10;&#10;        auto compiler = ShaderLoader::createDefaultCompiler();&#10;        ShaderLoader::ShaderLoader loader(std::move(compiler));&#10;&#10;        // Load vertex shader&#10;        std::string vertexPath = &quot;/home/charlie/CLionProjects/ShaderLoader/shaders/triangle.vert.spv&quot;;&#10;        if (loader.loadShader(vertexPath)) {&#10;            auto* vertexModule = loader.getModule(vertexPath);&#10;            if (vertexModule &amp;&amp; !vertexModule-&gt;spirv.empty()) {&#10;                vertexShaderCode = vertexModule-&gt;spirv;&#10;                std::cout &lt;&lt; &quot;Successfully loaded vertex shader (&quot; &lt;&lt; vertexShaderCode.size() &lt;&lt; &quot; words)&quot; &lt;&lt; std::endl;&#10;            }&#10;        }&#10;&#10;        // Load fragment shader&#10;        std::string fragmentPath = &quot;/home/charlie/CLionProjects/ShaderLoader/shaders/triangle.frag.spv&quot;;&#10;        if (loader.loadShader(fragmentPath)) {&#10;            auto* fragmentModule = loader.getModule(fragmentPath);&#10;            if (fragmentModule &amp;&amp; !fragmentModule-&gt;spirv.empty()) {&#10;                fragmentShaderCode = fragmentModule-&gt;spirv;&#10;                std::cout &lt;&lt; &quot;Successfully loaded fragment shader (&quot; &lt;&lt; fragmentShaderCode.size() &lt;&lt; &quot; words)&quot; &lt;&lt; std::endl;&#10;            }&#10;        }&#10;&#10;        if (vertexShaderCode.empty() || fragmentShaderCode.empty()) {&#10;            throw std::runtime_error(&quot;Failed to load shaders!&quot;);&#10;        }&#10;    }&#10;&#10;    void createInstance() {&#10;        if (enableValidationLayers &amp;&amp; !checkValidationLayerSupport()) {&#10;            throw std::runtime_error(&quot;validation layers requested, but not available!&quot;);&#10;        }&#10;&#10;        VkApplicationInfo appInfo{};&#10;        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;&#10;        appInfo.pApplicationName = &quot;Shader Playground&quot;;&#10;        appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);&#10;        appInfo.pEngineName = &quot;No Engine&quot;;&#10;        appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);&#10;        // Change to Vulkan 1.1 to support SPIR-V 1.3&#10;        appInfo.apiVersion = VK_API_VERSION_1_1;&#10;&#10;        VkInstanceCreateInfo createInfo{};&#10;        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;&#10;        createInfo.pApplicationInfo = &amp;appInfo;&#10;&#10;        auto extensions = getRequiredExtensions();&#10;        createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size());&#10;        createInfo.ppEnabledExtensionNames = extensions.data();&#10;&#10;        VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo{};&#10;        if (enableValidationLayers) {&#10;            createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;(validationLayers.size());&#10;            createInfo.ppEnabledLayerNames = validationLayers.data();&#10;&#10;            populateDebugMessengerCreateInfo(debugCreateInfo);&#10;            createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &amp;debugCreateInfo;&#10;        } else {&#10;            createInfo.enabledLayerCount = 0;&#10;            createInfo.pNext = nullptr;&#10;        }&#10;&#10;        if (vkCreateInstance(&amp;createInfo, nullptr, &amp;instance) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create instance!&quot;);&#10;        }&#10;    }&#10;&#10;    void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp; createInfo) {&#10;        createInfo = {};&#10;        createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;&#10;        createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;&#10;        createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;&#10;        createInfo.pfnUserCallback = debugCallback;&#10;    }&#10;&#10;    void setupDebugMessenger() {&#10;        if (!enableValidationLayers) return;&#10;&#10;        VkDebugUtilsMessengerCreateInfoEXT createInfo;&#10;        populateDebugMessengerCreateInfo(createInfo);&#10;&#10;        if (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, nullptr, &amp;debugMessenger) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to set up debug messenger!&quot;);&#10;        }&#10;    }&#10;&#10;    void createSurface() {&#10;        if (glfwCreateWindowSurface(instance, window, nullptr, &amp;surface) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create window surface!&quot;);&#10;        }&#10;    }&#10;&#10;    void pickPhysicalDevice() {&#10;        uint32_t deviceCount = 0;&#10;        vkEnumeratePhysicalDevices(instance, &amp;deviceCount, nullptr);&#10;&#10;        if (deviceCount == 0) {&#10;            throw std::runtime_error(&quot;failed to find GPUs with Vulkan support!&quot;);&#10;        }&#10;&#10;        std::vector&lt;VkPhysicalDevice&gt; devices(deviceCount);&#10;        vkEnumeratePhysicalDevices(instance, &amp;deviceCount, devices.data());&#10;&#10;        for (const auto&amp; device : devices) {&#10;            if (isDeviceSuitable(device)) {&#10;                physicalDevice = device;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (physicalDevice == VK_NULL_HANDLE) {&#10;            throw std::runtime_error(&quot;failed to find a suitable GPU!&quot;);&#10;        }&#10;    }&#10;&#10;    void createLogicalDevice() {&#10;        QueueFamilyIndices indices = findQueueFamilies(physicalDevice);&#10;&#10;        std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;&#10;        std::set&lt;uint32_t&gt; uniqueQueueFamilies = {indices.graphicsFamily.value(), indices.presentFamily.value()};&#10;&#10;        float queuePriority = 1.0f;&#10;        for (uint32_t queueFamily : uniqueQueueFamilies) {&#10;            VkDeviceQueueCreateInfo queueCreateInfo{};&#10;            queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;&#10;            queueCreateInfo.queueFamilyIndex = queueFamily;&#10;            queueCreateInfo.queueCount = 1;&#10;            queueCreateInfo.pQueuePriorities = &amp;queuePriority;&#10;            queueCreateInfos.push_back(queueCreateInfo);&#10;        }&#10;&#10;        VkPhysicalDeviceFeatures deviceFeatures{};&#10;&#10;        VkDeviceCreateInfo createInfo{};&#10;        createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;&#10;&#10;        createInfo.queueCreateInfoCount = static_cast&lt;uint32_t&gt;(queueCreateInfos.size());&#10;        createInfo.pQueueCreateInfos = queueCreateInfos.data();&#10;&#10;        createInfo.pEnabledFeatures = &amp;deviceFeatures;&#10;&#10;        const std::vector&lt;const char*&gt; deviceExtensions = {&#10;            VK_KHR_SWAPCHAIN_EXTENSION_NAME&#10;        };&#10;&#10;        createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(deviceExtensions.size());&#10;        createInfo.ppEnabledExtensionNames = deviceExtensions.data();&#10;&#10;        if (enableValidationLayers) {&#10;            createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;(validationLayers.size());&#10;            createInfo.ppEnabledLayerNames = validationLayers.data();&#10;        } else {&#10;            createInfo.enabledLayerCount = 0;&#10;        }&#10;&#10;        if (vkCreateDevice(physicalDevice, &amp;createInfo, nullptr, &amp;device) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create logical device!&quot;);&#10;        }&#10;&#10;        vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &amp;graphicsQueue);&#10;        vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &amp;presentQueue);&#10;    }&#10;&#10;    void createSwapChain() {&#10;        SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice);&#10;&#10;        VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);&#10;        VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);&#10;        VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);&#10;&#10;        uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1;&#10;        if (swapChainSupport.capabilities.maxImageCount &gt; 0 &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) {&#10;            imageCount = swapChainSupport.capabilities.maxImageCount;&#10;        }&#10;&#10;        VkSwapchainCreateInfoKHR createInfo{};&#10;        createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;&#10;        createInfo.surface = surface;&#10;&#10;        createInfo.minImageCount = imageCount;&#10;        createInfo.imageFormat = surfaceFormat.format;&#10;        createInfo.imageColorSpace = surfaceFormat.colorSpace;&#10;        createInfo.imageExtent = extent;&#10;        createInfo.imageArrayLayers = 1;&#10;        createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;&#10;&#10;        QueueFamilyIndices indices = findQueueFamilies(physicalDevice);&#10;        uint32_t queueFamilyIndices[] = {indices.graphicsFamily.value(), indices.presentFamily.value()};&#10;&#10;        if (indices.graphicsFamily != indices.presentFamily) {&#10;            createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;&#10;            createInfo.queueFamilyIndexCount = 2;&#10;            createInfo.pQueueFamilyIndices = queueFamilyIndices;&#10;        } else {&#10;            createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;&#10;        }&#10;&#10;        createInfo.preTransform = swapChainSupport.capabilities.currentTransform;&#10;        createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;&#10;        createInfo.presentMode = presentMode;&#10;        createInfo.clipped = VK_TRUE;&#10;&#10;        if (vkCreateSwapchainKHR(device, &amp;createInfo, nullptr, &amp;swapChain) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create swap chain!&quot;);&#10;        }&#10;&#10;        vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, nullptr);&#10;        swapChainImages.resize(imageCount);&#10;        vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, swapChainImages.data());&#10;&#10;        swapChainImageFormat = surfaceFormat.format;&#10;        swapChainExtent = extent;&#10;    }&#10;&#10;    void createImageViews() {&#10;        swapChainImageViews.resize(swapChainImages.size());&#10;&#10;        for (size_t i = 0; i &lt; swapChainImages.size(); i++) {&#10;            VkImageViewCreateInfo createInfo{};&#10;            createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;&#10;            createInfo.image = swapChainImages[i];&#10;            createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;&#10;            createInfo.format = swapChainImageFormat;&#10;            createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;&#10;            createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;&#10;            createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;&#10;            createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;&#10;            createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;&#10;            createInfo.subresourceRange.baseMipLevel = 0;&#10;            createInfo.subresourceRange.levelCount = 1;&#10;            createInfo.subresourceRange.baseArrayLayer = 0;&#10;            createInfo.subresourceRange.layerCount = 1;&#10;&#10;            if (vkCreateImageView(device, &amp;createInfo, nullptr, &amp;swapChainImageViews[i]) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to create image views!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void createRenderPass() {&#10;        VkAttachmentDescription colorAttachment{};&#10;        colorAttachment.format = swapChainImageFormat;&#10;        colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;&#10;        colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;&#10;        colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;&#10;        colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;&#10;        colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;&#10;        colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;&#10;        colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;&#10;&#10;        VkAttachmentReference colorAttachmentRef{};&#10;        colorAttachmentRef.attachment = 0;&#10;        colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;&#10;&#10;        VkSubpassDescription subpass{};&#10;        subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;&#10;        subpass.colorAttachmentCount = 1;&#10;        subpass.pColorAttachments = &amp;colorAttachmentRef;&#10;&#10;        VkSubpassDependency dependency{};&#10;        dependency.srcSubpass = VK_SUBPASS_EXTERNAL;&#10;        dependency.dstSubpass = 0;&#10;        dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;&#10;        dependency.srcAccessMask = 0;&#10;        dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;&#10;        dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;&#10;&#10;        VkRenderPassCreateInfo renderPassInfo{};&#10;        renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;&#10;        renderPassInfo.attachmentCount = 1;&#10;        renderPassInfo.pAttachments = &amp;colorAttachment;&#10;        renderPassInfo.subpassCount = 1;&#10;        renderPassInfo.pSubpasses = &amp;subpass;&#10;        renderPassInfo.dependencyCount = 1;&#10;        renderPassInfo.pDependencies = &amp;dependency;&#10;&#10;        if (vkCreateRenderPass(device, &amp;renderPassInfo, nullptr, &amp;renderPass) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create render pass!&quot;);&#10;        }&#10;    }&#10;&#10;    void createGraphicsPipeline() {&#10;        // Create shader modules&#10;        VkShaderModule vertShaderModule = createShaderModule(vertexShaderCode);&#10;        VkShaderModule fragShaderModule = createShaderModule(fragmentShaderCode);&#10;&#10;        VkPipelineShaderStageCreateInfo vertShaderStageInfo{};&#10;        vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;&#10;        vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;&#10;        vertShaderStageInfo.module = vertShaderModule;&#10;        vertShaderStageInfo.pName = &quot;main&quot;;&#10;&#10;        VkPipelineShaderStageCreateInfo fragShaderStageInfo{};&#10;        fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;&#10;        fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;&#10;        fragShaderStageInfo.module = fragShaderModule;&#10;        fragShaderStageInfo.pName = &quot;main&quot;;&#10;&#10;        VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};&#10;&#10;        // IMPORTANT: No vertex input for hardcoded triangle&#10;        VkPipelineVertexInputStateCreateInfo vertexInputInfo{};&#10;        vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;&#10;        vertexInputInfo.vertexBindingDescriptionCount = 0;&#10;        vertexInputInfo.vertexAttributeDescriptionCount = 0;&#10;&#10;        VkPipelineInputAssemblyStateCreateInfo inputAssembly{};&#10;        inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;&#10;        inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;&#10;        inputAssembly.primitiveRestartEnable = VK_FALSE;&#10;&#10;        VkPipelineViewportStateCreateInfo viewportState{};&#10;        viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;&#10;        viewportState.viewportCount = 1;&#10;        viewportState.scissorCount = 1;&#10;&#10;        VkPipelineRasterizationStateCreateInfo rasterizer{};&#10;        rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;&#10;        rasterizer.depthClampEnable = VK_FALSE;&#10;        rasterizer.rasterizerDiscardEnable = VK_FALSE;&#10;        rasterizer.polygonMode = VK_POLYGON_MODE_FILL;&#10;        rasterizer.lineWidth = 1.0f;&#10;        rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;&#10;        rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE; // Match shader triangle winding&#10;        rasterizer.depthBiasEnable = VK_FALSE;&#10;&#10;        VkPipelineMultisampleStateCreateInfo multisampling{};&#10;        multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;&#10;        multisampling.sampleShadingEnable = VK_FALSE;&#10;        multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;&#10;&#10;        VkPipelineColorBlendAttachmentState colorBlendAttachment{};&#10;        colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;&#10;        colorBlendAttachment.blendEnable = VK_FALSE;&#10;&#10;        VkPipelineColorBlendStateCreateInfo colorBlending{};&#10;        colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;&#10;        colorBlending.logicOpEnable = VK_FALSE;&#10;        colorBlending.logicOp = VK_LOGIC_OP_COPY;&#10;        colorBlending.attachmentCount = 1;&#10;        colorBlending.pAttachments = &amp;colorBlendAttachment;&#10;&#10;        VkDynamicState dynamicStates[] = {&#10;            VK_DYNAMIC_STATE_VIEWPORT,&#10;            VK_DYNAMIC_STATE_SCISSOR&#10;        };&#10;&#10;        VkPipelineDynamicStateCreateInfo dynamicState{};&#10;        dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;&#10;        dynamicState.dynamicStateCount = 2;&#10;        dynamicState.pDynamicStates = dynamicStates;&#10;&#10;        VkPipelineLayoutCreateInfo pipelineLayoutInfo{};&#10;        pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;&#10;        pipelineLayoutInfo.setLayoutCount = 0;&#10;        pipelineLayoutInfo.pushConstantRangeCount = 0;&#10;&#10;        if (vkCreatePipelineLayout(device, &amp;pipelineLayoutInfo, nullptr, &amp;pipelineLayout) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create pipeline layout!&quot;);&#10;        }&#10;&#10;        VkGraphicsPipelineCreateInfo pipelineInfo{};&#10;        pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;&#10;        pipelineInfo.stageCount = 2;&#10;        pipelineInfo.pStages = shaderStages;&#10;        pipelineInfo.pVertexInputState = &amp;vertexInputInfo;&#10;        pipelineInfo.pInputAssemblyState = &amp;inputAssembly;&#10;        pipelineInfo.pViewportState = &amp;viewportState;&#10;        pipelineInfo.pRasterizationState = &amp;rasterizer;&#10;        pipelineInfo.pMultisampleState = &amp;multisampling;&#10;        pipelineInfo.pColorBlendState = &amp;colorBlending;&#10;        pipelineInfo.pDynamicState = &amp;dynamicState;&#10;        pipelineInfo.layout = pipelineLayout;&#10;        pipelineInfo.renderPass = renderPass;&#10;        pipelineInfo.subpass = 0;&#10;        pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;&#10;&#10;        if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &amp;pipelineInfo, nullptr, &amp;graphicsPipeline) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create graphics pipeline!&quot;);&#10;        }&#10;&#10;        vkDestroyShaderModule(device, fragShaderModule, nullptr);&#10;        vkDestroyShaderModule(device, vertShaderModule, nullptr);&#10;&#10;        std::cout &lt;&lt; &quot;Successfully created graphics pipeline!&quot; &lt;&lt; std::endl;&#10;    }&#10;&#10;    void createFramebuffers() {&#10;        swapChainFramebuffers.resize(swapChainImageViews.size());&#10;&#10;        for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) {&#10;            VkImageView attachments[] = {&#10;                swapChainImageViews[i]&#10;            };&#10;&#10;            VkFramebufferCreateInfo framebufferInfo{};&#10;            framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;&#10;            framebufferInfo.renderPass = renderPass;&#10;            framebufferInfo.attachmentCount = 1;&#10;            framebufferInfo.pAttachments = attachments;&#10;            framebufferInfo.width = swapChainExtent.width;&#10;            framebufferInfo.height = swapChainExtent.height;&#10;            framebufferInfo.layers = 1;&#10;&#10;            if (vkCreateFramebuffer(device, &amp;framebufferInfo, nullptr, &amp;swapChainFramebuffers[i]) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to create framebuffer!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void createCommandPool() {&#10;        QueueFamilyIndices indices = findQueueFamilies(physicalDevice);&#10;&#10;        VkCommandPoolCreateInfo poolInfo{};&#10;        poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;&#10;        poolInfo.queueFamilyIndex = indices.graphicsFamily.value();&#10;        poolInfo.flags = 0; // Optional&#10;&#10;        if (vkCreateCommandPool(device, &amp;poolInfo, nullptr, &amp;commandPool) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create command pool!&quot;);&#10;        }&#10;    }&#10;&#10;    void createCommandBuffers() {&#10;        commandBuffers.resize(swapChainFramebuffers.size());&#10;&#10;        VkCommandBufferAllocateInfo allocInfo{};&#10;        allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;&#10;        allocInfo.commandPool = commandPool;&#10;        allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;&#10;        allocInfo.commandBufferCount = static_cast&lt;uint32_t&gt;(commandBuffers.size());&#10;&#10;        if (vkAllocateCommandBuffers(device, &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to allocate command buffers!&quot;);&#10;        }&#10;&#10;        for (size_t i = 0; i &lt; commandBuffers.size(); i++) {&#10;            VkCommandBufferBeginInfo beginInfo{};&#10;            beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;&#10;&#10;            if (vkBeginCommandBuffer(commandBuffers[i], &amp;beginInfo) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to begin recording command buffer!&quot;);&#10;            }&#10;&#10;            VkRenderPassBeginInfo renderPassInfo{};&#10;            renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;&#10;            renderPassInfo.renderPass = renderPass;&#10;            renderPassInfo.framebuffer = swapChainFramebuffers[i];&#10;            renderPassInfo.renderArea.offset = {0, 0};&#10;            renderPassInfo.renderArea.extent = swapChainExtent;&#10;&#10;            VkClearValue clearColor = {0.0f, 0.0f, 0.0f, 1.0f};&#10;            renderPassInfo.clearValueCount = 1;&#10;            renderPassInfo.pClearValues = &amp;clearColor;&#10;&#10;            vkCmdBeginRenderPass(commandBuffers[i], &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);&#10;&#10;            vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);&#10;&#10;            // Set dynamic viewport&#10;            VkViewport viewport{};&#10;            viewport.x = 0.0f;&#10;            viewport.y = 0.0f;&#10;            viewport.width = static_cast&lt;float&gt;(swapChainExtent.width);&#10;            viewport.height = static_cast&lt;float&gt;(swapChainExtent.height);&#10;            viewport.minDepth = 0.0f;&#10;            viewport.maxDepth = 1.0f;&#10;            vkCmdSetViewport(commandBuffers[i], 0, 1, &amp;viewport);&#10;&#10;            // Set dynamic scissor&#10;            VkRect2D scissor{};&#10;            scissor.offset = {0, 0};&#10;            scissor.extent = swapChainExtent;&#10;            vkCmdSetScissor(commandBuffers[i], 0, 1, &amp;scissor);&#10;&#10;            // IMPORTANT: No vertex buffer binding for hardcoded triangle&#10;            vkCmdDraw(commandBuffers[i], 3, 1, 0, 0);&#10;&#10;            vkCmdEndRenderPass(commandBuffers[i]);&#10;&#10;            if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to record command buffer!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void createSyncObjects() {&#10;        imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);&#10;        renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);&#10;        inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);&#10;&#10;        VkSemaphoreCreateInfo semaphoreInfo{};&#10;        semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;&#10;&#10;        for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;            if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS ||&#10;                vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to create semaphores!&quot;);&#10;            }&#10;&#10;            VkFenceCreateInfo fenceInfo{};&#10;            fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;&#10;            fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;&#10;&#10;            if (vkCreateFence(device, &amp;fenceInfo, nullptr, &amp;inFlightFences[i]) != VK_SUCCESS) {&#10;                throw std::runtime_error(&quot;failed to create fence!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void mainLoop() {&#10;        while (!glfwWindowShouldClose(window)) {&#10;            glfwPollEvents();&#10;&#10;            drawFrame();&#10;        }&#10;&#10;        vkDeviceWaitIdle(device);&#10;    }&#10;&#10;    void drawFrame() {&#10;        vkWaitForFences(device, 1, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);&#10;&#10;        uint32_t imageIndex;&#10;        VkResult result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);&#10;&#10;        // Only reset fence if we are about to submit work&#10;        vkResetFences(device, 1, &amp;inFlightFences[currentFrame]);&#10;&#10;        VkSubmitInfo submitInfo{};&#10;        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;&#10;&#10;        VkSemaphore waitSemaphores[] = {imageAvailableSemaphores[currentFrame]};&#10;        VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};&#10;&#10;        submitInfo.waitSemaphoreCount = 1;&#10;        submitInfo.pWaitSemaphores = waitSemaphores;&#10;        submitInfo.pWaitDstStageMask = waitStages;&#10;&#10;        submitInfo.commandBufferCount = 1;&#10;        submitInfo.pCommandBuffers = &amp;commandBuffers[imageIndex];&#10;&#10;        VkSemaphore signalSemaphores[] = {renderFinishedSemaphores[currentFrame]};&#10;&#10;        submitInfo.signalSemaphoreCount = 1;&#10;        submitInfo.pSignalSemaphores = signalSemaphores;&#10;&#10;        if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to submit draw command buffer!&quot;);&#10;        }&#10;&#10;        VkPresentInfoKHR presentInfo{};&#10;        presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;&#10;&#10;        presentInfo.waitSemaphoreCount = 1;&#10;        presentInfo.pWaitSemaphores = signalSemaphores;&#10;&#10;        VkSwapchainKHR swapChains[] = {swapChain};&#10;&#10;        presentInfo.swapchainCount = 1;&#10;        presentInfo.pSwapchains = swapChains;&#10;        presentInfo.pImageIndices = &amp;imageIndex;&#10;&#10;        vkQueuePresentKHR(presentQueue, &amp;presentInfo);&#10;&#10;        currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;&#10;    }&#10;&#10;    void cleanup() {&#10;        vkDeviceWaitIdle(device);&#10;&#10;        // Clean up synchronization objects&#10;        for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;            vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr);&#10;            vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr);&#10;            vkDestroyFence(device, inFlightFences[i], nullptr);&#10;        }&#10;&#10;        // Clean up command pool (this also frees command buffers)&#10;        vkDestroyCommandPool(device, commandPool, nullptr);&#10;&#10;        // Clean up framebuffers&#10;        for (size_t i = 0; i &lt; swapChainFramebuffers.size(); i++) {&#10;            vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr);&#10;        }&#10;&#10;        // Clean up pipeline&#10;        vkDestroyPipeline(device, graphicsPipeline, nullptr);&#10;        vkDestroyPipelineLayout(device, pipelineLayout, nullptr);&#10;&#10;        // Clean up render pass&#10;        vkDestroyRenderPass(device, renderPass, nullptr);&#10;&#10;        // Clean up image views&#10;        for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) {&#10;            vkDestroyImageView(device, swapChainImageViews[i], nullptr);&#10;        }&#10;&#10;        // Clean up swap chain&#10;        vkDestroySwapchainKHR(device, swapChain, nullptr);&#10;&#10;        // Clean up logical device&#10;        vkDestroyDevice(device, nullptr);&#10;&#10;        // Clean up debug messenger&#10;        if (enableValidationLayers) {&#10;            DestroyDebugUtilsMessengerEXT(instance, debugMessenger, nullptr);&#10;        }&#10;&#10;        // Clean up surface and instance&#10;        vkDestroySurfaceKHR(instance, surface, nullptr);&#10;        vkDestroyInstance(instance, nullptr);&#10;&#10;        // Clean up GLFW&#10;        glfwDestroyWindow(window);&#10;        glfwTerminate();&#10;    }&#10;&#10;    // Helper structures and methods&#10;    struct QueueFamilyIndices {&#10;        std::optional&lt;uint32_t&gt; graphicsFamily;&#10;        std::optional&lt;uint32_t&gt; presentFamily;&#10;&#10;        bool isComplete() {&#10;            return graphicsFamily.has_value() &amp;&amp; presentFamily.has_value();&#10;        }&#10;    };&#10;&#10;    struct SwapChainSupportDetails {&#10;        VkSurfaceCapabilitiesKHR capabilities;&#10;        std::vector&lt;VkSurfaceFormatKHR&gt; formats;&#10;        std::vector&lt;VkPresentModeKHR&gt; presentModes;&#10;    };&#10;&#10;    VkShaderModule createShaderModule(const std::vector&lt;uint32_t&gt;&amp; code) {&#10;        VkShaderModuleCreateInfo createInfo{};&#10;        createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;&#10;        createInfo.codeSize = code.size() * sizeof(uint32_t);&#10;        createInfo.pCode = code.data();&#10;&#10;        VkShaderModule shaderModule;&#10;        if (vkCreateShaderModule(device, &amp;createInfo, nullptr, &amp;shaderModule) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create shader module!&quot;);&#10;        }&#10;&#10;        return shaderModule;&#10;    }&#10;&#10;    bool checkValidationLayerSupport() {&#10;        uint32_t layerCount;&#10;        vkEnumerateInstanceLayerProperties(&amp;layerCount, nullptr);&#10;&#10;        std::vector&lt;VkLayerProperties&gt; availableLayers(layerCount);&#10;        vkEnumerateInstanceLayerProperties(&amp;layerCount, availableLayers.data());&#10;&#10;        for (const char* layerName : validationLayers) {&#10;            bool layerFound = false;&#10;&#10;            for (const auto&amp; layerProperties : availableLayers) {&#10;                if (strcmp(layerName, layerProperties.layerName) == 0) {&#10;                    layerFound = true;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            if (!layerFound) {&#10;                return false;&#10;            }&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    std::vector&lt;const char*&gt; getRequiredExtensions() {&#10;        uint32_t glfwExtensionCount = 0;&#10;        const char** glfwExtensions;&#10;        glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);&#10;&#10;        std::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);&#10;&#10;        if (enableValidationLayers) {&#10;            extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);&#10;        }&#10;&#10;        return extensions;&#10;    }&#10;&#10;    static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,&#10;                                                       VkDebugUtilsMessageTypeFlagsEXT messageType,&#10;                                                       const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,&#10;                                                       void* pUserData) {&#10;        std::cerr &lt;&lt; &quot;validation layer: &quot; &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;&#10;        return VK_FALSE;&#10;    }&#10;&#10;    bool isDeviceSuitable(VkPhysicalDevice device) {&#10;        QueueFamilyIndices indices = findQueueFamilies(device);&#10;&#10;        bool extensionsSupported = checkDeviceExtensionSupport(device);&#10;&#10;        bool swapChainAdequate = false;&#10;        if (extensionsSupported) {&#10;            SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);&#10;            swapChainAdequate = !swapChainSupport.formats.empty() &amp;&amp; !swapChainSupport.presentModes.empty();&#10;        }&#10;&#10;        return indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate;&#10;    }&#10;&#10;    bool checkDeviceExtensionSupport(VkPhysicalDevice device) {&#10;        uint32_t extensionCount;&#10;        vkEnumerateDeviceExtensionProperties(device, nullptr, &amp;extensionCount, nullptr);&#10;&#10;        std::vector&lt;VkExtensionProperties&gt; availableExtensions(extensionCount);&#10;        vkEnumerateDeviceExtensionProperties(device, nullptr, &amp;extensionCount, availableExtensions.data());&#10;&#10;        const std::vector&lt;const char*&gt; deviceExtensions = {&#10;            VK_KHR_SWAPCHAIN_EXTENSION_NAME&#10;        };&#10;&#10;        std::set&lt;std::string&gt; requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());&#10;&#10;        for (const auto&amp; extension : availableExtensions) {&#10;            requiredExtensions.erase(extension.extensionName);&#10;        }&#10;&#10;        return requiredExtensions.empty();&#10;    }&#10;&#10;    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {&#10;        QueueFamilyIndices indices;&#10;&#10;        uint32_t queueFamilyCount = 0;&#10;        vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, nullptr);&#10;&#10;        std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount);&#10;        vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data());&#10;&#10;        int i = 0;&#10;        for (const auto&amp; queueFamily : queueFamilies) {&#10;            if (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) {&#10;                indices.graphicsFamily = i;&#10;            }&#10;&#10;            VkBool32 presentSupport = false;&#10;            vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &amp;presentSupport);&#10;&#10;            if (presentSupport) {&#10;                indices.presentFamily = i;&#10;            }&#10;&#10;            if (indices.isComplete()) {&#10;                break;&#10;            }&#10;&#10;            i++;&#10;        }&#10;&#10;        return indices;&#10;    }&#10;&#10;    SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) {&#10;        SwapChainSupportDetails details;&#10;&#10;        vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &amp;details.capabilities);&#10;&#10;        uint32_t formatCount;&#10;        vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, nullptr);&#10;&#10;        if (formatCount != 0) {&#10;            details.formats.resize(formatCount);&#10;            vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, details.formats.data());&#10;        }&#10;&#10;        uint32_t presentModeCount;&#10;        vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, nullptr);&#10;&#10;        if (presentModeCount != 0) {&#10;            details.presentModes.resize(presentModeCount);&#10;            vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, details.presentModes.data());&#10;        }&#10;&#10;        return details;&#10;    }&#10;&#10;    VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats) {&#10;        for (const auto&amp; availableFormat : availableFormats) {&#10;            if (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {&#10;                return availableFormat;&#10;            }&#10;        }&#10;&#10;        return availableFormats[0];&#10;    }&#10;&#10;    VkPresentModeKHR chooseSwapPresentMode(const std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes) {&#10;        for (const auto&amp; availablePresentMode : availablePresentModes) {&#10;            if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) {&#10;                return availablePresentMode;&#10;            }&#10;        }&#10;&#10;        return VK_PRESENT_MODE_FIFO_KHR;&#10;    }&#10;&#10;    VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp; capabilities) {&#10;        if (capabilities.currentExtent.width != UINT32_MAX) {&#10;            return capabilities.currentExtent;&#10;        } else {&#10;            int width, height;&#10;            glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;&#10;            VkExtent2D actualExtent = {&#10;                static_cast&lt;uint32_t&gt;(width),&#10;                static_cast&lt;uint32_t&gt;(height)&#10;            };&#10;&#10;            actualExtent.width = std::clamp(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);&#10;            actualExtent.height = std::clamp(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);&#10;&#10;            return actualExtent;&#10;        }&#10;    }&#10;&#10;    // Debug extension function loaders&#10;    VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) {&#10;        auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkCreateDebugUtilsMessengerEXT&quot;);&#10;        if (func != nullptr) {&#10;            return func(instance, pCreateInfo, pAllocator, pDebugMessenger);&#10;        } else {&#10;            return VK_ERROR_EXTENSION_NOT_PRESENT;&#10;        }&#10;    }&#10;&#10;    void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) {&#10;        auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkDestroyDebugUtilsMessengerEXT&quot;);&#10;        if (func != nullptr) {&#10;            func(instance, debugMessenger, pAllocator);&#10;        }&#10;    }&#10;};&#10;&#10;int main() {&#10;    ShaderPlaygroundApp app;&#10;&#10;    try {&#10;        app.run();&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return EXIT_FAILURE;&#10;    }&#10;&#10;    return EXIT_SUCCESS;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Private/main_triangle_fixed.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Private/main_triangle_fixed.cpp" />
              <option name="originalContent" value="#include &lt;iostream&gt;&#10;#include &lt;fstream&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;cstdlib&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;limits&gt;&#10;#include &lt;array&gt;&#10;&#10;// Use traditional Vulkan-Hpp headers without RAII&#10;#include &lt;vulkan/vulkan.hpp&gt;&#10;&#10;#define GLFW_INCLUDE_VULKAN&#10;#include &lt;GLFW/glfw3.h&gt;&#10;#include &lt;glm/glm.hpp&gt;&#10;&#10;constexpr uint32_t WIDTH = 800;&#10;constexpr uint32_t HEIGHT = 600;&#10;constexpr int MAX_FRAMES_IN_FLIGHT = 2;&#10;&#10;const std::vector validationLayers = {&#10;    &quot;VK_LAYER_KHRONOS_validation&quot;&#10;};&#10;&#10;#ifdef NDEBUG&#10;constexpr bool enableValidationLayers = false;&#10;#else&#10;constexpr bool enableValidationLayers = true;&#10;#endif&#10;&#10;struct Vertex {&#10;    glm::vec2 pos;&#10;    glm::vec3 color;&#10;&#10;    static vk::VertexInputBindingDescription getBindingDescription() {&#10;        return { 0, sizeof(Vertex), vk::VertexInputRate::eVertex };&#10;    }&#10;&#10;    static std::array&lt;vk::VertexInputAttributeDescription, 2&gt; getAttributeDescriptions() {&#10;        return {&#10;            vk::VertexInputAttributeDescription( 0, 0, vk::Format::eR32G32Sfloat, offsetof(Vertex, pos) ),&#10;            vk::VertexInputAttributeDescription( 1, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, color) )&#10;        };&#10;    }&#10;};&#10;&#10;const std::vector&lt;Vertex&gt; vertices = {&#10;    {{-0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}},&#10;    {{0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}},&#10;    {{0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}},&#10;    {{-0.5f, 0.5f}, {1.0f, 1.0f, 1.0f}}&#10;};&#10;&#10;const std::vector&lt;uint16_t&gt; indices = {&#10;    0, 1, 2, 2, 3, 0&#10;};&#10;&#10;class HelloTriangleApplication {&#10;public:&#10;    void run() {&#10;        initWindow();&#10;        initVulkan();&#10;        mainLoop();&#10;        cleanup();&#10;    }&#10;&#10;private:&#10;    GLFWwindow *                     window = nullptr;&#10;    vk::Instance                     instance;&#10;    vk::DebugUtilsMessengerEXT       debugMessenger;&#10;    vk::SurfaceKHR                   surface;&#10;    vk::PhysicalDevice               physicalDevice;&#10;    vk::Device                       device;&#10;    uint32_t                         queueIndex = ~0;&#10;    vk::Queue                        queue;&#10;&#10;    vk::SwapchainKHR swapChain;&#10;    std::vector&lt;vk::Image&gt; swapChainImages;&#10;    vk::Format swapChainImageFormat = vk::Format::eUndefined;&#10;    vk::Extent2D swapChainExtent;&#10;    std::vector&lt;vk::ImageView&gt; swapChainImageViews;&#10;&#10;    vk::PipelineLayout pipelineLayout;&#10;    vk::Pipeline graphicsPipeline;&#10;    vk::RenderPass renderPass;&#10;    std::vector&lt;vk::Framebuffer&gt; swapChainFramebuffers;&#10;&#10;    vk::Buffer vertexBuffer;&#10;    vk::DeviceMemory vertexBufferMemory;&#10;    vk::Buffer indexBuffer;&#10;    vk::DeviceMemory indexBufferMemory;&#10;&#10;    vk::CommandPool commandPool;&#10;    std::vector&lt;vk::CommandBuffer&gt; commandBuffers;&#10;&#10;    std::vector&lt;vk::Semaphore&gt; presentCompleteSemaphore;&#10;    std::vector&lt;vk::Semaphore&gt; renderFinishedSemaphore;&#10;    std::vector&lt;vk::Fence&gt; inFlightFences;&#10;    uint32_t semaphoreIndex = 0;&#10;    uint32_t currentFrame = 0;&#10;&#10;    bool framebufferResized = false;&#10;&#10;    std::vector&lt;const char*&gt; requiredDeviceExtension = {&#10;        vk::KHRSwapchainExtensionName&#10;    };&#10;&#10;    void initWindow() {&#10;        glfwInit();&#10;&#10;        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);&#10;&#10;        window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Vulkan&quot;, nullptr, nullptr);&#10;        glfwSetWindowUserPointer(window, this);&#10;        glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);&#10;    }&#10;&#10;    static void framebufferResizeCallback(GLFWwindow* window, int width, int height) {&#10;        auto app = static_cast&lt;HelloTriangleApplication*&gt;(glfwGetWindowUserPointer(window));&#10;        app-&gt;framebufferResized = true;&#10;    }&#10;&#10;    void initVulkan() {&#10;        createInstance();&#10;        setupDebugMessenger();&#10;        createSurface();&#10;        pickPhysicalDevice();&#10;        createLogicalDevice();&#10;        createSwapChain();&#10;        createImageViews();&#10;        createRenderPass();&#10;        createGraphicsPipeline();&#10;        createFramebuffers();&#10;        createCommandPool();&#10;        createVertexBuffer();&#10;        createIndexBuffer();&#10;        createCommandBuffers();&#10;        createSyncObjects();&#10;    }&#10;&#10;    void mainLoop() {&#10;        while (!glfwWindowShouldClose(window)) {&#10;            glfwPollEvents();&#10;            drawFrame();&#10;        }&#10;&#10;        device.waitIdle();&#10;    }&#10;&#10;    void cleanupSwapChain() {&#10;        for (auto&amp; framebuffer : swapChainFramebuffers) {&#10;            device.destroyFramebuffer(framebuffer);&#10;        }&#10;&#10;        for (auto&amp; imageView : swapChainImageViews) {&#10;            device.destroyImageView(imageView);&#10;        }&#10;        device.destroySwapchainKHR(swapChain);&#10;    }&#10;&#10;    void cleanup() {&#10;        cleanupSwapChain();&#10;&#10;        // Fix: Destroy semaphores with correct loop count&#10;        for (size_t i = 0; i &lt; swapChainImages.size(); i++) {&#10;            device.destroySemaphore(renderFinishedSemaphore[i]);&#10;            device.destroySemaphore(presentCompleteSemaphore[i]);&#10;        }&#10;&#10;        for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;            device.destroyFence(inFlightFences[i]);&#10;        }&#10;&#10;        device.destroyCommandPool(commandPool);&#10;        device.destroyPipeline(graphicsPipeline);&#10;        device.destroyPipelineLayout(pipelineLayout);&#10;        device.destroyRenderPass(renderPass);&#10;        device.destroy();&#10;&#10;        // Skip debug messenger cleanup since we disabled it&#10;        // if (enableValidationLayers) {&#10;        //     instance.destroyDebugUtilsMessengerEXT(debugMessenger);&#10;        // }&#10;&#10;        instance.destroySurfaceKHR(surface);&#10;        instance.destroy();&#10;&#10;        glfwDestroyWindow(window);&#10;        glfwTerminate();&#10;    }&#10;&#10;    void recreateSwapChain() {&#10;        int width = 0, height = 0;&#10;        glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;        while (width == 0 || height == 0) {&#10;            glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;            glfwWaitEvents();&#10;        }&#10;&#10;        device.waitIdle();&#10;&#10;        cleanupSwapChain();&#10;        createSwapChain();&#10;        createImageViews();&#10;        createFramebuffers();&#10;    }&#10;&#10;    void createInstance() {&#10;        vk::ApplicationInfo appInfo(&#10;            &quot;Hello Triangle&quot;,&#10;            VK_MAKE_VERSION(1, 0, 0),&#10;            &quot;No Engine&quot;,&#10;            VK_MAKE_VERSION(1, 0, 0),&#10;            VK_API_VERSION_1_0&#10;        );&#10;&#10;        // Get the required extensions.&#10;        auto requiredExtensions = getRequiredExtensions();&#10;&#10;        vk::InstanceCreateInfo createInfo(&#10;            {},&#10;            &amp;appInfo,&#10;            enableValidationLayers ? static_cast&lt;uint32_t&gt;(validationLayers.size()) : 0,&#10;            enableValidationLayers ? validationLayers.data() : nullptr,&#10;            static_cast&lt;uint32_t&gt;(requiredExtensions.size()),&#10;            requiredExtensions.data()&#10;        );&#10;&#10;        instance = vk::createInstance(createInfo);&#10;    }&#10;&#10;    void setupDebugMessenger() {&#10;        // Disable debug messenger for now to avoid linker issues&#10;        // if (!enableValidationLayers) return;&#10;        return; // Skip debug messenger setup&#10;    }&#10;&#10;    void createSurface() {&#10;        VkSurfaceKHR _surface;&#10;        if (glfwCreateWindowSurface(static_cast&lt;VkInstance&gt;(instance), window, nullptr, &amp;_surface) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create window surface!&quot;);&#10;        }&#10;        surface = vk::SurfaceKHR(_surface);&#10;    }&#10;&#10;    void pickPhysicalDevice() {&#10;        std::vector&lt;vk::PhysicalDevice&gt; devices = instance.enumeratePhysicalDevices();&#10;&#10;        for (const auto&amp; device : devices) {&#10;            if (isDeviceSuitable(device)) {&#10;                physicalDevice = device;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (!physicalDevice) {&#10;            throw std::runtime_error(&quot;failed to find a suitable GPU!&quot;);&#10;        }&#10;    }&#10;&#10;    bool isDeviceSuitable(vk::PhysicalDevice device) {&#10;        auto queueFamilies = device.getQueueFamilyProperties();&#10;&#10;        bool graphicsQueueFound = false;&#10;        for (uint32_t i = 0; i &lt; queueFamilies.size(); i++) {&#10;            if (queueFamilies[i].queueFlags &amp; vk::QueueFlagBits::eGraphics) {&#10;                if (device.getSurfaceSupportKHR(i, surface)) {&#10;                    queueIndex = i;&#10;                    graphicsQueueFound = true;&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        return graphicsQueueFound;&#10;    }&#10;&#10;    void createLogicalDevice() {&#10;        float queuePriority = 1.0f;&#10;        vk::DeviceQueueCreateInfo queueCreateInfo(&#10;            {},&#10;            queueIndex,&#10;            1,&#10;            &amp;queuePriority&#10;        );&#10;&#10;        vk::PhysicalDeviceFeatures deviceFeatures{};&#10;&#10;        vk::DeviceCreateInfo createInfo(&#10;            {},&#10;            1,&#10;            &amp;queueCreateInfo,&#10;            enableValidationLayers ? static_cast&lt;uint32_t&gt;(validationLayers.size()) : 0,&#10;            enableValidationLayers ? validationLayers.data() : nullptr,&#10;            static_cast&lt;uint32_t&gt;(requiredDeviceExtension.size()),&#10;            requiredDeviceExtension.data(),&#10;            &amp;deviceFeatures&#10;        );&#10;&#10;        device = physicalDevice.createDevice(createInfo);&#10;        queue = device.getQueue(queueIndex, 0);&#10;    }&#10;&#10;    void createSwapChain() {&#10;        auto surfaceCapabilities = physicalDevice.getSurfaceCapabilitiesKHR(surface);&#10;        swapChainImageFormat = chooseSwapSurfaceFormat(physicalDevice.getSurfaceFormatsKHR(surface));&#10;        swapChainExtent = chooseSwapExtent(surfaceCapabilities);&#10;&#10;        uint32_t imageCount = surfaceCapabilities.minImageCount + 1;&#10;        if (surfaceCapabilities.maxImageCount &gt; 0 &amp;&amp; imageCount &gt; surfaceCapabilities.maxImageCount) {&#10;            imageCount = surfaceCapabilities.maxImageCount;&#10;        }&#10;&#10;        vk::SwapchainCreateInfoKHR createInfo(&#10;            {},&#10;            surface,&#10;            imageCount,&#10;            swapChainImageFormat,&#10;            vk::ColorSpaceKHR::eSrgbNonlinear,&#10;            swapChainExtent,&#10;            1,&#10;            vk::ImageUsageFlagBits::eColorAttachment,&#10;            vk::SharingMode::eExclusive,&#10;            0,&#10;            nullptr,&#10;            surfaceCapabilities.currentTransform,&#10;            vk::CompositeAlphaFlagBitsKHR::eOpaque,&#10;            chooseSwapPresentMode(physicalDevice.getSurfacePresentModesKHR(surface)),&#10;            VK_TRUE&#10;        );&#10;&#10;        swapChain = device.createSwapchainKHR(createInfo);&#10;        swapChainImages = device.getSwapchainImagesKHR(swapChain);&#10;    }&#10;&#10;    void createImageViews() {&#10;        swapChainImageViews.resize(swapChainImages.size());&#10;&#10;        for (size_t i = 0; i &lt; swapChainImages.size(); i++) {&#10;            vk::ImageViewCreateInfo createInfo(&#10;                {},&#10;                swapChainImages[i],&#10;                vk::ImageViewType::e2D,&#10;                swapChainImageFormat,&#10;                {},&#10;                { vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1 }&#10;            );&#10;&#10;            swapChainImageViews[i] = device.createImageView(createInfo);&#10;        }&#10;    }&#10;&#10;    void createRenderPass() {&#10;        vk::AttachmentDescription colorAttachment(&#10;            {},&#10;            swapChainImageFormat,&#10;            vk::SampleCountFlagBits::e1,&#10;            vk::AttachmentLoadOp::eClear,&#10;            vk::AttachmentStoreOp::eStore,&#10;            vk::AttachmentLoadOp::eDontCare,&#10;            vk::AttachmentStoreOp::eDontCare,&#10;            vk::ImageLayout::eUndefined,&#10;            vk::ImageLayout::ePresentSrcKHR&#10;        );&#10;&#10;        vk::AttachmentReference colorAttachmentRef(0, vk::ImageLayout::eColorAttachmentOptimal);&#10;&#10;        vk::SubpassDescription subpass(&#10;            {},                           // flags&#10;            vk::PipelineBindPoint::eGraphics,  // pipelineBindPoint&#10;            {},                           // inputAttachments (empty)&#10;            colorAttachmentRef,           // colorAttachments&#10;            {},                           // resolveAttachments (empty)&#10;            nullptr,                      // depthStencilAttachment&#10;            {}                            // preserveAttachments (empty)&#10;        );&#10;&#10;        vk::RenderPassCreateInfo renderPassInfo(&#10;            {},&#10;            1,&#10;            &amp;colorAttachment,&#10;            1,&#10;            &amp;subpass&#10;        );&#10;&#10;        renderPass = device.createRenderPass(renderPassInfo);&#10;    }&#10;&#10;    void createGraphicsPipeline() {&#10;        // Load custom vertex and fragment shaders - users can easily edit these!&#10;        auto vertShaderCode = readFile(&quot;../shaders/custom_vertex.vert.spv&quot;);&#10;        auto fragShaderCode = readFile(&quot;../shaders/custom_fragment.frag.spv&quot;);&#10;&#10;        vk::ShaderModule vertShaderModule = createShaderModule(vertShaderCode);&#10;        vk::ShaderModule fragShaderModule = createShaderModule(fragShaderCode);&#10;&#10;        vk::PipelineShaderStageCreateInfo vertShaderStageInfo(&#10;            {},&#10;            vk::ShaderStageFlagBits::eVertex,&#10;            vertShaderModule,&#10;            &quot;main&quot;&#10;        );&#10;&#10;        vk::PipelineShaderStageCreateInfo fragShaderStageInfo(&#10;            {},&#10;            vk::ShaderStageFlagBits::eFragment,&#10;            fragShaderModule,&#10;            &quot;main&quot;&#10;        );&#10;&#10;        vk::PipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};&#10;&#10;        // The existing shaders don't use vertex input, so we'll disable vertex input&#10;        vk::PipelineVertexInputStateCreateInfo vertexInputInfo(&#10;            {},&#10;            0,&#10;            nullptr,&#10;            0,&#10;            nullptr&#10;        );&#10;&#10;        vk::PipelineInputAssemblyStateCreateInfo inputAssembly(&#10;            {},&#10;            vk::PrimitiveTopology::eTriangleList,&#10;            VK_FALSE&#10;        );&#10;&#10;        vk::PipelineViewportStateCreateInfo viewportState(&#10;            {},&#10;            1,&#10;            nullptr,&#10;            1,&#10;            nullptr&#10;        );&#10;&#10;        vk::PipelineRasterizationStateCreateInfo rasterizer(&#10;            {},&#10;            VK_FALSE,&#10;            VK_FALSE,&#10;            vk::PolygonMode::eFill,&#10;            vk::CullModeFlagBits::eBack,&#10;            vk::FrontFace::eClockwise,&#10;            VK_FALSE,&#10;            0.0f,&#10;            0.0f,&#10;            0.0f,&#10;            1.0f&#10;        );&#10;&#10;        vk::PipelineMultisampleStateCreateInfo multisampling(&#10;            {},&#10;            vk::SampleCountFlagBits::e1,&#10;            VK_FALSE&#10;        );&#10;&#10;        vk::PipelineColorBlendAttachmentState colorBlendAttachment(&#10;            VK_FALSE,&#10;            vk::BlendFactor::eOne,&#10;            vk::BlendFactor::eZero,&#10;            vk::BlendOp::eAdd,&#10;            vk::BlendFactor::eOne,&#10;            vk::BlendFactor::eZero,&#10;            vk::BlendOp::eAdd,&#10;            vk::ColorComponentFlagBits::eR | vk::ColorComponentFlagBits::eG | vk::ColorComponentFlagBits::eB | vk::ColorComponentFlagBits::eA&#10;        );&#10;&#10;        vk::PipelineColorBlendStateCreateInfo colorBlending(&#10;            {},&#10;            VK_FALSE,&#10;            vk::LogicOp::eCopy,&#10;            1,&#10;            &amp;colorBlendAttachment&#10;        );&#10;&#10;        std::vector&lt;vk::DynamicState&gt; dynamicStates = {&#10;            vk::DynamicState::eViewport,&#10;            vk::DynamicState::eScissor&#10;        };&#10;&#10;        vk::PipelineDynamicStateCreateInfo dynamicState(&#10;            {},&#10;            static_cast&lt;uint32_t&gt;(dynamicStates.size()),&#10;            dynamicStates.data()&#10;        );&#10;&#10;        vk::PipelineLayoutCreateInfo pipelineLayoutInfo(&#10;            {},&#10;            0,&#10;            nullptr,&#10;            0,&#10;            nullptr&#10;        );&#10;&#10;        pipelineLayout = device.createPipelineLayout(pipelineLayoutInfo);&#10;&#10;        vk::GraphicsPipelineCreateInfo pipelineInfo(&#10;            {},&#10;            2,&#10;            shaderStages,&#10;            &amp;vertexInputInfo,&#10;            &amp;inputAssembly,&#10;            nullptr,&#10;            &amp;viewportState,&#10;            &amp;rasterizer,&#10;            &amp;multisampling,&#10;            nullptr,&#10;            &amp;colorBlending,&#10;            &amp;dynamicState,&#10;            pipelineLayout,&#10;            renderPass,  // Use the render pass instead of nullptr&#10;            0&#10;        );&#10;&#10;        auto result = device.createGraphicsPipeline(nullptr, pipelineInfo);&#10;        if (result.result != vk::Result::eSuccess) {&#10;            throw std::runtime_error(&quot;failed to create graphics pipeline!&quot;);&#10;        }&#10;        graphicsPipeline = result.value;&#10;&#10;        device.destroyShaderModule(fragShaderModule);&#10;        device.destroyShaderModule(vertShaderModule);&#10;    }&#10;&#10;    void createFramebuffers() {&#10;        swapChainFramebuffers.resize(swapChainImageViews.size());&#10;&#10;        for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) {&#10;            vk::ImageView attachments[] = {&#10;                swapChainImageViews[i]&#10;            };&#10;&#10;            vk::FramebufferCreateInfo framebufferInfo(&#10;                {},&#10;                renderPass,&#10;                1,&#10;                attachments,&#10;                swapChainExtent.width,&#10;                swapChainExtent.height,&#10;                1&#10;            );&#10;&#10;            swapChainFramebuffers[i] = device.createFramebuffer(framebufferInfo);&#10;        }&#10;    }&#10;&#10;    void createCommandPool() {&#10;        vk::CommandPoolCreateInfo poolInfo(&#10;            vk::CommandPoolCreateFlagBits::eResetCommandBuffer,&#10;            queueIndex&#10;        );&#10;&#10;        commandPool = device.createCommandPool(poolInfo);&#10;    }&#10;&#10;    void createVertexBuffer() {&#10;        // The existing shaders don't use vertex buffers, so we'll skip this&#10;    }&#10;&#10;    void createIndexBuffer() {&#10;        // The existing shaders don't use index buffers, so we'll skip this&#10;    }&#10;&#10;    void createCommandBuffers() {&#10;        commandBuffers.resize(MAX_FRAMES_IN_FLIGHT);&#10;&#10;        vk::CommandBufferAllocateInfo allocInfo(&#10;            commandPool,&#10;            vk::CommandBufferLevel::ePrimary,&#10;            MAX_FRAMES_IN_FLIGHT&#10;        );&#10;&#10;        commandBuffers = device.allocateCommandBuffers(allocInfo);&#10;    }&#10;&#10;    void recordCommandBuffer(uint32_t imageIndex) {&#10;        vk::CommandBufferBeginInfo beginInfo{};&#10;        commandBuffers[currentFrame].begin(beginInfo);&#10;&#10;        vk::ClearValue clearColor = vk::ClearColorValue(0.0f, 0.0f, 0.0f, 1.0f);&#10;        vk::RenderPassBeginInfo renderPassInfo(&#10;            renderPass,&#10;            swapChainFramebuffers[imageIndex],&#10;            { {0, 0}, swapChainExtent },&#10;            1,&#10;            &amp;clearColor&#10;        );&#10;&#10;        commandBuffers[currentFrame].beginRenderPass(renderPassInfo, vk::SubpassContents::eInline);&#10;&#10;        commandBuffers[currentFrame].bindPipeline(vk::PipelineBindPoint::eGraphics, graphicsPipeline);&#10;&#10;        vk::Viewport viewport(0.0f, 0.0f, static_cast&lt;float&gt;(swapChainExtent.width), static_cast&lt;float&gt;(swapChainExtent.height), 0.0f, 1.0f);&#10;        commandBuffers[currentFrame].setViewport(0, 1, &amp;viewport);&#10;&#10;        vk::Rect2D scissor({0, 0}, swapChainExtent);&#10;        commandBuffers[currentFrame].setScissor(0, 1, &amp;scissor);&#10;&#10;        // Draw hexagon with 6 vertices instead of triangle with 3&#10;        commandBuffers[currentFrame].draw(6, 1, 0, 0);&#10;&#10;        commandBuffers[currentFrame].endRenderPass();&#10;        commandBuffers[currentFrame].end();&#10;    }&#10;&#10;    void createSyncObjects() {&#10;        presentCompleteSemaphore.resize(swapChainImages.size());&#10;        renderFinishedSemaphore.resize(swapChainImages.size());&#10;        inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);&#10;&#10;        vk::SemaphoreCreateInfo semaphoreInfo{};&#10;        vk::FenceCreateInfo fenceInfo(vk::FenceCreateFlagBits::eSignaled);&#10;&#10;        for (size_t i = 0; i &lt; swapChainImages.size(); i++) {&#10;            presentCompleteSemaphore[i] = device.createSemaphore(semaphoreInfo);&#10;            renderFinishedSemaphore[i] = device.createSemaphore(semaphoreInfo);&#10;        }&#10;&#10;        for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;            inFlightFences[i] = device.createFence(fenceInfo);&#10;        }&#10;    }&#10;&#10;    void drawFrame() {&#10;        auto waitResult = device.waitForFences(1, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);&#10;        if (waitResult != vk::Result::eSuccess) {&#10;            throw std::runtime_error(&quot;failed to wait for fence!&quot;);&#10;        }&#10;&#10;        auto result = device.acquireNextImageKHR(swapChain, UINT64_MAX, presentCompleteSemaphore[semaphoreIndex], nullptr);&#10;        if (result.result == vk::Result::eErrorOutOfDateKHR) {&#10;            recreateSwapChain();&#10;            return;&#10;        }&#10;        if (result.result != vk::Result::eSuccess &amp;&amp; result.result != vk::Result::eSuboptimalKHR) {&#10;            throw std::runtime_error(&quot;failed to acquire swap chain image!&quot;);&#10;        }&#10;        uint32_t imageIndex = result.value;&#10;&#10;        auto resetResult = device.resetFences(1, &amp;inFlightFences[currentFrame]);&#10;        if (resetResult != vk::Result::eSuccess) {&#10;            throw std::runtime_error(&quot;failed to reset fence!&quot;);&#10;        }&#10;&#10;        commandBuffers[currentFrame].reset();&#10;        recordCommandBuffer(imageIndex);&#10;&#10;        vk::PipelineStageFlags waitStages[] = {vk::PipelineStageFlagBits::eColorAttachmentOutput};&#10;        vk::SubmitInfo submitInfo(&#10;            1,&#10;            &amp;presentCompleteSemaphore[semaphoreIndex],&#10;            waitStages,&#10;            1,&#10;            &amp;commandBuffers[currentFrame],&#10;            1,&#10;            &amp;renderFinishedSemaphore[imageIndex]&#10;        );&#10;&#10;        auto submitResult = queue.submit(1, &amp;submitInfo, inFlightFences[currentFrame]);&#10;        if (submitResult != vk::Result::eSuccess) {&#10;            throw std::runtime_error(&quot;failed to submit draw command buffer!&quot;);&#10;        }&#10;&#10;        vk::PresentInfoKHR presentInfo(&#10;            1,&#10;            &amp;renderFinishedSemaphore[imageIndex],&#10;            1,&#10;            &amp;swapChain,&#10;            &amp;imageIndex&#10;        );&#10;&#10;        auto presentResult = queue.presentKHR(presentInfo);&#10;        if (presentResult == vk::Result::eErrorOutOfDateKHR || presentResult == vk::Result::eSuboptimalKHR || framebufferResized) {&#10;            framebufferResized = false;&#10;            recreateSwapChain();&#10;        } else if (presentResult != vk::Result::eSuccess) {&#10;            throw std::runtime_error(&quot;failed to present swap chain image!&quot;);&#10;        }&#10;&#10;        semaphoreIndex = (semaphoreIndex + 1) % presentCompleteSemaphore.size();&#10;        currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;&#10;    }&#10;&#10;    vk::ShaderModule createShaderModule(const std::vector&lt;char&gt;&amp; code) {&#10;        vk::ShaderModuleCreateInfo createInfo(&#10;            {},&#10;            code.size(),&#10;            reinterpret_cast&lt;const uint32_t*&gt;(code.data())&#10;        );&#10;&#10;        return device.createShaderModule(createInfo);&#10;    }&#10;&#10;    static vk::Format chooseSwapSurfaceFormat(const std::vector&lt;vk::SurfaceFormatKHR&gt;&amp; availableFormats) {&#10;        for (const auto&amp; format : availableFormats) {&#10;            if (format.format == vk::Format::eB8G8R8A8Srgb &amp;&amp; format.colorSpace == vk::ColorSpaceKHR::eSrgbNonlinear) {&#10;                return format.format;&#10;            }&#10;        }&#10;        return availableFormats[0].format;&#10;    }&#10;&#10;    static vk::PresentModeKHR chooseSwapPresentMode(const std::vector&lt;vk::PresentModeKHR&gt;&amp; availablePresentModes) {&#10;        for (const auto&amp; availablePresentMode : availablePresentModes) {&#10;            if (availablePresentMode == vk::PresentModeKHR::eMailbox) {&#10;                return availablePresentMode;&#10;            }&#10;        }&#10;        return vk::PresentModeKHR::eFifo;&#10;    }&#10;&#10;    vk::Extent2D chooseSwapExtent(const vk::SurfaceCapabilitiesKHR&amp; capabilities) {&#10;        if (capabilities.currentExtent.width != std::numeric_limits&lt;uint32_t&gt;::max()) {&#10;            return capabilities.currentExtent;&#10;        }&#10;&#10;        int width, height;&#10;        glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;&#10;        vk::Extent2D actualExtent = {&#10;            static_cast&lt;uint32_t&gt;(width),&#10;            static_cast&lt;uint32_t&gt;(height)&#10;        };&#10;&#10;        actualExtent.width = std::clamp(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);&#10;        actualExtent.height = std::clamp(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);&#10;&#10;        return actualExtent;&#10;    }&#10;&#10;    std::vector&lt;const char*&gt; getRequiredExtensions() {&#10;        uint32_t glfwExtensionCount = 0;&#10;        const char** glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);&#10;&#10;        std::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);&#10;&#10;        if (enableValidationLayers) {&#10;            extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);&#10;        }&#10;&#10;        return extensions;&#10;    }&#10;&#10;    static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(&#10;        VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,&#10;        VkDebugUtilsMessageTypeFlagsEXT messageType,&#10;        const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,&#10;        void* pUserData) {&#10;&#10;        std::cerr &lt;&lt; &quot;validation layer: &quot; &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;&#10;&#10;        return VK_FALSE;&#10;    }&#10;&#10;    static std::vector&lt;char&gt; readFile(const std::string&amp; filename) {&#10;        std::ifstream file(filename, std::ios::ate | std::ios::binary);&#10;&#10;        if (!file.is_open()) {&#10;            throw std::runtime_error(&quot;failed to open file!&quot;);&#10;        }&#10;&#10;        size_t fileSize = (size_t) file.tellg();&#10;        std::vector&lt;char&gt; buffer(fileSize);&#10;&#10;        file.seekg(0);&#10;        file.read(buffer.data(), fileSize);&#10;&#10;        file.close();&#10;&#10;        return buffer;&#10;    }&#10;};&#10;&#10;int main() {&#10;    try {&#10;        HelloTriangleApplication app;&#10;        app.run();&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return EXIT_FAILURE;&#10;    }&#10;&#10;    return EXIT_SUCCESS;&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;iostream&gt;&#10;#include &lt;fstream&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;cstdlib&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;limits&gt;&#10;#include &lt;array&gt;&#10;&#10;// Use traditional Vulkan-Hpp headers without RAII&#10;#include &lt;vulkan/vulkan.hpp&gt;&#10;&#10;#define GLFW_INCLUDE_VULKAN&#10;#include &lt;GLFW/glfw3.h&gt;&#10;#include &lt;glm/glm.hpp&gt;&#10;&#10;constexpr uint32_t WIDTH = 800;&#10;constexpr uint32_t HEIGHT = 600;&#10;constexpr int MAX_FRAMES_IN_FLIGHT = 2;&#10;&#10;const std::vector validationLayers = {&#10;    &quot;VK_LAYER_KHRONOS_validation&quot;&#10;};&#10;&#10;#ifdef NDEBUG&#10;constexpr bool enableValidationLayers = false;&#10;#else&#10;constexpr bool enableValidationLayers = true;&#10;#endif&#10;&#10;struct Vertex {&#10;    glm::vec2 pos;&#10;    glm::vec3 color;&#10;&#10;    static vk::VertexInputBindingDescription getBindingDescription() {&#10;        return { 0, sizeof(Vertex), vk::VertexInputRate::eVertex };&#10;    }&#10;&#10;    static std::array&lt;vk::VertexInputAttributeDescription, 2&gt; getAttributeDescriptions() {&#10;        return {&#10;            vk::VertexInputAttributeDescription( 0, 0, vk::Format::eR32G32Sfloat, offsetof(Vertex, pos) ),&#10;            vk::VertexInputAttributeDescription( 1, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, color) )&#10;        };&#10;    }&#10;};&#10;&#10;const std::vector&lt;Vertex&gt; vertices = {&#10;    {{-0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}},&#10;    {{0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}},&#10;    {{0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}},&#10;    {{-0.5f, 0.5f}, {1.0f, 1.0f, 1.0f}}&#10;};&#10;&#10;const std::vector&lt;uint16_t&gt; indices = {&#10;    0, 1, 2, 2, 3, 0&#10;};&#10;&#10;class HelloTriangleApplication {&#10;public:&#10;    void run() {&#10;        initWindow();&#10;        initVulkan();&#10;        mainLoop();&#10;        cleanup();&#10;    }&#10;&#10;private:&#10;    GLFWwindow *                     window = nullptr;&#10;    vk::Instance                     instance;&#10;    vk::DebugUtilsMessengerEXT       debugMessenger;&#10;    vk::SurfaceKHR                   surface;&#10;    vk::PhysicalDevice               physicalDevice;&#10;    vk::Device                       device;&#10;    uint32_t                         queueIndex = ~0;&#10;    vk::Queue                        queue;&#10;&#10;    vk::SwapchainKHR swapChain;&#10;    std::vector&lt;vk::Image&gt; swapChainImages;&#10;    vk::Format swapChainImageFormat = vk::Format::eUndefined;&#10;    vk::Extent2D swapChainExtent;&#10;    std::vector&lt;vk::ImageView&gt; swapChainImageViews;&#10;&#10;    vk::PipelineLayout pipelineLayout;&#10;    vk::Pipeline graphicsPipeline;&#10;    vk::RenderPass renderPass;&#10;    std::vector&lt;vk::Framebuffer&gt; swapChainFramebuffers;&#10;&#10;    vk::Buffer vertexBuffer;&#10;    vk::DeviceMemory vertexBufferMemory;&#10;    vk::Buffer indexBuffer;&#10;    vk::DeviceMemory indexBufferMemory;&#10;&#10;    vk::CommandPool commandPool;&#10;    std::vector&lt;vk::CommandBuffer&gt; commandBuffers;&#10;&#10;    std::vector&lt;vk::Semaphore&gt; presentCompleteSemaphore;&#10;    std::vector&lt;vk::Semaphore&gt; renderFinishedSemaphore;&#10;    std::vector&lt;vk::Fence&gt; inFlightFences;&#10;    uint32_t semaphoreIndex = 0;&#10;    uint32_t currentFrame = 0;&#10;&#10;    bool framebufferResized = false;&#10;&#10;    std::vector&lt;const char*&gt; requiredDeviceExtension = {&#10;        vk::KHRSwapchainExtensionName&#10;    };&#10;&#10;    void initWindow() {&#10;        glfwInit();&#10;&#10;        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);&#10;&#10;        window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Vulkan&quot;, nullptr, nullptr);&#10;        glfwSetWindowUserPointer(window, this);&#10;        glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);&#10;    }&#10;&#10;    static void framebufferResizeCallback(GLFWwindow* window, int width, int height) {&#10;        auto app = static_cast&lt;HelloTriangleApplication*&gt;(glfwGetWindowUserPointer(window));&#10;        app-&gt;framebufferResized = true;&#10;    }&#10;&#10;    void initVulkan() {&#10;        createInstance();&#10;        setupDebugMessenger();&#10;        createSurface();&#10;        pickPhysicalDevice();&#10;        createLogicalDevice();&#10;        createSwapChain();&#10;        createImageViews();&#10;        createRenderPass();&#10;        createGraphicsPipeline();&#10;        createFramebuffers();&#10;        createCommandPool();&#10;        createVertexBuffer();&#10;        createIndexBuffer();&#10;        createCommandBuffers();&#10;        createSyncObjects();&#10;    }&#10;&#10;    void mainLoop() {&#10;        while (!glfwWindowShouldClose(window)) {&#10;            glfwPollEvents();&#10;            drawFrame();&#10;        }&#10;&#10;        device.waitIdle();&#10;    }&#10;&#10;    void cleanupSwapChain() {&#10;        for (auto&amp; framebuffer : swapChainFramebuffers) {&#10;            device.destroyFramebuffer(framebuffer);&#10;        }&#10;&#10;        for (auto&amp; imageView : swapChainImageViews) {&#10;            device.destroyImageView(imageView);&#10;        }&#10;        device.destroySwapchainKHR(swapChain);&#10;    }&#10;&#10;    void cleanup() {&#10;        cleanupSwapChain();&#10;&#10;        // Fix: Destroy semaphores with correct loop count&#10;        for (size_t i = 0; i &lt; swapChainImages.size(); i++) {&#10;            device.destroySemaphore(renderFinishedSemaphore[i]);&#10;            device.destroySemaphore(presentCompleteSemaphore[i]);&#10;        }&#10;&#10;        for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;            device.destroyFence(inFlightFences[i]);&#10;        }&#10;&#10;        device.destroyCommandPool(commandPool);&#10;        device.destroyPipeline(graphicsPipeline);&#10;        device.destroyPipelineLayout(pipelineLayout);&#10;        device.destroyRenderPass(renderPass);&#10;        device.destroy();&#10;&#10;        // Skip debug messenger cleanup since we disabled it&#10;        // if (enableValidationLayers) {&#10;        //     instance.destroyDebugUtilsMessengerEXT(debugMessenger);&#10;        // }&#10;&#10;        instance.destroySurfaceKHR(surface);&#10;        instance.destroy();&#10;&#10;        glfwDestroyWindow(window);&#10;        glfwTerminate();&#10;    }&#10;&#10;    void recreateSwapChain() {&#10;        int width = 0, height = 0;&#10;        glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;        while (width == 0 || height == 0) {&#10;            glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;            glfwWaitEvents();&#10;        }&#10;&#10;        device.waitIdle();&#10;&#10;        cleanupSwapChain();&#10;        createSwapChain();&#10;        createImageViews();&#10;        createFramebuffers();&#10;    }&#10;&#10;    void createInstance() {&#10;        vk::ApplicationInfo appInfo(&#10;            &quot;Hello Triangle&quot;,&#10;            VK_MAKE_VERSION(1, 0, 0),&#10;            &quot;No Engine&quot;,&#10;            VK_MAKE_VERSION(1, 0, 0),&#10;            VK_API_VERSION_1_0&#10;        );&#10;&#10;        // Get the required extensions.&#10;        auto requiredExtensions = getRequiredExtensions();&#10;&#10;        vk::InstanceCreateInfo createInfo(&#10;            {},&#10;            &amp;appInfo,&#10;            enableValidationLayers ? static_cast&lt;uint32_t&gt;(validationLayers.size()) : 0,&#10;            enableValidationLayers ? validationLayers.data() : nullptr,&#10;            static_cast&lt;uint32_t&gt;(requiredExtensions.size()),&#10;            requiredExtensions.data()&#10;        );&#10;&#10;        instance = vk::createInstance(createInfo);&#10;    }&#10;&#10;    void setupDebugMessenger() {&#10;        // Disable debug messenger for now to avoid linker issues&#10;        // if (!enableValidationLayers) return;&#10;        return; // Skip debug messenger setup&#10;    }&#10;&#10;    void createSurface() {&#10;        VkSurfaceKHR _surface;&#10;        if (glfwCreateWindowSurface(static_cast&lt;VkInstance&gt;(instance), window, nullptr, &amp;_surface) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;failed to create window surface!&quot;);&#10;        }&#10;        surface = vk::SurfaceKHR(_surface);&#10;    }&#10;&#10;    void pickPhysicalDevice() {&#10;        std::vector&lt;vk::PhysicalDevice&gt; devices = instance.enumeratePhysicalDevices();&#10;&#10;        for (const auto&amp; device : devices) {&#10;            if (isDeviceSuitable(device)) {&#10;                physicalDevice = device;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (!physicalDevice) {&#10;            throw std::runtime_error(&quot;failed to find a suitable GPU!&quot;);&#10;        }&#10;    }&#10;&#10;    bool isDeviceSuitable(vk::PhysicalDevice device) {&#10;        auto queueFamilies = device.getQueueFamilyProperties();&#10;&#10;        bool graphicsQueueFound = false;&#10;        for (uint32_t i = 0; i &lt; queueFamilies.size(); i++) {&#10;            if (queueFamilies[i].queueFlags &amp; vk::QueueFlagBits::eGraphics) {&#10;                if (device.getSurfaceSupportKHR(i, surface)) {&#10;                    queueIndex = i;&#10;                    graphicsQueueFound = true;&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        return graphicsQueueFound;&#10;    }&#10;&#10;    void createLogicalDevice() {&#10;        float queuePriority = 1.0f;&#10;        vk::DeviceQueueCreateInfo queueCreateInfo(&#10;            {},&#10;            queueIndex,&#10;            1,&#10;            &amp;queuePriority&#10;        );&#10;&#10;        vk::PhysicalDeviceFeatures deviceFeatures{};&#10;&#10;        vk::DeviceCreateInfo createInfo(&#10;            {},&#10;            1,&#10;            &amp;queueCreateInfo,&#10;            enableValidationLayers ? static_cast&lt;uint32_t&gt;(validationLayers.size()) : 0,&#10;            enableValidationLayers ? validationLayers.data() : nullptr,&#10;            static_cast&lt;uint32_t&gt;(requiredDeviceExtension.size()),&#10;            requiredDeviceExtension.data(),&#10;            &amp;deviceFeatures&#10;        );&#10;&#10;        device = physicalDevice.createDevice(createInfo);&#10;        queue = device.getQueue(queueIndex, 0);&#10;    }&#10;&#10;    void createSwapChain() {&#10;        auto surfaceCapabilities = physicalDevice.getSurfaceCapabilitiesKHR(surface);&#10;        swapChainImageFormat = chooseSwapSurfaceFormat(physicalDevice.getSurfaceFormatsKHR(surface));&#10;        swapChainExtent = chooseSwapExtent(surfaceCapabilities);&#10;&#10;        uint32_t imageCount = surfaceCapabilities.minImageCount + 1;&#10;        if (surfaceCapabilities.maxImageCount &gt; 0 &amp;&amp; imageCount &gt; surfaceCapabilities.maxImageCount) {&#10;            imageCount = surfaceCapabilities.maxImageCount;&#10;        }&#10;&#10;        vk::SwapchainCreateInfoKHR createInfo(&#10;            {},&#10;            surface,&#10;            imageCount,&#10;            swapChainImageFormat,&#10;            vk::ColorSpaceKHR::eSrgbNonlinear,&#10;            swapChainExtent,&#10;            1,&#10;            vk::ImageUsageFlagBits::eColorAttachment,&#10;            vk::SharingMode::eExclusive,&#10;            0,&#10;            nullptr,&#10;            surfaceCapabilities.currentTransform,&#10;            vk::CompositeAlphaFlagBitsKHR::eOpaque,&#10;            chooseSwapPresentMode(physicalDevice.getSurfacePresentModesKHR(surface)),&#10;            VK_TRUE&#10;        );&#10;&#10;        swapChain = device.createSwapchainKHR(createInfo);&#10;        swapChainImages = device.getSwapchainImagesKHR(swapChain);&#10;    }&#10;&#10;    void createImageViews() {&#10;        swapChainImageViews.resize(swapChainImages.size());&#10;&#10;        for (size_t i = 0; i &lt; swapChainImages.size(); i++) {&#10;            vk::ImageViewCreateInfo createInfo(&#10;                {},&#10;                swapChainImages[i],&#10;                vk::ImageViewType::e2D,&#10;                swapChainImageFormat,&#10;                {},&#10;                { vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1 }&#10;            );&#10;&#10;            swapChainImageViews[i] = device.createImageView(createInfo);&#10;        }&#10;    }&#10;&#10;    void createRenderPass() {&#10;        vk::AttachmentDescription colorAttachment(&#10;            {},&#10;            swapChainImageFormat,&#10;            vk::SampleCountFlagBits::e1,&#10;            vk::AttachmentLoadOp::eClear,&#10;            vk::AttachmentStoreOp::eStore,&#10;            vk::AttachmentLoadOp::eDontCare,&#10;            vk::AttachmentStoreOp::eDontCare,&#10;            vk::ImageLayout::eUndefined,&#10;            vk::ImageLayout::ePresentSrcKHR&#10;        );&#10;&#10;        vk::AttachmentReference colorAttachmentRef(0, vk::ImageLayout::eColorAttachmentOptimal);&#10;&#10;        vk::SubpassDescription subpass(&#10;            {},                           // flags&#10;            vk::PipelineBindPoint::eGraphics,  // pipelineBindPoint&#10;            {},                           // inputAttachments (empty)&#10;            colorAttachmentRef,           // colorAttachments&#10;            {},                           // resolveAttachments (empty)&#10;            nullptr,                      // depthStencilAttachment&#10;            {}                            // preserveAttachments (empty)&#10;        );&#10;&#10;        vk::RenderPassCreateInfo renderPassInfo(&#10;            {},&#10;            1,&#10;            &amp;colorAttachment,&#10;            1,&#10;            &amp;subpass&#10;        );&#10;&#10;        renderPass = device.createRenderPass(renderPassInfo);&#10;    }&#10;&#10;    void createGraphicsPipeline() {&#10;        // Load custom vertex and fragment shaders - users can easily edit these!&#10;        auto vertShaderCode = readFile(&quot;../shaders/custom_vertex.vert.spv&quot;);&#10;        auto fragShaderCode = readFile(&quot;../shaders/custom_fragment.frag.spv&quot;);&#10;&#10;        vk::ShaderModule vertShaderModule = createShaderModule(vertShaderCode);&#10;        vk::ShaderModule fragShaderModule = createShaderModule(fragShaderCode);&#10;&#10;        vk::PipelineShaderStageCreateInfo vertShaderStageInfo(&#10;            {},&#10;            vk::ShaderStageFlagBits::eVertex,&#10;            vertShaderModule,&#10;            &quot;main&quot;&#10;        );&#10;&#10;        vk::PipelineShaderStageCreateInfo fragShaderStageInfo(&#10;            {},&#10;            vk::ShaderStageFlagBits::eFragment,&#10;            fragShaderModule,&#10;            &quot;main&quot;&#10;        );&#10;&#10;        vk::PipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};&#10;&#10;        // The existing shaders don't use vertex input, so we'll disable vertex input&#10;        vk::PipelineVertexInputStateCreateInfo vertexInputInfo(&#10;            {},&#10;            0,&#10;            nullptr,&#10;            0,&#10;            nullptr&#10;        );&#10;&#10;        vk::PipelineInputAssemblyStateCreateInfo inputAssembly(&#10;            {},&#10;            vk::PrimitiveTopology::eTriangleList,&#10;            VK_FALSE&#10;        );&#10;&#10;        vk::PipelineViewportStateCreateInfo viewportState(&#10;            {},&#10;            1,&#10;            nullptr,&#10;            1,&#10;            nullptr&#10;        );&#10;&#10;        vk::PipelineRasterizationStateCreateInfo rasterizer(&#10;            {},&#10;            VK_FALSE,&#10;            VK_FALSE,&#10;            vk::PolygonMode::eFill,&#10;            vk::CullModeFlagBits::eBack,&#10;            vk::FrontFace::eClockwise,&#10;            VK_FALSE,&#10;            0.0f,&#10;            0.0f,&#10;            0.0f,&#10;            1.0f&#10;        );&#10;&#10;        vk::PipelineMultisampleStateCreateInfo multisampling(&#10;            {},&#10;            vk::SampleCountFlagBits::e1,&#10;            VK_FALSE&#10;        );&#10;&#10;        vk::PipelineColorBlendAttachmentState colorBlendAttachment(&#10;            VK_FALSE,&#10;            vk::BlendFactor::eOne,&#10;            vk::BlendFactor::eZero,&#10;            vk::BlendOp::eAdd,&#10;            vk::BlendFactor::eOne,&#10;            vk::BlendFactor::eZero,&#10;            vk::BlendOp::eAdd,&#10;            vk::ColorComponentFlagBits::eR | vk::ColorComponentFlagBits::eG | vk::ColorComponentFlagBits::eB | vk::ColorComponentFlagBits::eA&#10;        );&#10;&#10;        vk::PipelineColorBlendStateCreateInfo colorBlending(&#10;            {},&#10;            VK_FALSE,&#10;            vk::LogicOp::eCopy,&#10;            1,&#10;            &amp;colorBlendAttachment&#10;        );&#10;&#10;        std::vector&lt;vk::DynamicState&gt; dynamicStates = {&#10;            vk::DynamicState::eViewport,&#10;            vk::DynamicState::eScissor&#10;        };&#10;&#10;        vk::PipelineDynamicStateCreateInfo dynamicState(&#10;            {},&#10;            static_cast&lt;uint32_t&gt;(dynamicStates.size()),&#10;            dynamicStates.data()&#10;        );&#10;&#10;        vk::PipelineLayoutCreateInfo pipelineLayoutInfo(&#10;            {},&#10;            0,&#10;            nullptr,&#10;            0,&#10;            nullptr&#10;        );&#10;&#10;        pipelineLayout = device.createPipelineLayout(pipelineLayoutInfo);&#10;&#10;        vk::GraphicsPipelineCreateInfo pipelineInfo(&#10;            {},&#10;            2,&#10;            shaderStages,&#10;            &amp;vertexInputInfo,&#10;            &amp;inputAssembly,&#10;            nullptr,&#10;            &amp;viewportState,&#10;            &amp;rasterizer,&#10;            &amp;multisampling,&#10;            nullptr,&#10;            &amp;colorBlending,&#10;            &amp;dynamicState,&#10;            pipelineLayout,&#10;            renderPass,  // Use the render pass instead of nullptr&#10;            0&#10;        );&#10;&#10;        auto result = device.createGraphicsPipeline(nullptr, pipelineInfo);&#10;        if (result.result != vk::Result::eSuccess) {&#10;            throw std::runtime_error(&quot;failed to create graphics pipeline!&quot;);&#10;        }&#10;        graphicsPipeline = result.value;&#10;&#10;        device.destroyShaderModule(fragShaderModule);&#10;        device.destroyShaderModule(vertShaderModule);&#10;    }&#10;&#10;    void createFramebuffers() {&#10;        swapChainFramebuffers.resize(swapChainImageViews.size());&#10;&#10;        for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) {&#10;            vk::ImageView attachments[] = {&#10;                swapChainImageViews[i]&#10;            };&#10;&#10;            vk::FramebufferCreateInfo framebufferInfo(&#10;                {},&#10;                renderPass,&#10;                1,&#10;                attachments,&#10;                swapChainExtent.width,&#10;                swapChainExtent.height,&#10;                1&#10;            );&#10;&#10;            swapChainFramebuffers[i] = device.createFramebuffer(framebufferInfo);&#10;        }&#10;    }&#10;&#10;    void createCommandPool() {&#10;        vk::CommandPoolCreateInfo poolInfo(&#10;            vk::CommandPoolCreateFlagBits::eResetCommandBuffer,&#10;            queueIndex&#10;        );&#10;&#10;        commandPool = device.createCommandPool(poolInfo);&#10;    }&#10;&#10;    void createVertexBuffer() {&#10;        // The existing shaders don't use vertex buffers, so we'll skip this&#10;    }&#10;&#10;    void createIndexBuffer() {&#10;        // The existing shaders don't use index buffers, so we'll skip this&#10;    }&#10;&#10;    void createCommandBuffers() {&#10;        commandBuffers.resize(MAX_FRAMES_IN_FLIGHT);&#10;&#10;        vk::CommandBufferAllocateInfo allocInfo(&#10;            commandPool,&#10;            vk::CommandBufferLevel::ePrimary,&#10;            MAX_FRAMES_IN_FLIGHT&#10;        );&#10;&#10;        commandBuffers = device.allocateCommandBuffers(allocInfo);&#10;    }&#10;&#10;    void recordCommandBuffer(uint32_t imageIndex) {&#10;        vk::CommandBufferBeginInfo beginInfo{};&#10;        commandBuffers[currentFrame].begin(beginInfo);&#10;&#10;        vk::ClearValue clearColor = vk::ClearColorValue(0.0f, 0.0f, 0.0f, 1.0f);&#10;        vk::RenderPassBeginInfo renderPassInfo(&#10;            renderPass,&#10;            swapChainFramebuffers[imageIndex],&#10;            { {0, 0}, swapChainExtent },&#10;            1,&#10;            &amp;clearColor&#10;        );&#10;&#10;        commandBuffers[currentFrame].beginRenderPass(renderPassInfo, vk::SubpassContents::eInline);&#10;&#10;        commandBuffers[currentFrame].bindPipeline(vk::PipelineBindPoint::eGraphics, graphicsPipeline);&#10;&#10;        vk::Viewport viewport(0.0f, 0.0f, static_cast&lt;float&gt;(swapChainExtent.width), static_cast&lt;float&gt;(swapChainExtent.height), 0.0f, 1.0f);&#10;        commandBuffers[currentFrame].setViewport(0, 1, &amp;viewport);&#10;&#10;        vk::Rect2D scissor({0, 0}, swapChainExtent);&#10;        commandBuffers[currentFrame].setScissor(0, 1, &amp;scissor);&#10;&#10;        // Draw triangle with only 3 vertices since the new shader uses a simple triangle&#10;        commandBuffers[currentFrame].draw(3, 1, 0, 0);&#10;&#10;        commandBuffers[currentFrame].endRenderPass();&#10;        commandBuffers[currentFrame].end();&#10;    }&#10;&#10;    void createSyncObjects() {&#10;        presentCompleteSemaphore.resize(swapChainImages.size());&#10;        renderFinishedSemaphore.resize(swapChainImages.size());&#10;        inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);&#10;&#10;        vk::SemaphoreCreateInfo semaphoreInfo{};&#10;        vk::FenceCreateInfo fenceInfo(vk::FenceCreateFlagBits::eSignaled);&#10;&#10;        for (size_t i = 0; i &lt; swapChainImages.size(); i++) {&#10;            presentCompleteSemaphore[i] = device.createSemaphore(semaphoreInfo);&#10;            renderFinishedSemaphore[i] = device.createSemaphore(semaphoreInfo);&#10;        }&#10;&#10;        for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;            inFlightFences[i] = device.createFence(fenceInfo);&#10;        }&#10;    }&#10;&#10;    void drawFrame() {&#10;        auto waitResult = device.waitForFences(1, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);&#10;        if (waitResult != vk::Result::eSuccess) {&#10;            throw std::runtime_error(&quot;failed to wait for fence!&quot;);&#10;        }&#10;&#10;        auto result = device.acquireNextImageKHR(swapChain, UINT64_MAX, presentCompleteSemaphore[semaphoreIndex], nullptr);&#10;        if (result.result == vk::Result::eErrorOutOfDateKHR) {&#10;            recreateSwapChain();&#10;            return;&#10;        }&#10;        if (result.result != vk::Result::eSuccess &amp;&amp; result.result != vk::Result::eSuboptimalKHR) {&#10;            throw std::runtime_error(&quot;failed to acquire swap chain image!&quot;);&#10;        }&#10;        uint32_t imageIndex = result.value;&#10;&#10;        auto resetResult = device.resetFences(1, &amp;inFlightFences[currentFrame]);&#10;        if (resetResult != vk::Result::eSuccess) {&#10;            throw std::runtime_error(&quot;failed to reset fence!&quot;);&#10;        }&#10;&#10;        commandBuffers[currentFrame].reset();&#10;        recordCommandBuffer(imageIndex);&#10;&#10;        vk::PipelineStageFlags waitStages[] = {vk::PipelineStageFlagBits::eColorAttachmentOutput};&#10;        vk::SubmitInfo submitInfo(&#10;            1,&#10;            &amp;presentCompleteSemaphore[semaphoreIndex],&#10;            waitStages,&#10;            1,&#10;            &amp;commandBuffers[currentFrame],&#10;            1,&#10;            &amp;renderFinishedSemaphore[imageIndex]&#10;        );&#10;&#10;        auto submitResult = queue.submit(1, &amp;submitInfo, inFlightFences[currentFrame]);&#10;        if (submitResult != vk::Result::eSuccess) {&#10;            throw std::runtime_error(&quot;failed to submit draw command buffer!&quot;);&#10;        }&#10;&#10;        vk::PresentInfoKHR presentInfo(&#10;            1,&#10;            &amp;renderFinishedSemaphore[imageIndex],&#10;            1,&#10;            &amp;swapChain,&#10;            &amp;imageIndex&#10;        );&#10;&#10;        auto presentResult = queue.presentKHR(presentInfo);&#10;        if (presentResult == vk::Result::eErrorOutOfDateKHR || presentResult == vk::Result::eSuboptimalKHR || framebufferResized) {&#10;            framebufferResized = false;&#10;            recreateSwapChain();&#10;        } else if (presentResult != vk::Result::eSuccess) {&#10;            throw std::runtime_error(&quot;failed to present swap chain image!&quot;);&#10;        }&#10;&#10;        semaphoreIndex = (semaphoreIndex + 1) % presentCompleteSemaphore.size();&#10;        currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;&#10;    }&#10;&#10;    vk::ShaderModule createShaderModule(const std::vector&lt;char&gt;&amp; code) {&#10;        vk::ShaderModuleCreateInfo createInfo(&#10;            {},&#10;            code.size(),&#10;            reinterpret_cast&lt;const uint32_t*&gt;(code.data())&#10;        );&#10;&#10;        return device.createShaderModule(createInfo);&#10;    }&#10;&#10;    static vk::Format chooseSwapSurfaceFormat(const std::vector&lt;vk::SurfaceFormatKHR&gt;&amp; availableFormats) {&#10;        for (const auto&amp; format : availableFormats) {&#10;            if (format.format == vk::Format::eB8G8R8A8Srgb &amp;&amp; format.colorSpace == vk::ColorSpaceKHR::eSrgbNonlinear) {&#10;                return format.format;&#10;            }&#10;        }&#10;        return availableFormats[0].format;&#10;    }&#10;&#10;    static vk::PresentModeKHR chooseSwapPresentMode(const std::vector&lt;vk::PresentModeKHR&gt;&amp; availablePresentModes) {&#10;        for (const auto&amp; availablePresentMode : availablePresentModes) {&#10;            if (availablePresentMode == vk::PresentModeKHR::eMailbox) {&#10;                return availablePresentMode;&#10;            }&#10;        }&#10;        return vk::PresentModeKHR::eFifo;&#10;    }&#10;&#10;    vk::Extent2D chooseSwapExtent(const vk::SurfaceCapabilitiesKHR&amp; capabilities) {&#10;        if (capabilities.currentExtent.width != std::numeric_limits&lt;uint32_t&gt;::max()) {&#10;            return capabilities.currentExtent;&#10;        }&#10;&#10;        int width, height;&#10;        glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;&#10;        vk::Extent2D actualExtent = {&#10;            static_cast&lt;uint32_t&gt;(width),&#10;            static_cast&lt;uint32_t&gt;(height)&#10;        };&#10;&#10;        actualExtent.width = std::clamp(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);&#10;        actualExtent.height = std::clamp(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);&#10;&#10;        return actualExtent;&#10;    }&#10;&#10;    std::vector&lt;const char*&gt; getRequiredExtensions() {&#10;        uint32_t glfwExtensionCount = 0;&#10;        const char** glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);&#10;&#10;        std::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);&#10;&#10;        if (enableValidationLayers) {&#10;            extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);&#10;        }&#10;&#10;        return extensions;&#10;    }&#10;&#10;    static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(&#10;        VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,&#10;        VkDebugUtilsMessageTypeFlagsEXT messageType,&#10;        const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,&#10;        void* pUserData) {&#10;&#10;        std::cerr &lt;&lt; &quot;validation layer: &quot; &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;&#10;&#10;        return VK_FALSE;&#10;    }&#10;&#10;    static std::vector&lt;char&gt; readFile(const std::string&amp; filename) {&#10;        std::ifstream file(filename, std::ios::ate | std::ios::binary);&#10;&#10;        if (!file.is_open()) {&#10;            throw std::runtime_error(&quot;failed to open file!&quot;);&#10;        }&#10;&#10;        size_t fileSize = (size_t) file.tellg();&#10;        std::vector&lt;char&gt; buffer(fileSize);&#10;&#10;        file.seekg(0);&#10;        file.read(buffer.data(), fileSize);&#10;&#10;        file.close();&#10;&#10;        return buffer;&#10;    }&#10;};&#10;&#10;int main() {&#10;    try {&#10;        HelloTriangleApplication app;&#10;        app.run();&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return EXIT_FAILURE;&#10;    }&#10;&#10;    return EXIT_SUCCESS;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Private/modern_shader_app.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Private/modern_shader_app.cpp" />
              <option name="updatedContent" value="#include &lt;iostream&gt;&#10;#include &lt;string&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;vulkan/vulkan.hpp&gt;&#10;&#10;#define GLFW_INCLUDE_VULKAN&#10;#include &lt;GLFW/glfw3.h&gt;&#10;&#10;// Include the existing ShaderLoader system&#10;#include &quot;../ShaderLoader/Public/ShaderLoader.h&quot;&#10;#include &quot;../ShaderLoader/Public/IShaderCompiler.h&quot;&#10;&#10;constexpr uint32_t WIDTH = 800;&#10;constexpr uint32_t HEIGHT = 600;&#10;&#10;class ModernShaderLoaderApp {&#10;public:&#10;    ModernShaderLoaderApp(const std::string&amp; vertShaderPath, const std::string&amp; fragShaderPath, const std::string&amp; computeShaderPath = &quot;&quot;)&#10;        : vertPath(vertShaderPath), fragPath(fragShaderPath), computePath(computeShaderPath) {}&#10;&#10;    void run() {&#10;        initWindow();&#10;        initVulkan();&#10;        initShaderLoader();&#10;        loadShaders();&#10;        createGraphicsPipeline();&#10;        if (!computePath.empty()) {&#10;            createComputePipeline();&#10;        }&#10;        mainLoop();&#10;        cleanup();&#10;    }&#10;&#10;private:&#10;    std::string vertPath, fragPath, computePath;&#10;    GLFWwindow* window = nullptr;&#10;    vk::Instance instance;&#10;    vk::Device device;&#10;    vk::PhysicalDevice physicalDevice;&#10;    vk::Queue graphicsQueue;&#10;    vk::Queue computeQueue;&#10;    uint32_t graphicsQueueFamily = ~0u;&#10;    uint32_t computeQueueFamily = ~0u;&#10;    vk::SwapchainKHR swapchain;&#10;    std::vector&lt;vk::Image&gt; swapchainImages;&#10;    std::vector&lt;vk::ImageView&gt; swapchainImageViews;&#10;    vk::Format swapchainImageFormat;&#10;    vk::Extent2D swapchainExtent;&#10;    vk::RenderPass renderPass;&#10;    vk::Pipeline graphicsPipeline;&#10;    vk::Pipeline computePipeline;&#10;    vk::PipelineLayout graphicsPipelineLayout;&#10;    vk::PipelineLayout computePipelineLayout;&#10;    std::vector&lt;vk::Framebuffer&gt; framebuffers;&#10;    vk::CommandPool commandPool;&#10;    vk::CommandBuffer commandBuffer;&#10;    vk::Semaphore imageAvailableSemaphore;&#10;    vk::Semaphore renderFinishedSemaphore;&#10;    vk::Fence inFlightFence;&#10;&#10;    std::unique_ptr&lt;ShaderLoader::ShaderLoader&gt; shaderLoader;&#10;&#10;    void initWindow() {&#10;        glfwInit();&#10;        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);&#10;        glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);&#10;        window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Modern Shader Loader&quot;, nullptr, nullptr);&#10;    }&#10;&#10;    void initVulkan() {&#10;        createInstance();&#10;        pickPhysicalDevice();&#10;        createLogicalDevice();&#10;        createSwapchain();&#10;        createImageViews();&#10;        createRenderPass();&#10;        createFramebuffers();&#10;        createCommandPool();&#10;        createCommandBuffer();&#10;        createSyncObjects();&#10;    }&#10;&#10;    void initShaderLoader() {&#10;        // Create a basic shader compiler that loads SPIR-V files&#10;        auto compiler = std::make_unique&lt;BasicShaderCompiler&gt;();&#10;        shaderLoader = std::make_unique&lt;ShaderLoader::ShaderLoader&gt;(std::move(compiler));&#10;    }&#10;&#10;    void loadShaders() {&#10;        std::cout &lt;&lt; &quot;Loading vertex shader: &quot; &lt;&lt; vertPath &lt;&lt; std::endl;&#10;        if (!shaderLoader-&gt;loadShader(vertPath)) {&#10;            throw std::runtime_error(&quot;Failed to load vertex shader&quot;);&#10;        }&#10;&#10;        std::cout &lt;&lt; &quot;Loading fragment shader: &quot; &lt;&lt; fragPath &lt;&lt; std::endl;&#10;        if (!shaderLoader-&gt;loadShader(fragPath)) {&#10;            throw std::runtime_error(&quot;Failed to load fragment shader&quot;);&#10;        }&#10;&#10;        if (!computePath.empty()) {&#10;            std::cout &lt;&lt; &quot;Loading compute shader: &quot; &lt;&lt; computePath &lt;&lt; std::endl;&#10;            if (!shaderLoader-&gt;loadShader(computePath)) {&#10;                throw std::runtime_error(&quot;Failed to load compute shader&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void createGraphicsPipeline() {&#10;        auto vertModule = shaderLoader-&gt;getModule(vertPath);&#10;        auto fragModule = shaderLoader-&gt;getModule(fragPath);&#10;&#10;        if (!vertModule || !fragModule) {&#10;            throw std::runtime_error(&quot;Failed to get shader modules&quot;);&#10;        }&#10;&#10;        // Create Vulkan shader modules&#10;        vk::ShaderModuleCreateInfo vertCreateInfo({}, vertModule-&gt;spirv.size() * sizeof(uint32_t), &#10;                                                   reinterpret_cast&lt;const uint32_t*&gt;(vertModule-&gt;spirv.data()));&#10;        vk::ShaderModuleCreateInfo fragCreateInfo({}, fragModule-&gt;spirv.size() * sizeof(uint32_t), &#10;                                                   reinterpret_cast&lt;const uint32_t*&gt;(fragModule-&gt;spirv.data()));&#10;&#10;        auto vertShaderModule = device.createShaderModule(vertCreateInfo);&#10;        auto fragShaderModule = device.createShaderModule(fragCreateInfo);&#10;&#10;        // Create pipeline stages&#10;        std::vector&lt;vk::PipelineShaderStageCreateInfo&gt; shaderStages = {&#10;            {{}, vk::ShaderStageFlagBits::eVertex, vertShaderModule, &quot;main&quot;},&#10;            {{}, vk::ShaderStageFlagBits::eFragment, fragShaderModule, &quot;main&quot;}&#10;        };&#10;&#10;        // Vertex input (empty for hardcoded vertex shaders)&#10;        vk::PipelineVertexInputStateCreateInfo vertexInputInfo{};&#10;&#10;        // Input assembly&#10;        vk::PipelineInputAssemblyStateCreateInfo inputAssembly({}, vk::PrimitiveTopology::eTriangleList);&#10;&#10;        // Viewport and scissor&#10;        vk::Viewport viewport(0.0f, 0.0f, WIDTH, HEIGHT, 0.0f, 1.0f);&#10;        vk::Rect2D scissor({0, 0}, {WIDTH, HEIGHT});&#10;        vk::PipelineViewportStateCreateInfo viewportState({}, 1, &amp;viewport, 1, &amp;scissor);&#10;&#10;        // Rasterizer&#10;        vk::PipelineRasterizationStateCreateInfo rasterizer({}, false, false, vk::PolygonMode::eFill,&#10;                                                             vk::CullModeFlagBits::eBack, vk::FrontFace::eClockwise);&#10;&#10;        // Multisampling&#10;        vk::PipelineMultisampleStateCreateInfo multisampling({}, vk::SampleCountFlagBits::e1);&#10;&#10;        // Color blending&#10;        vk::PipelineColorBlendAttachmentState colorBlendAttachment;&#10;        colorBlendAttachment.colorWriteMask = vk::ColorComponentFlagBits::eR | vk::ColorComponentFlagBits::eG | &#10;                                              vk::ColorComponentFlagBits::eB | vk::ColorComponentFlagBits::eA;&#10;        vk::PipelineColorBlendStateCreateInfo colorBlending({}, false, vk::LogicOp::eCopy, 1, &amp;colorBlendAttachment);&#10;&#10;        // Pipeline layout&#10;        vk::PipelineLayoutCreateInfo pipelineLayoutInfo{};&#10;        graphicsPipelineLayout = device.createPipelineLayout(pipelineLayoutInfo);&#10;&#10;        // Create pipeline&#10;        vk::GraphicsPipelineCreateInfo pipelineInfo({}, shaderStages, &amp;vertexInputInfo, &amp;inputAssembly, nullptr,&#10;                                                     &amp;viewportState, &amp;rasterizer, &amp;multisampling, nullptr,&#10;                                                     &amp;colorBlending, nullptr, graphicsPipelineLayout, renderPass, 0);&#10;&#10;        auto result = device.createGraphicsPipeline(nullptr, pipelineInfo);&#10;        graphicsPipeline = result.value;&#10;&#10;        // Cleanup&#10;        device.destroyShaderModule(vertShaderModule);&#10;        device.destroyShaderModule(fragShaderModule);&#10;&#10;        std::cout &lt;&lt; &quot;Graphics pipeline created successfully!&quot; &lt;&lt; std::endl;&#10;    }&#10;&#10;    void createComputePipeline() {&#10;        auto computeModule = shaderLoader-&gt;getModule(computePath);&#10;        if (!computeModule) {&#10;            throw std::runtime_error(&quot;Failed to get compute shader module&quot;);&#10;        }&#10;&#10;        // Create Vulkan shader module&#10;        vk::ShaderModuleCreateInfo createInfo({}, computeModule-&gt;spirv.size() * sizeof(uint32_t), &#10;                                              reinterpret_cast&lt;const uint32_t*&gt;(computeModule-&gt;spirv.data()));&#10;        auto computeShaderModule = device.createShaderModule(createInfo);&#10;&#10;        // Pipeline layout&#10;        vk::PipelineLayoutCreateInfo pipelineLayoutInfo{};&#10;        computePipelineLayout = device.createPipelineLayout(pipelineLayoutInfo);&#10;&#10;        // Create compute pipeline&#10;        vk::ComputePipelineCreateInfo pipelineInfo({}, {{}, vk::ShaderStageFlagBits::eCompute, computeShaderModule, &quot;main&quot;}, &#10;                                                    computePipelineLayout);&#10;&#10;        auto result = device.createComputePipeline(nullptr, pipelineInfo);&#10;        computePipeline = result.value;&#10;&#10;        device.destroyShaderModule(computeShaderModule);&#10;&#10;        std::cout &lt;&lt; &quot;Compute pipeline created successfully!&quot; &lt;&lt; std::endl;&#10;    }&#10;&#10;    void mainLoop() {&#10;        while (!glfwWindowShouldClose(window)) {&#10;            glfwPollEvents();&#10;            drawFrame();&#10;        }&#10;        device.waitIdle();&#10;    }&#10;&#10;    void drawFrame() {&#10;        device.waitForFences(1, &amp;inFlightFence, VK_TRUE, UINT64_MAX);&#10;        device.resetFences(1, &amp;inFlightFence);&#10;&#10;        auto [result, imageIndex] = device.acquireNextImageKHR(swapchain, UINT64_MAX, imageAvailableSemaphore, nullptr);&#10;&#10;        commandBuffer.reset();&#10;        recordCommandBuffer(imageIndex);&#10;&#10;        vk::SubmitInfo submitInfo;&#10;        vk::PipelineStageFlags waitStages[] = {vk::PipelineStageFlagBits::eColorAttachmentOutput};&#10;        submitInfo.setWaitSemaphores(imageAvailableSemaphore);&#10;        submitInfo.setWaitDstStageMask(waitStages);&#10;        submitInfo.setCommandBuffers(commandBuffer);&#10;        submitInfo.setSignalSemaphores(renderFinishedSemaphore);&#10;&#10;        graphicsQueue.submit(submitInfo, inFlightFence);&#10;&#10;        vk::PresentInfoKHR presentInfo;&#10;        presentInfo.setWaitSemaphores(renderFinishedSemaphore);&#10;        presentInfo.setSwapchains(swapchain);&#10;        presentInfo.setImageIndices(imageIndex);&#10;&#10;        graphicsQueue.presentKHR(presentInfo);&#10;    }&#10;&#10;    void recordCommandBuffer(uint32_t imageIndex) {&#10;        vk::CommandBufferBeginInfo beginInfo{};&#10;        commandBuffer.begin(beginInfo);&#10;&#10;        vk::RenderPassBeginInfo renderPassInfo;&#10;        renderPassInfo.renderPass = renderPass;&#10;        renderPassInfo.framebuffer = framebuffers[imageIndex];&#10;        renderPassInfo.renderArea.offset = vk::Offset2D{0, 0};&#10;        renderPassInfo.renderArea.extent = swapchainExtent;&#10;&#10;        vk::ClearValue clearColor = vk::ClearColorValue(std::array&lt;float, 4&gt;{0.0f, 0.0f, 0.0f, 1.0f});&#10;        renderPassInfo.setClearValues(clearColor);&#10;&#10;        commandBuffer.beginRenderPass(renderPassInfo, vk::SubpassContents::eInline);&#10;        commandBuffer.bindPipeline(vk::PipelineBindPoint::eGraphics, graphicsPipeline);&#10;        &#10;        // Draw 6 vertices for hexagon (adjust based on your shader)&#10;        commandBuffer.draw(6, 1, 0, 0);&#10;        &#10;        commandBuffer.endRenderPass();&#10;        commandBuffer.end();&#10;    }&#10;&#10;    // ... (other Vulkan setup methods - createInstance, pickPhysicalDevice, etc.)&#10;    // These would be similar to the existing implementation but simplified&#10;&#10;    void cleanup() {&#10;        if (computePipeline) {&#10;            device.destroyPipeline(computePipeline);&#10;            device.destroyPipelineLayout(computePipelineLayout);&#10;        }&#10;        &#10;        device.destroyPipeline(graphicsPipeline);&#10;        device.destroyPipelineLayout(graphicsPipelineLayout);&#10;        &#10;        for (auto framebuffer : framebuffers) {&#10;            device.destroyFramebuffer(framebuffer);&#10;        }&#10;        &#10;        device.destroyRenderPass(renderPass);&#10;        &#10;        for (auto imageView : swapchainImageViews) {&#10;            device.destroyImageView(imageView);&#10;        }&#10;        &#10;        device.destroySwapchainKHR(swapchain);&#10;        device.destroyCommandPool(commandPool);&#10;        device.destroySemaphore(imageAvailableSemaphore);&#10;        device.destroySemaphore(renderFinishedSemaphore);&#10;        device.destroyFence(inFlightFence);&#10;        device.destroy();&#10;        &#10;        glfwDestroyWindow(window);&#10;        glfwTerminate();&#10;    }&#10;&#10;    // Simplified Vulkan setup methods would go here...&#10;};&#10;&#10;// Basic implementation of IShaderCompiler for loading SPIR-V files&#10;class BasicShaderCompiler : public ShaderLoader::IShaderCompiler {&#10;public:&#10;    ShaderLoader::ShaderModule loadSpirvFromFile(const std::string&amp; path) override {&#10;        ShaderLoader::ShaderModule module;&#10;        &#10;        std::ifstream file(path, std::ios::ate | std::ios::binary);&#10;        if (!file.is_open()) {&#10;            module.infoLog = &quot;Failed to open file: &quot; + path;&#10;            return module;&#10;        }&#10;&#10;        size_t fileSize = static_cast&lt;size_t&gt;(file.tellg());&#10;        module.spirv.resize(fileSize / sizeof(uint32_t));&#10;&#10;        file.seekg(0);&#10;        file.read(reinterpret_cast&lt;char*&gt;(module.spirv.data()), fileSize);&#10;        file.close();&#10;&#10;        module.infoLog = &quot;Successfully loaded: &quot; + path;&#10;        return module;&#10;    }&#10;};&#10;&#10;int main(int argc, char* argv[]) {&#10;    try {&#10;        std::string vertShader = &quot;../shaders/triangle.vert.spv&quot;;&#10;        std::string fragShader = &quot;../shaders/triangle.frag.spv&quot;;&#10;        std::string computeShader = &quot;&quot;;&#10;&#10;        // Command line arguments for shader selection&#10;        if (argc &gt;= 3) {&#10;            vertShader = argv[1];&#10;            fragShader = argv[2];&#10;        }&#10;        if (argc &gt;= 4) {&#10;            computeShader = argv[3];&#10;        }&#10;&#10;        std::cout &lt;&lt; &quot;Starting Modern Shader Loader App&quot; &lt;&lt; std::endl;&#10;        std::cout &lt;&lt; &quot;Vertex Shader: &quot; &lt;&lt; vertShader &lt;&lt; std::endl;&#10;        std::cout &lt;&lt; &quot;Fragment Shader: &quot; &lt;&lt; fragShader &lt;&lt; std::endl;&#10;        if (!computeShader.empty()) {&#10;            std::cout &lt;&lt; &quot;Compute Shader: &quot; &lt;&lt; computeShader &lt;&lt; std::endl;&#10;        }&#10;&#10;        ModernShaderLoaderApp app(vertShader, fragShader, computeShader);&#10;        app.run();&#10;&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return EXIT_FAILURE;&#10;    }&#10;&#10;    return EXIT_SUCCESS;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/RenderPass.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/RenderPass.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/RenderPass.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/RenderPass.h" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;vulkan/vulkan.h&gt;&#10;&#10;class RenderPass {&#10;public:&#10;  RenderPass(VkDevice device, VkFormat colorFormat);&#10;  ~RenderPass();&#10;&#10;  VkRenderPass get() const { return renderPass; }&#10;  void createIfNeeded();&#10;&#10;private:&#10;  VkDevice device;&#10;  VkFormat colorFormat;&#10;  VkRenderPass renderPass = VK_NULL_HANDLE;&#10;&#10;  void createRenderPass();&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/ShaderLoader/Private/ShaderLoader.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ShaderLoader/Private/ShaderLoader.cpp" />
              <option name="originalContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;#include &quot;../Public/ShaderLoader.h&quot;&#10;#include &lt;fstream&gt;&#10;        // read file&#10;        // read file&#10;        // read file&#10;        // read file&#10;        // read file&#10;        // read file&#10;        // read file&#10;        // read file&#10;        // read file&#10;        std::ifstream in(path);&#10;        if (!in) return false;&#10;        std::string src{ std::istreambuf_iterator&lt;char&gt;(in),&#10;                         std::istreambuf_iterator&lt;char&gt;() };&#10;&#10;        // infer language from extension&#10;        ShaderLanguage lang = (path.ends_with(&quot;.hlsl&quot;) ? ShaderLanguage::HLSL : ShaderLanguage::GLSL);&#10;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;        if (!module.infoLog.empty()) {&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;        // read file&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;        // read file&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;        // read file&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;&#10;        if (module.spirv.empty()) return false;&#10;        auto module = m_compiler-&gt;compileFromSource(src, lang);&#10;            // compilation errors/warnings can be logged here&#10;        }&#10;        if (module.spirv.empty()) return false;&#10;&#10;        m_modules[path] = std::move(module);&#10;        return true;&#10;    }&#10;&#10;    const ShaderModule* ShaderLoader::getModule(const std::string&amp; path) const {&#10;        auto it = m_modules.find(path);&#10;        return (it != m_modules.end() ? &amp;it-&gt;second : nullptr);&#10;    }&#10;&#10;} // namespace ShaderLoader&#10;" />
              <option name="updatedContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;#include &quot;../Public/ShaderLoader.h&quot;&#10;#include &lt;fstream&gt;&#10;#include &lt;iostream&gt;&#10;&#10;namespace ShaderLoader {&#10;&#10;    ShaderLoader::ShaderLoader(std::unique_ptr&lt;IShaderCompiler&gt; compiler)&#10;        : m_compiler(std::move(compiler))&#10;    {}&#10;&#10;    bool ShaderLoader::loadShader(const std::string&amp; path) {&#10;        // Load SPIR-V directly from file&#10;        auto module = m_compiler-&gt;loadSpirvFromFile(path);&#10;        &#10;        if (module.spirv.empty()) {&#10;            // Log error but don't fail completely&#10;            std::cout &lt;&lt; &quot;Failed to load SPIR-V shader: &quot; &lt;&lt; module.infoLog &lt;&lt; std::endl;&#10;            return false;&#10;        }&#10;&#10;        std::cout &lt;&lt; module.infoLog &lt;&lt; std::endl; // Success message&#10;        m_modules[path] = std::move(module);&#10;        return true;&#10;    }&#10;&#10;    const ShaderModule* ShaderLoader::getModule(const std::string&amp; path) const {&#10;        auto it = m_modules.find(path);&#10;        return (it != m_modules.end() ? &amp;it-&gt;second : nullptr);&#10;    }&#10;&#10;} // namespace ShaderLoader" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/ShaderLoader/Public/IShaderCompiler.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ShaderLoader/Public/IShaderCompiler.h" />
              <option name="originalContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;#ifndef ISHADERCOMPILER_H&#10;#define ISHADERCOMPILER_H&#10;#pragma once&#10;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstdint&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;memory&gt;&#10;&#10;namespace ShaderLoader {&#10;&#10;    enum class ShaderLanguage {&#10;        GLSL,&#10;        HLSL&#10;    };&#10;&#10;    struct ShaderModule {&#10;        std::vector&lt;uint32_t&gt; spirv;&#10;        std::string           infoLog;&#10;    };&#10;&#10;    class IShaderCompiler {&#10;    public:&#10;        virtual ~IShaderCompiler() = default;&#10;&#10;        virtual ShaderModule compileFromSource(&#10;            const std::string&amp;             src,&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;            ShaderLanguage                 lang,&#10;            const std::string&amp;             entry   = &quot;main&quot;,&#10;            const std::vector&lt;std::string&gt;&amp; defines = {}&#10;        ) = 0;&#10;&#10;        virtual ShaderModule compileFromFile(&#10;            const std::string&amp; path,&#10;            ShaderLanguage     lang&#10;        ) = 0;&#10;    };&#10;&#10;    // Factory function to create the default compiler&#10;    std::unique_ptr&lt;IShaderCompiler&gt; createDefaultCompiler();&#10;&#10;}&#10;&#10;#endif&#10;" />
              <option name="updatedContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;#ifndef ISHADERCOMPILER_H&#10;#define ISHADERCOMPILER_H&#10;#pragma once&#10;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstdint&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;memory&gt;&#10;&#10;namespace ShaderLoader {&#10;&#10;    enum class ShaderLanguage {&#10;        GLSL,&#10;        HLSL&#10;    };&#10;&#10;    struct ShaderModule {&#10;        std::vector&lt;uint32_t&gt; spirv;&#10;        std::string           infoLog;&#10;    };&#10;&#10;    class IShaderCompiler {&#10;    public:&#10;        virtual ~IShaderCompiler() = default;&#10;&#10;        // Load SPIR-V directly from file&#10;        virtual ShaderModule loadSpirvFromFile(const std::string&amp; path) = 0;&#10;    };&#10;&#10;    // Factory function to create the default compiler&#10;    std::unique_ptr&lt;IShaderCompiler&gt; createDefaultCompiler();&#10;&#10;}&#10;&#10;#endif" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/VulkanCore/Private/MainWindow.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/VulkanCore/Private/MainWindow.cpp" />
              <option name="originalContent" value="#include &quot;MainWindow.h&quot;&#10;#include &lt;QVBoxLayout&gt;&#10;#include &lt;QPushButton&gt;&#10;#include &lt;QComboBox&gt;&#10;#include &lt;QFileDialog&gt;&#10;#include &lt;QVulkanWindow&gt;&#10;    QVulkanInstance* vulkanInstance = new QVulkanInstance();&#10;    vulkanInstance-&gt;setApiVersion(QVersionNumber(1, 1, 0));&#10;    if (!vulkanInstance-&gt;create()) {&#10;        qFatal(&quot;Failed to create Vulkan instance&quot;);&#10;    }&#10;&#10;    // Set Vulkan instance for QVulkanWindow&#10;    m_vulkanWindow = new QVulkanWindow();&#10;    m_vulkanWindow-&gt;setVulkanInstance(vulkanInstance);&#10;&#10;    // Set up the central widget and layout&#10;    QWidget* centralWidget = new QWidget(this);&#10;    QVBoxLayout* layout = new QVBoxLayout(centralWidget);&#10;&#10;    // Add Vulkan rendering window&#10;    QWidget* vulkanWidget = QWidget::createWindowContainer(m_vulkanWindow);&#10;    layout-&gt;addWidget(vulkanWidget);&#10;&#10;    // Add shader selection dropdown&#10;    QComboBox* shaderDropdown = new QComboBox(this);&#10;    shaderDropdown-&gt;addItem(&quot;Vertex Shader&quot;);&#10;    shaderDropdown-&gt;addItem(&quot;Fragment Shader&quot;);&#10;    layout-&gt;addWidget(shaderDropdown);&#10;&#10;    // Add load shader button&#10;    QPushButton* loadShaderButton = new QPushButton(&quot;Load Shader&quot;, this);&#10;    layout-&gt;addWidget(loadShaderButton);&#10;&#10;    // Connect button click to shader loading&#10;    connect(loadShaderButton, &amp;QPushButton::clicked, this, [this, shaderDropdown]() {&#10;        QString filePath = QFileDialog::getOpenFileName(this, &quot;Select Shader File&quot;, &quot;./shaders&quot;, &quot;SPIR-V Files (*.spv)&quot;);&#10;        if (!filePath.isEmpty()) {&#10;            loadShader(filePath, shaderDropdown-&gt;currentText());&#10;        }&#10;    });&#10;&#10;    setCentralWidget(centralWidget);&#10;}&#10;&#10;void MainWindow::loadShader(const QString&amp; filePath, const QString&amp; shaderType) {&#10;    // Logic to load and apply the shader based on type&#10;    // Logic to load and apply the shader based on type&#10;    // Logic to load and apply the shader based on type&#10;    // Logic to load and apply the shader based on type&#10;    if (shaderType == &quot;Vertex Shader&quot;) {&#10;        // Load vertex shader&#10;        // Load fragment shader&#10;        // Load fragment shader&#10;        // Load fragment shader&#10;" />
              <option name="updatedContent" value="#include &quot;MainWindow.h&quot;&#10;#include &lt;QVBoxLayout&gt;&#10;#include &lt;QPushButton&gt;&#10;#include &lt;QComboBox&gt;&#10;#include &lt;QFileDialog&gt;&#10;#include &lt;QVulkanWindow&gt;&#10;#include &lt;QDebug&gt;&#10;&#10;MainWindow::MainWindow(QWidget* parent) : QMainWindow(parent) {&#10;    // Create Vulkan instance&#10;    QVulkanInstance* vulkanInstance = new QVulkanInstance();&#10;    vulkanInstance-&gt;setApiVersion(QVersionNumber(1, 1, 0));&#10;    if (!vulkanInstance-&gt;create()) {&#10;        qFatal(&quot;Failed to create Vulkan instance&quot;);&#10;    }&#10;&#10;    // Set Vulkan instance for QVulkanWindow&#10;    m_vulkanWindow = new QVulkanWindow();&#10;    m_vulkanWindow-&gt;setVulkanInstance(vulkanInstance);&#10;&#10;    // Set up the central widget and layout&#10;    QWidget* centralWidget = new QWidget(this);&#10;    QVBoxLayout* layout = new QVBoxLayout(centralWidget);&#10;&#10;    // Add Vulkan rendering window&#10;    QWidget* vulkanWidget = QWidget::createWindowContainer(m_vulkanWindow);&#10;    layout-&gt;addWidget(vulkanWidget);&#10;&#10;    // Add shader selection dropdown&#10;    QComboBox* shaderDropdown = new QComboBox(this);&#10;    shaderDropdown-&gt;addItem(&quot;Vertex Shader&quot;);&#10;    shaderDropdown-&gt;addItem(&quot;Fragment Shader&quot;);&#10;    layout-&gt;addWidget(shaderDropdown);&#10;&#10;    // Add load shader button&#10;    QPushButton* loadShaderButton = new QPushButton(&quot;Load Shader&quot;, this);&#10;    layout-&gt;addWidget(loadShaderButton);&#10;&#10;    // Connect button click to shader loading&#10;    connect(loadShaderButton, &amp;QPushButton::clicked, this, [this, shaderDropdown]() {&#10;        QString filePath = QFileDialog::getOpenFileName(this, &quot;Select Shader File&quot;, &quot;./shaders&quot;, &quot;SPIR-V Files (*.spv)&quot;);&#10;        if (!filePath.isEmpty()) {&#10;            loadShader(filePath, shaderDropdown-&gt;currentText());&#10;        }&#10;    });&#10;&#10;    setCentralWidget(centralWidget);&#10;}&#10;&#10;void MainWindow::loadShader(const QString&amp; filePath, const QString&amp; shaderType) {&#10;    if (shaderType == &quot;Vertex Shader&quot;) {&#10;        // Load vertex shader logic&#10;        qDebug() &lt;&lt; &quot;Loading vertex shader from: &quot; &lt;&lt; filePath;&#10;        // ... Vulkan logic to apply vertex shader ...&#10;    } else if (shaderType == &quot;Fragment Shader&quot;) {&#10;        // Load fragment shader logic&#10;        qDebug() &lt;&lt; &quot;Loading fragment shader from: &quot; &lt;&lt; filePath;&#10;        // ... Vulkan logic to apply fragment shader ...&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/VulkanCore/Private/QtVulkanWindow.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/VulkanCore/Private/QtVulkanWindow.cpp" />
              <option name="originalContent" value="//&#10;// Created by charlie on 8/2/25.&#10;//&#10;&#10;#include &quot;../Public/QtVulkanWindow.h&quot;&#10;#include &quot;../Public/IVulkanContext.h&quot;&#10;#include &quot;../Public/VulkanRenderer.h&quot;&#10;#include &quot;../../ShaderLoader/Public/ShaderLoader.h&quot;&#10;#include &quot;../../ShaderLoader/Public/IShaderCompiler.h&quot;&#10;#include &lt;vulkan/vulkan.h&gt;&#10;#include &lt;QVulkanDeviceFunctions&gt;&#10;&#10;namespace VulkanCore {&#10;&#10;    class VulkanWindowRenderer : public QVulkanWindowRenderer {&#10;    public:&#10;        VulkanWindowRenderer(QVulkanWindow* w)&#10;            : m_window(w)&#10;        {&#10;            m_context = createVulkanContext();&#10;            // Use Qt's existing Vulkan instance instead of creating our own&#10;            VkInstance qtInstance = w-&gt;vulkanInstance()-&gt;vkInstance();&#10;            m_context-&gt;initializeWithExistingInstance(qtInstance);&#10;        }&#10;&#10;        void initResources() override {&#10;            // No long‐lived resources here; Qt handles instance &amp; surface&#10;        }&#10;&#10;        void initSwapChainResources() override {&#10;            m_renderer = std::make_unique&lt;VulkanRenderer&gt;(m_context);&#10;            m_renderer-&gt;initialize(m_window);&#10;&#10;            // Load shaders from files first, then fall back to default paths&#10;            if (m_vertexSpirv.empty() || m_fragmentSpirv.empty()) {&#10;                // Try to load from default paths instead of hardcoded SPIR-V&#10;                loadDefaultShadersFromFiles();&#10;            }&#10;&#10;            // Only create pipeline if we have valid shaders&#10;            if (!m_vertexSpirv.empty() &amp;&amp; !m_fragmentSpirv.empty()) {&#10;                createGraphicsPipeline();&#10;            }&#10;        }&#10;&#10;        void releaseSwapChainResources() override {&#10;            if (m_renderer) {&#10;                m_renderer-&gt;cleanup();&#10;                m_renderer.reset();&#10;            }&#10;        }&#10;&#10;        void releaseResources() override {&#10;            if (m_context) {&#10;                m_context-&gt;cleanup();&#10;                m_context.reset();&#10;            }&#10;        }&#10;&#10;        void startNextFrame() override {&#10;            if (!m_renderer || m_renderer-&gt;getPipeline() == VK_NULL_HANDLE) {&#10;                m_window-&gt;frameReady();&#10;                return;&#10;            }&#10;&#10;            // Use Qt's command buffer properly&#10;            VkCommandBuffer cb = m_window-&gt;currentCommandBuffer();&#10;            const QSize sz = m_window-&gt;swapChainImageSize();&#10;&#10;            // Get Qt's device functions&#10;            QVulkanDeviceFunctions* devFuncs = m_window-&gt;vulkanInstance()-&gt;deviceFunctions(m_window-&gt;device());&#10;&#10;            // Begin Qt's render pass&#10;            VkClearColorValue clearColor = {{0.0f, 0.0f, 0.0f, 1.0f}};&#10;            VkClearValue clearValues[1];&#10;            clearValues[0].color = clearColor;&#10;&#10;            VkRenderPassBeginInfo rpBeginInfo;&#10;            memset(&amp;rpBeginInfo, 0, sizeof(rpBeginInfo));&#10;            rpBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;&#10;            rpBeginInfo.renderPass = m_window-&gt;defaultRenderPass();&#10;            rpBeginInfo.framebuffer = m_window-&gt;currentFramebuffer();&#10;            rpBeginInfo.renderArea.extent.width = sz.width();&#10;            rpBeginInfo.renderArea.extent.height = sz.height();&#10;            rpBeginInfo.clearValueCount = 1;&#10;            rpBeginInfo.pClearValues = clearValues;&#10;&#10;            devFuncs-&gt;vkCmdBeginRenderPass(cb, &amp;rpBeginInfo, VK_SUBPASS_CONTENTS_INLINE);&#10;&#10;            // Bind our pipeline and draw&#10;            if (m_renderer-&gt;getPipeline() != VK_NULL_HANDLE) {&#10;                devFuncs-&gt;vkCmdBindPipeline(cb, VK_PIPELINE_BIND_POINT_GRAPHICS, m_renderer-&gt;getPipeline());&#10;&#10;                // Set viewport and scissor&#10;                VkViewport viewport;&#10;                viewport.x = 0;&#10;                viewport.y = 0;&#10;                viewport.width = sz.width();&#10;                viewport.height = sz.height();&#10;                viewport.minDepth = 0.0f;&#10;                viewport.maxDepth = 1.0f;&#10;                devFuncs-&gt;vkCmdSetViewport(cb, 0, 1, &amp;viewport);&#10;&#10;                VkRect2D scissor;&#10;                scissor.offset.x = 0;&#10;                scissor.offset.y = 0;&#10;                scissor.extent.width = sz.width();&#10;                scissor.extent.height = sz.height();&#10;                devFuncs-&gt;vkCmdSetScissor(cb, 0, 1, &amp;scissor);&#10;&#10;                // Draw triangle (3 vertices, no vertex buffer needed)&#10;                devFuncs-&gt;vkCmdDraw(cb, 3, 1, 0, 0);&#10;            }&#10;&#10;            devFuncs-&gt;vkCmdEndRenderPass(cb);&#10;&#10;            m_window-&gt;frameReady();&#10;        }&#10;&#10;        // Method to load custom shaders&#10;        bool loadShaders(const std::vector&lt;uint32_t&gt;&amp; vertexSpirv, const std::vector&lt;uint32_t&gt;&amp; fragmentSpirv) {&#10;            m_vertexSpirv = vertexSpirv;&#10;            m_fragmentSpirv = fragmentSpirv;&#10;&#10;            if (m_renderer) {&#10;                return createGraphicsPipeline();&#10;            }&#10;            return true; // Will be created when renderer is initialized&#10;        }&#10;&#10;    private:&#10;        QVulkanWindow* m_window;&#10;        std::shared_ptr&lt;IVulkanContext&gt; m_context;&#10;        std::unique_ptr&lt;VulkanRenderer&gt; m_renderer;&#10;        std::vector&lt;uint32_t&gt; m_vertexSpirv;&#10;        std::vector&lt;uint32_t&gt; m_fragmentSpirv;&#10;&#10;        void loadDefaultShadersFromFiles() {&#10;            // Load from actual shader files instead of hardcoded SPIR-V&#10;            auto compiler = ShaderLoader::createDefaultCompiler();&#10;            ShaderLoader::ShaderLoader loader(std::move(compiler));&#10;&#10;            // Use absolute paths to the shaders directory&#10;            std::string basePath = &quot;/home/charlie/CLionProjects/ShaderLoader/shaders/&quot;;&#10;            std::string vertexPath = basePath + &quot;triangle.vert.spv&quot;;&#10;            std::string fragmentPath = basePath + &quot;triangle.frag.spv&quot;;&#10;&#10;            if (loader.loadShader(vertexPath)) {&#10;                auto* vertexModule = loader.getModule(vertexPath);&#10;                if (vertexModule &amp;&amp; !vertexModule-&gt;spirv.empty()) {&#10;                    m_vertexSpirv = vertexModule-&gt;spirv;&#10;                }&#10;            }&#10;&#10;            if (loader.loadShader(fragmentPath)) {&#10;                auto* fragmentModule = loader.getModule(fragmentPath);&#10;                if (fragmentModule &amp;&amp; !fragmentModule-&gt;spirv.empty()) {&#10;                    m_fragmentSpirv = fragmentModule-&gt;spirv;&#10;                }&#10;            }&#10;        }&#10;&#10;        void createDefaultShaders() {&#10;            // Remove the hardcoded SPIR-V and use file loading instead&#10;            loadDefaultShadersFromFiles();&#10;        }&#10;&#10;        bool createGraphicsPipeline() {&#10;            if (!m_renderer || m_vertexSpirv.empty() || m_fragmentSpirv.empty()) {&#10;                return false;&#10;            }&#10;&#10;            PipelineCreateInfo createInfo;&#10;            createInfo.vertexSpirv = m_vertexSpirv;&#10;            createInfo.fragmentSpirv = m_fragmentSpirv;&#10;            createInfo.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;&#10;            createInfo.renderPass = m_window-&gt;defaultRenderPass(); // Use Qt's render pass&#10;            createInfo.swapChainExtent = {&#10;                static_cast&lt;uint32_t&gt;(m_window-&gt;swapChainImageSize().width()),&#10;                static_cast&lt;uint32_t&gt;(m_window-&gt;swapChainImageSize().height())&#10;            };&#10;&#10;            return m_renderer-&gt;createPipeline(createInfo);&#10;        }&#10;    };&#10;&#10;    QVulkanWindowRenderer* QtVulkanWindow::createRenderer() {&#10;        m_renderer = new VulkanWindowRenderer(this);&#10;        return m_renderer;&#10;    }&#10;&#10;    bool QtVulkanWindow::loadShadersFromFiles(const QString&amp; vertexShaderPath, const QString&amp; fragmentShaderPath) {&#10;        // Use the existing ShaderLoader infrastructure&#10;        auto compiler = ShaderLoader::createDefaultCompiler();&#10;        ShaderLoader::ShaderLoader loader(std::move(compiler));&#10;&#10;        // Load vertex shader&#10;        if (!loader.loadShader(vertexShaderPath.toStdString())) {&#10;            return false;&#10;        }&#10;        auto* vertexModule = loader.getModule(vertexShaderPath.toStdString());&#10;        if (!vertexModule || vertexModule-&gt;spirv.empty()) {&#10;            return false;&#10;        }&#10;&#10;        // Load fragment shader&#10;        if (!loader.loadShader(fragmentShaderPath.toStdString())) {&#10;            return false;&#10;        }&#10;        auto* fragmentModule = loader.getModule(fragmentShaderPath.toStdString());&#10;        if (!fragmentModule || fragmentModule-&gt;spirv.empty()) {&#10;            return false;&#10;        }&#10;&#10;        // Load shaders into the renderer&#10;        if (m_renderer) {&#10;            auto* vulkanRenderer = static_cast&lt;VulkanWindowRenderer*&gt;(m_renderer);&#10;            return vulkanRenderer-&gt;loadShaders(vertexModule-&gt;spirv, fragmentModule-&gt;spirv);&#10;        }&#10;&#10;        return true; // Will be loaded when renderer is created&#10;    }&#10;&#10;} // namespace VulkanCore&#10;" />
              <option name="updatedContent" value="//&#10;// Created by charlie on 8/2/25.&#10;//&#10;&#10;#include &quot;../Public/QtVulkanWindow.h&quot;&#10;#include &quot;../Public/IVulkanContext.h&quot;&#10;#include &quot;../Public/VulkanRenderer.h&quot;&#10;#include &quot;../../ShaderLoader/Public/ShaderLoader.h&quot;&#10;#include &quot;../../ShaderLoader/Public/IShaderCompiler.h&quot;&#10;#include &lt;vulkan/vulkan.h&gt;&#10;#include &lt;QVulkanDeviceFunctions&gt;&#10;&#10;namespace VulkanCore {&#10;&#10;    class VulkanWindowRenderer : public QVulkanWindowRenderer {&#10;    public:&#10;        VulkanWindowRenderer(QVulkanWindow* w)&#10;            : m_window(w)&#10;        {&#10;            m_context = createVulkanContext();&#10;            // Use Qt's existing Vulkan instance instead of creating our own&#10;            VkInstance qtInstance = w-&gt;vulkanInstance()-&gt;vkInstance();&#10;            m_context-&gt;initializeWithExistingInstance(qtInstance);&#10;        }&#10;&#10;        void initResources() override {&#10;            // No long‐lived resources here; Qt handles instance &amp; surface&#10;        }&#10;&#10;        void initSwapChainResources() override {&#10;            m_renderer = std::make_unique&lt;VulkanRenderer&gt;(m_context);&#10;            m_renderer-&gt;initialize(m_window);&#10;&#10;            // Load shaders from files first, then fall back to default paths&#10;            if (m_vertexSpirv.empty() || m_fragmentSpirv.empty()) {&#10;                // Try to load from default paths instead of hardcoded SPIR-V&#10;                loadDefaultShadersFromFiles();&#10;            }&#10;&#10;            // Only create pipeline if we have valid shaders&#10;            if (!m_vertexSpirv.empty() &amp;&amp; !m_fragmentSpirv.empty()) {&#10;                createGraphicsPipeline();&#10;            }&#10;        }&#10;&#10;        void releaseSwapChainResources() override {&#10;            if (m_renderer) {&#10;                m_renderer-&gt;cleanup();&#10;                m_renderer.reset();&#10;            }&#10;        }&#10;&#10;        void releaseResources() override {&#10;            if (m_context) {&#10;                m_context-&gt;cleanup();&#10;                m_context.reset();&#10;            }&#10;        }&#10;&#10;        void startNextFrame() override {&#10;            if (!m_renderer || m_renderer-&gt;getPipeline() == VK_NULL_HANDLE) {&#10;                std::cerr &lt;&lt; &quot;Pipeline is NULL, skipping frame&quot; &lt;&lt; std::endl;&#10;                m_window-&gt;frameReady();&#10;                return;&#10;            }&#10;&#10;            // Use Qt's command buffer properly&#10;            VkCommandBuffer cb = m_window-&gt;currentCommandBuffer();&#10;            const QSize sz = m_window-&gt;swapChainImageSize();&#10;            &#10;            std::cerr &lt;&lt; &quot;Rendering frame, size: &quot; &lt;&lt; sz.width() &lt;&lt; &quot;x&quot; &lt;&lt; sz.height() &lt;&lt; std::endl;&#10;            &#10;            // Get Qt's device functions&#10;            QVulkanDeviceFunctions* devFuncs = m_window-&gt;vulkanInstance()-&gt;deviceFunctions(m_window-&gt;device());&#10;&#10;            // Begin Qt's render pass&#10;            VkClearColorValue clearColor = {{0.2f, 0.3f, 0.3f, 1.0f}}; // Dark green background for visibility&#10;            VkClearValue clearValues[1];&#10;            clearValues[0].color = clearColor;&#10;&#10;            VkRenderPassBeginInfo rpBeginInfo;&#10;            memset(&amp;rpBeginInfo, 0, sizeof(rpBeginInfo));&#10;            rpBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;&#10;            rpBeginInfo.renderPass = m_window-&gt;defaultRenderPass();&#10;            rpBeginInfo.framebuffer = m_window-&gt;currentFramebuffer();&#10;            rpBeginInfo.renderArea.extent.width = sz.width();&#10;            rpBeginInfo.renderArea.extent.height = sz.height();&#10;            rpBeginInfo.clearValueCount = 1;&#10;            rpBeginInfo.pClearValues = clearValues;&#10;&#10;            devFuncs-&gt;vkCmdBeginRenderPass(cb, &amp;rpBeginInfo, VK_SUBPASS_CONTENTS_INLINE);&#10;&#10;            // Bind our pipeline and draw&#10;            if (m_renderer-&gt;getPipeline() != VK_NULL_HANDLE) {&#10;                std::cerr &lt;&lt; &quot;Binding pipeline and drawing triangle&quot; &lt;&lt; std::endl;&#10;                devFuncs-&gt;vkCmdBindPipeline(cb, VK_PIPELINE_BIND_POINT_GRAPHICS, m_renderer-&gt;getPipeline());&#10;&#10;                // Set viewport and scissor&#10;                VkViewport viewport;&#10;                viewport.x = 0;&#10;                viewport.y = 0;&#10;                viewport.width = sz.width();&#10;                viewport.height = sz.height();&#10;                viewport.minDepth = 0.0f;&#10;                viewport.maxDepth = 1.0f;&#10;                devFuncs-&gt;vkCmdSetViewport(cb, 0, 1, &amp;viewport);&#10;&#10;                VkRect2D scissor;&#10;                scissor.offset.x = 0;&#10;                scissor.offset.y = 0;&#10;                scissor.extent.width = sz.width();&#10;                scissor.extent.height = sz.height();&#10;                devFuncs-&gt;vkCmdSetScissor(cb, 0, 1, &amp;scissor);&#10;&#10;                // Draw triangle (3 vertices, no vertex buffer needed)&#10;                devFuncs-&gt;vkCmdDraw(cb, 3, 1, 0, 0);&#10;                std::cerr &lt;&lt; &quot;Triangle draw command issued&quot; &lt;&lt; std::endl;&#10;            } else {&#10;                std::cerr &lt;&lt; &quot;Pipeline is NULL!&quot; &lt;&lt; std::endl;&#10;            }&#10;&#10;            devFuncs-&gt;vkCmdEndRenderPass(cb);&#10;&#10;            m_window-&gt;frameReady();&#10;        }&#10;&#10;        // Method to load custom shaders&#10;        bool loadShaders(const std::vector&lt;uint32_t&gt;&amp; vertexSpirv, const std::vector&lt;uint32_t&gt;&amp; fragmentSpirv) {&#10;            m_vertexSpirv = vertexSpirv;&#10;            m_fragmentSpirv = fragmentSpirv;&#10;&#10;            if (m_renderer) {&#10;                return createGraphicsPipeline();&#10;            }&#10;            return true; // Will be created when renderer is initialized&#10;        }&#10;&#10;    private:&#10;        QVulkanWindow* m_window;&#10;        std::shared_ptr&lt;IVulkanContext&gt; m_context;&#10;        std::unique_ptr&lt;VulkanRenderer&gt; m_renderer;&#10;        std::vector&lt;uint32_t&gt; m_vertexSpirv;&#10;        std::vector&lt;uint32_t&gt; m_fragmentSpirv;&#10;&#10;        void loadDefaultShadersFromFiles() {&#10;            // Load from actual shader files instead of hardcoded SPIR-V&#10;            auto compiler = ShaderLoader::createDefaultCompiler();&#10;            ShaderLoader::ShaderLoader loader(std::move(compiler));&#10;&#10;            // Use absolute paths to the shaders directory&#10;            std::string basePath = &quot;/home/charlie/CLionProjects/ShaderLoader/shaders/&quot;;&#10;            std::string vertexPath = basePath + &quot;triangle.vert.spv&quot;;&#10;            std::string fragmentPath = basePath + &quot;triangle.frag.spv&quot;;&#10;&#10;            if (loader.loadShader(vertexPath)) {&#10;                auto* vertexModule = loader.getModule(vertexPath);&#10;                if (vertexModule &amp;&amp; !vertexModule-&gt;spirv.empty()) {&#10;                    m_vertexSpirv = vertexModule-&gt;spirv;&#10;                }&#10;            }&#10;&#10;            if (loader.loadShader(fragmentPath)) {&#10;                auto* fragmentModule = loader.getModule(fragmentPath);&#10;                if (fragmentModule &amp;&amp; !fragmentModule-&gt;spirv.empty()) {&#10;                    m_fragmentSpirv = fragmentModule-&gt;spirv;&#10;                }&#10;            }&#10;        }&#10;&#10;        void createDefaultShaders() {&#10;            // Remove the hardcoded SPIR-V and use file loading instead&#10;            loadDefaultShadersFromFiles();&#10;        }&#10;&#10;        bool createGraphicsPipeline() {&#10;            if (!m_renderer || m_vertexSpirv.empty() || m_fragmentSpirv.empty()) {&#10;                return false;&#10;            }&#10;&#10;            PipelineCreateInfo createInfo;&#10;            createInfo.vertexSpirv = m_vertexSpirv;&#10;            createInfo.fragmentSpirv = m_fragmentSpirv;&#10;            createInfo.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;&#10;            createInfo.renderPass = m_window-&gt;defaultRenderPass(); // Use Qt's render pass&#10;            createInfo.swapChainExtent = {&#10;                static_cast&lt;uint32_t&gt;(m_window-&gt;swapChainImageSize().width()),&#10;                static_cast&lt;uint32_t&gt;(m_window-&gt;swapChainImageSize().height())&#10;            };&#10;&#10;            return m_renderer-&gt;createPipeline(createInfo);&#10;        }&#10;    };&#10;&#10;    QVulkanWindowRenderer* QtVulkanWindow::createRenderer() {&#10;        m_renderer = new VulkanWindowRenderer(this);&#10;        return m_renderer;&#10;    }&#10;&#10;    bool QtVulkanWindow::loadShadersFromFiles(const QString&amp; vertexShaderPath, const QString&amp; fragmentShaderPath) {&#10;        // Use the existing ShaderLoader infrastructure&#10;        auto compiler = ShaderLoader::createDefaultCompiler();&#10;        ShaderLoader::ShaderLoader loader(std::move(compiler));&#10;&#10;        // Load vertex shader&#10;        if (!loader.loadShader(vertexShaderPath.toStdString())) {&#10;            return false;&#10;        }&#10;        auto* vertexModule = loader.getModule(vertexShaderPath.toStdString());&#10;        if (!vertexModule || vertexModule-&gt;spirv.empty()) {&#10;            return false;&#10;        }&#10;&#10;        // Load fragment shader&#10;        if (!loader.loadShader(fragmentShaderPath.toStdString())) {&#10;            return false;&#10;        }&#10;        auto* fragmentModule = loader.getModule(fragmentShaderPath.toStdString());&#10;        if (!fragmentModule || fragmentModule-&gt;spirv.empty()) {&#10;            return false;&#10;        }&#10;&#10;        // Load shaders into the renderer&#10;        if (m_renderer) {&#10;            auto* vulkanRenderer = static_cast&lt;VulkanWindowRenderer*&gt;(m_renderer);&#10;            return vulkanRenderer-&gt;loadShaders(vertexModule-&gt;spirv, fragmentModule-&gt;spirv);&#10;        }&#10;&#10;        return true; // Will be loaded when renderer is created&#10;    }&#10;&#10;} // namespace VulkanCore" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/VulkanCore/Private/VulkanContext.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/VulkanCore/Private/VulkanContext.cpp" />
              <option name="originalContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;// src/VulkanCore/Private/VulkanContext.cpp&#10;&#10;// src/VulkanCore/Private/VulkanContext.cpp&#10;&#10;#include &quot;../Public/IVulkanContext.h&quot;&#10;&#10;#include &lt;vulkan/vulkan.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;memory&gt;&#10;&#10;namespace VulkanCore {&#10;&#10;class VulkanContext : public IVulkanContext {&#10;public:&#10;    VulkanContext() = default;&#10;    ~VulkanContext() override { cleanup(); }&#10;&#10;    bool initialize(const std::string&amp; applicationName) override {&#10;        if (!createInstance(applicationName))      return false;&#10;        if (!pickPhysicalDevice())                  return false;&#10;        if (!createLogicalDevice())                 return false;&#10;        vkGetDeviceQueue(m_device, m_queueFamilyIndex, 0, &amp;m_graphicsQueue);&#10;        return true;&#10;    }&#10;&#10;" />
              <option name="updatedContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;// src/VulkanCore/Private/VulkanContext.cpp&#10;&#10;// src/VulkanCore/Private/VulkanContext.cpp&#10;&#10;#include &quot;../Public/IVulkanContext.h&quot;&#10;&#10;#include &lt;vulkan/vulkan.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;memory&gt;&#10;&#10;namespace VulkanCore {&#10;&#10;class VulkanContext : public IVulkanContext {&#10;public:&#10;    VulkanContext() = default;&#10;    ~VulkanContext() override { cleanup(); }&#10;&#10;    bool initialize(const std::string&amp; applicationName) override {&#10;        if (!createInstance(applicationName))      return false;&#10;        if (!pickPhysicalDevice())                  return false;&#10;        if (!createLogicalDevice())                 return false;&#10;        vkGetDeviceQueue(m_device, m_queueFamilyIndex, 0, &amp;m_graphicsQueue);&#10;        return true;&#10;    }&#10;&#10;    bool initializeWithExistingInstance(VkInstance existingInstance) override {&#10;        m_instance = existingInstance;&#10;        m_ownsInstance = false; // We don't own this instance, so don't destroy it&#10;        if (!pickPhysicalDevice())                  return false;&#10;        if (!createLogicalDevice())                 return false;&#10;        vkGetDeviceQueue(m_device, m_queueFamilyIndex, 0, &amp;m_graphicsQueue);&#10;        return true;&#10;    }&#10;&#10;    void cleanup() override {&#10;        if (m_device != VK_NULL_HANDLE) {&#10;            vkDeviceWaitIdle(m_device);&#10;            vkDestroyDevice(m_device, nullptr);&#10;            m_device = VK_NULL_HANDLE;&#10;        }&#10;        if (m_ownsInstance &amp;&amp; m_instance != VK_NULL_HANDLE) {&#10;            vkDestroyInstance(m_instance, nullptr);&#10;            m_instance = VK_NULL_HANDLE;&#10;        }&#10;    }&#10;&#10;    VkInstance       instance()       const override { return m_instance; }&#10;    VkDevice         device()         const override { return m_device; }&#10;    VkPhysicalDevice physicalDevice() const override { return m_physicalDevice; }&#10;    VkQueue          graphicsQueue()  const override { return m_graphicsQueue; }&#10;    uint32_t         graphicsQueueFamilyIndex() const override { return m_queueFamilyIndex; }&#10;&#10;private:&#10;    VkInstance       m_instance{VK_NULL_HANDLE};&#10;    VkPhysicalDevice m_physicalDevice{VK_NULL_HANDLE};&#10;    VkDevice         m_device{VK_NULL_HANDLE};&#10;    VkQueue          m_graphicsQueue{VK_NULL_HANDLE};&#10;    uint32_t         m_queueFamilyIndex{0};&#10;    bool             m_ownsInstance{true}; // Assume we own the instance by default&#10;&#10;    bool createInstance(const std::string&amp; appName) {&#10;        VkApplicationInfo appInfo{};&#10;        appInfo.sType              = VK_STRUCTURE_TYPE_APPLICATION_INFO;&#10;        appInfo.pApplicationName   = appName.c_str();&#10;        appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);&#10;        appInfo.pEngineName        = &quot;ShaderPlaygroundEngine&quot;;&#10;        appInfo.engineVersion      = VK_MAKE_VERSION(1, 0, 0);&#10;        appInfo.apiVersion         = VK_API_VERSION_1_3;&#10;&#10;        // No platform extensions—Qt will provide surface support itself&#10;        VkInstanceCreateInfo instCI{};&#10;        instCI.sType                   = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;&#10;        instCI.pApplicationInfo        = &amp;appInfo;&#10;        instCI.enabledExtensionCount   = 0;&#10;        instCI.ppEnabledExtensionNames = nullptr;&#10;        instCI.enabledLayerCount       = 0;&#10;        instCI.ppEnabledLayerNames     = nullptr;&#10;&#10;        return vkCreateInstance(&amp;instCI, nullptr, &amp;m_instance) == VK_SUCCESS;&#10;    }&#10;&#10;    bool pickPhysicalDevice() {&#10;        uint32_t count = 0;&#10;        vkEnumeratePhysicalDevices(m_instance, &amp;count, nullptr);&#10;        if (count == 0) return false;&#10;&#10;        std::vector&lt;VkPhysicalDevice&gt; devices(count);&#10;        vkEnumeratePhysicalDevices(m_instance, &amp;count, devices.data());&#10;&#10;        for (auto dev : devices) {&#10;            uint32_t queueCount = 0;&#10;            vkGetPhysicalDeviceQueueFamilyProperties(dev, &amp;queueCount, nullptr);&#10;            std::vector&lt;VkQueueFamilyProperties&gt; families(queueCount);&#10;            vkGetPhysicalDeviceQueueFamilyProperties(dev, &amp;queueCount, families.data());&#10;&#10;            for (uint32_t i = 0; i &lt; queueCount; ++i) {&#10;                if (families[i].queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) {&#10;                    m_physicalDevice    = dev;&#10;                    m_queueFamilyIndex  = i;&#10;                    return true;&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    bool createLogicalDevice() {&#10;        float queuePriority = 1.0f;&#10;        VkDeviceQueueCreateInfo queueCI{};&#10;        queueCI.sType            = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;&#10;        queueCI.queueFamilyIndex = m_queueFamilyIndex;&#10;        queueCI.queueCount       = 1;&#10;        queueCI.pQueuePriorities = &amp;queuePriority;&#10;&#10;        // We still need the swapchain extension for rendering&#10;        const char* deviceExts[] = {&#10;            VK_KHR_SWAPCHAIN_EXTENSION_NAME&#10;        };&#10;&#10;        VkPhysicalDeviceFeatures deviceFeatures{}; // enable as needed&#10;&#10;        VkDeviceCreateInfo devCI{};&#10;        devCI.sType                   = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;&#10;        devCI.queueCreateInfoCount    = 1;&#10;        devCI.pQueueCreateInfos       = &amp;queueCI;&#10;        devCI.enabledExtensionCount   = 1;&#10;        devCI.ppEnabledExtensionNames = deviceExts;&#10;        devCI.pEnabledFeatures        = &amp;deviceFeatures;&#10;&#10;        return vkCreateDevice(m_physicalDevice, &amp;devCI, nullptr, &amp;m_device) == VK_SUCCESS;&#10;    }&#10;};&#10;&#10;std::shared_ptr&lt;IVulkanContext&gt; createVulkanContext() {&#10;    return std::make_shared&lt;VulkanContext&gt;();&#10;}&#10;&#10;} // namespace VulkanCore" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/VulkanCore/Private/VulkanRenderer.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/VulkanCore/Private/VulkanRenderer.cpp" />
              <option name="originalContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;// src/VulkanCore/Private/VulkanRenderer.cpp&#10;&#10;// src/VulkanCore/Private/VulkanRenderer.cpp&#10;&#10;#include &quot;../Public/VulkanRenderer.h&quot;&#10;#include &lt;QVulkanWindow&gt;&#10;#include &lt;QVulkanInstance&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;iostream&gt;&#10;&#10;namespace VulkanCore {&#10;&#10;// Helpers for swapchain setup&#10;static VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector&lt;VkSurfaceFormatKHR&gt;&amp; formats) {&#10;    for (auto&amp; fmt : formats) {&#10;        if (fmt.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp;&#10;            fmt.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)&#10;            return fmt;&#10;    }&#10;    return formats[0];&#10;}&#10;&#10;static VkPresentModeKHR choosePresentMode(const std::vector&lt;VkPresentModeKHR&gt;&amp; modes) {&#10;    for (auto&amp; mode : modes) {&#10;        if (mode == VK_PRESENT_MODE_MAILBOX_KHR)&#10;            return mode;&#10;    }&#10;    return VK_PRESENT_MODE_FIFO_KHR;&#10;}&#10;&#10;static VkExtent2D chooseExtent(const VkSurfaceCapabilitiesKHR&amp; caps, QVulkanWindow* window) {&#10;    if (caps.currentExtent.width != UINT32_MAX)&#10;        return caps.currentExtent;&#10;    // fall back to window size&#10;    return {&#10;        static_cast&lt;uint32_t&gt;(window-&gt;width()),&#10;        static_cast&lt;uint32_t&gt;(window-&gt;height())&#10;    };&#10;}&#10;&#10;// Add this near the top of the file (inside namespace) to decode VkResult:&#10;static const char* vkResultToString(VkResult res) {&#10;    switch (res) {&#10;        case VK_SUCCESS:                        return &quot;VK_SUCCESS&quot;;&#10;        case VK_NOT_READY:                      return &quot;VK_NOT_READY&quot;;&#10;        case VK_TIMEOUT:                        return &quot;VK_TIMEOUT&quot;;&#10;        case VK_EVENT_SET:                      return &quot;VK_EVENT_SET&quot;;&#10;        case VK_EVENT_RESET:                    return &quot;VK_EVENT_RESET&quot;;&#10;        case VK_INCOMPLETE:                     return &quot;VK_INCOMPLETE&quot;;&#10;        case VK_ERROR_OUT_OF_HOST_MEMORY:       return &quot;VK_ERROR_OUT_OF_HOST_MEMORY&quot;;&#10;        case VK_ERROR_OUT_OF_DEVICE_MEMORY:     return &quot;VK_ERROR_OUT_OF_DEVICE_MEMORY&quot;;&#10;        case VK_ERROR_INITIALIZATION_FAILED:    return &quot;VK_ERROR_INITIALIZATION_FAILED&quot;;&#10;        case VK_ERROR_DEVICE_LOST:              return &quot;VK_ERROR_DEVICE_LOST&quot;;&#10;        case VK_ERROR_MEMORY_MAP_FAILED:        return &quot;VK_ERROR_MEMORY_MAP_FAILED&quot;;&#10;        case VK_ERROR_LAYER_NOT_PRESENT:        return &quot;VK_ERROR_LAYER_NOT_PRESENT&quot;;&#10;        case VK_ERROR_EXTENSION_NOT_PRESENT:    return &quot;VK_ERROR_EXTENSION_NOT_PRESENT&quot;;&#10;        case VK_ERROR_FEATURE_NOT_PRESENT:      return &quot;VK_ERROR_FEATURE_NOT_PRESENT&quot;;&#10;        case VK_ERROR_INCOMPATIBLE_DRIVER:      return &quot;VK_ERROR_INCOMPATIBLE_DRIVER&quot;;&#10;        case VK_ERROR_TOO_MANY_OBJECTS:         return &quot;VK_ERROR_TOO_MANY_OBJECTS&quot;;&#10;        case VK_ERROR_FORMAT_NOT_SUPPORTED:     return &quot;VK_ERROR_FORMAT_NOT_SUPPORTED&quot;;&#10;        case VK_ERROR_FRAGMENTED_POOL:          return &quot;VK_ERROR_FRAGMENTED_POOL&quot;;&#10;        case VK_ERROR_OUT_OF_POOL_MEMORY:       return &quot;VK_ERROR_OUT_OF_POOL_MEMORY&quot;;&#10;        case VK_ERROR_INVALID_EXTERNAL_HANDLE:  return &quot;VK_ERROR_INVALID_EXTERNAL_HANDLE&quot;;&#10;        case VK_ERROR_FRAGMENTATION:            return &quot;VK_ERROR_FRAGMENTATION&quot;;&#10;        case VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: return &quot;VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS&quot;;&#10;        case VK_ERROR_SURFACE_LOST_KHR:         return &quot;VK_ERROR_SURFACE_LOST_KHR&quot;;&#10;        case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR: return &quot;VK_ERROR_NATIVE_WINDOW_IN_USE_KHR&quot;;&#10;        case VK_SUBOPTIMAL_KHR:                 return &quot;VK_SUBOPTIMAL_KHR&quot;;&#10;        case VK_ERROR_OUT_OF_DATE_KHR:          return &quot;VK_ERROR_OUT_OF_DATE_KHR&quot;;&#10;        case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR: return &quot;VK_ERROR_INCOMPATIBLE_DISPLAY_KHR&quot;;&#10;        case VK_ERROR_VALIDATION_FAILED_EXT:    return &quot;VK_ERROR_VALIDATION_FAILED_EXT&quot;;&#10;        case VK_ERROR_UNKNOWN:                  return &quot;VK_ERROR_UNKNOWN/VK_ERROR_INVALID_SHADER_NV&quot;;&#10;        case VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: return &quot;VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT&quot;;&#10;        case VK_ERROR_NOT_PERMITTED_EXT:        return &quot;VK_ERROR_NOT_PERMITTED_EXT&quot;;&#10;        case VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT: return &quot;VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT&quot;;&#10;        default:                                return &quot;UNKNOWN_VK_RESULT&quot;;&#10;    }&#10;}&#10;&#10;VulkanRenderer::VulkanRenderer(std::shared_ptr&lt;IVulkanContext&gt; context)&#10;    : m_context(std::move(context))&#10;{}&#10;&#10;VulkanRenderer::~VulkanRenderer() {&#10;    cleanup();&#10;}&#10;&#10;bool VulkanRenderer::initialize(void* nativeWindowHandle) {&#10;    m_window = static_cast&lt;QVulkanWindow*&gt;(nativeWindowHandle);&#10;&#10;    if (!createSurface())        return false;&#10;    if (!createSwapchain())      return false;&#10;    if (!createImageViews())     return false;&#10;    // Don't create render pass here - Qt lifecycle will invalidate it&#10;    // Create it on-demand in createPipeline() instead&#10;    // if (!createRenderPass())     return false;&#10;    if (!createCommandPool())    return false;&#10;    if (!createVertexBuffer())   return false;&#10;    if (!createSyncObjects())    return false;&#10;&#10;    return true;&#10;}&#10;&#10;void VulkanRenderer::cleanup() {&#10;    waitIdle();&#10;&#10;    // Cleanup synchronization objects&#10;    for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;        if (i &lt; m_imageAvailableSemaphores.size()) {&#10;            vkDestroySemaphore(m_context-&gt;device(), m_imageAvailableSemaphores[i], nullptr);&#10;        }&#10;        if (i &lt; m_renderFinishedSemaphores.size()) {&#10;            vkDestroySemaphore(m_context-&gt;device(), m_renderFinishedSemaphores[i], nullptr);&#10;        }&#10;        if (i &lt; m_inFlightFences.size()) {&#10;            vkDestroyFence(m_context-&gt;device(), m_inFlightFences[i], nullptr);&#10;        }&#10;    }&#10;    // Clear so we don't double‐destroy on a second cleanup&#10;    m_imageAvailableSemaphores.clear();&#10;    m_renderFinishedSemaphores.clear();&#10;    m_inFlightFences.clear();&#10;&#10;    // Cleanup pipeline&#10;    destroyPipeline();&#10;&#10;    // Cleanup vertex buffer&#10;    if (m_vertexBuffer != VK_NULL_HANDLE) {&#10;        vkDestroyBuffer(m_context-&gt;device(), m_vertexBuffer, nullptr);&#10;        m_vertexBuffer = VK_NULL_HANDLE;&#10;    }&#10;    if (m_vertexBufferMemory != VK_NULL_HANDLE) {&#10;        vkFreeMemory(m_context-&gt;device(), m_vertexBufferMemory, nullptr);&#10;        m_vertexBufferMemory = VK_NULL_HANDLE;&#10;    }&#10;&#10;    cleanupSwapchain();&#10;&#10;    // Remove manual destroy of a Qt-owned surface:&#10;    m_surface = VK_NULL_HANDLE;&#10;&#10;    if (m_commandPool != VK_NULL_HANDLE) {&#10;        vkDestroyCommandPool(m_context-&gt;device(), m_commandPool, nullptr);&#10;        m_commandPool = VK_NULL_HANDLE;&#10;    }&#10;}&#10;&#10;void VulkanRenderer::drawFrame(const std::function&lt;void(VkCommandBuffer)&gt;&amp; recordCommands) {&#10;    // When using Qt's QVulkanWindow, we need to work within Qt's rendering framework&#10;    // Qt will call our renderer through the QVulkanWindowRenderer interface&#10;    // For now, we'll use a simplified approach that works with Qt's command buffer&#10;&#10;    // Get the device from our context for basic operations&#10;    VkDevice device = m_context-&gt;device();&#10;&#10;    // For Qt integration, the actual command buffer recording should happen&#10;    // in the QVulkanWindowRenderer's startNextFrame method&#10;    // This method serves as a bridge between the two systems&#10;&#10;    // We can still call the recordCommands function, but we need a valid command buffer&#10;    // In a proper Qt integration, this would be provided by Qt's renderer&#10;    if (!m_commandBuffers.empty()) {&#10;        VkCommandBuffer cmd = m_commandBuffers[0]; // Use first available command buffer&#10;&#10;        VkCommandBufferBeginInfo bi{VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};&#10;        bi.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;&#10;        vkBeginCommandBuffer(cmd, &amp;bi);&#10;&#10;        recordCommands(cmd);&#10;&#10;        vkEndCommandBuffer(cmd);&#10;&#10;        // Submit the command buffer&#10;        VkSubmitInfo si{VK_STRUCTURE_TYPE_SUBMIT_INFO};&#10;        si.commandBufferCount = 1;&#10;        si.pCommandBuffers = &amp;cmd;&#10;&#10;        vkQueueSubmit(m_context-&gt;graphicsQueue(), 1, &amp;si, VK_NULL_HANDLE);&#10;        vkQueueWaitIdle(m_context-&gt;graphicsQueue());&#10;    }&#10;}&#10;&#10;void VulkanRenderer::waitIdle() {&#10;    vkDeviceWaitIdle(m_context-&gt;device());&#10;}&#10;&#10;bool VulkanRenderer::createSurface() {&#10;    // Qt manages the surface internally, we can get it through the Vulkan instance&#10;    m_surface = QVulkanInstance::surfaceForWindow(m_window);&#10;    return m_surface != VK_NULL_HANDLE;&#10;}&#10;&#10;bool VulkanRenderer::createSwapchain() {&#10;    VkPhysicalDevice phys = m_context-&gt;physicalDevice();&#10;    VkSurfaceCapabilitiesKHR caps;&#10;    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys, m_surface, &amp;caps);&#10;&#10;    uint32_t fc=0;&#10;    vkGetPhysicalDeviceSurfaceFormatsKHR(phys, m_surface, &amp;fc, nullptr);&#10;    std::vector&lt;VkSurfaceFormatKHR&gt; fmts(fc);&#10;    vkGetPhysicalDeviceSurfaceFormatsKHR(phys, m_surface, &amp;fc, fmts.data());&#10;&#10;    uint32_t pm=0;&#10;    vkGetPhysicalDeviceSurfacePresentModesKHR(phys, m_surface, &amp;pm, nullptr);&#10;    std::vector&lt;VkPresentModeKHR&gt; pms(pm);&#10;    vkGetPhysicalDeviceSurfacePresentModesKHR(phys, m_surface, &amp;pm, pms.data());&#10;&#10;    auto sf = chooseSwapSurfaceFormat(fmts);&#10;    auto pmode = choosePresentMode(pms);&#10;    m_swapchainExtent = chooseExtent(caps, m_window);&#10;&#10;    // Store the swapchain format for consistent use&#10;    m_swapchainImageFormat = sf.format;&#10;&#10;    uint32_t ic = caps.minImageCount + 1;&#10;    if (caps.maxImageCount &gt; 0 &amp;&amp; ic &gt; caps.maxImageCount)&#10;        ic = caps.maxImageCount;&#10;&#10;    VkSwapchainCreateInfoKHR sci{VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR};&#10;    sci.surface            = m_surface;&#10;    sci.minImageCount      = ic;&#10;    sci.imageFormat        = sf.format;&#10;    sci.imageColorSpace    = sf.colorSpace;&#10;    sci.imageExtent        = m_swapchainExtent;&#10;    sci.imageArrayLayers   = 1;&#10;    sci.imageUsage         = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;&#10;    sci.preTransform       = caps.currentTransform;&#10;    sci.compositeAlpha     = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;&#10;    sci.presentMode        = pmode;&#10;    sci.clipped            = VK_TRUE;&#10;    sci.oldSwapchain       = VK_NULL_HANDLE;&#10;&#10;    if (vkCreateSwapchainKHR(m_context-&gt;device(), &amp;sci, nullptr, &amp;m_swapchain) != VK_SUCCESS)&#10;        return false;&#10;&#10;    uint32_t cnt;&#10;    vkGetSwapchainImagesKHR(m_context-&gt;device(), m_swapchain, &amp;cnt, nullptr);&#10;    m_swapchainImages.resize(cnt);&#10;    vkGetSwapchainImagesKHR(m_context-&gt;device(), m_swapchain, &amp;cnt, m_swapchainImages.data());&#10;    return true;&#10;}&#10;&#10;bool VulkanRenderer::createImageViews() {&#10;    m_imageViews.resize(m_swapchainImages.size());&#10;    for (size_t i=0; i&lt;m_swapchainImages.size(); ++i) {&#10;        VkImageViewCreateInfo iv{VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};&#10;        iv.image            = m_swapchainImages[i];&#10;        iv.viewType         = VK_IMAGE_VIEW_TYPE_2D;&#10;        iv.format           = m_swapchainImageFormat; // Use actual swapchain format&#10;        iv.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0,1, 0,1};&#10;        if (vkCreateImageView(m_context-&gt;device(), &amp;iv, nullptr, &amp;m_imageViews[i]) != VK_SUCCESS)&#10;            return false;&#10;    }&#10;    return true;&#10;}&#10;&#10;bool VulkanRenderer::createRenderPass() {&#10;    VkAttachmentDescription ad{};&#10;    ad.format        = m_swapchainImageFormat; // Use actual swapchain format&#10;    ad.samples       = VK_SAMPLE_COUNT_1_BIT;&#10;    ad.loadOp        = VK_ATTACHMENT_LOAD_OP_CLEAR;&#10;    ad.storeOp       = VK_ATTACHMENT_STORE_OP_STORE;&#10;    ad.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;  // Add this&#10;    ad.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; // Add this&#10;    ad.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;&#10;    ad.finalLayout   = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;&#10;&#10;    VkAttachmentReference ar{0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};&#10;&#10;    VkSubpassDescription sp{};&#10;    sp.pipelineBindPoint    = VK_PIPELINE_BIND_POINT_GRAPHICS;&#10;    sp.colorAttachmentCount = 1;&#10;    sp.pColorAttachments    = &amp;ar;&#10;&#10;    // add subpass dependency for layout transitions&#10;    VkSubpassDependency dep{};&#10;    dep.srcSubpass      = VK_SUBPASS_EXTERNAL;&#10;    dep.dstSubpass      = 0;&#10;    dep.srcStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;&#10;    dep.dstStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;&#10;    dep.srcAccessMask   = 0;&#10;    dep.dstAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;&#10;&#10;    VkRenderPassCreateInfo rp{VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO};&#10;    rp.attachmentCount  = 1;&#10;    rp.pAttachments     = &amp;ad;&#10;    rp.subpassCount     = 1;&#10;    rp.pSubpasses       = &amp;sp;&#10;    rp.dependencyCount  = 1;  // This was missing!&#10;    rp.pDependencies    = &amp;dep;&#10;&#10;    VkResult res = vkCreateRenderPass(m_context-&gt;device(), &amp;rp, nullptr, &amp;m_renderPass);&#10;    if (res != VK_SUCCESS) {&#10;        std::cerr &lt;&lt; &quot;Failed to create render pass. VkResult: &quot; &lt;&lt; res &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;    return true;&#10;}&#10;&#10;bool VulkanRenderer::createFramebuffers() {&#10;    m_framebuffers.resize(m_imageViews.size());&#10;    for (size_t i=0; i&lt;m_imageViews.size(); ++i) {&#10;        VkFramebufferCreateInfo fb{VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO};&#10;        fb.renderPass      = m_renderPass;&#10;        fb.attachmentCount = 1;&#10;        fb.pAttachments    = &amp;m_imageViews[i];&#10;        fb.width           = m_swapchainExtent.width;&#10;        fb.height          = m_swapchainExtent.height;&#10;        fb.layers          = 1;&#10;        if (vkCreateFramebuffer(m_context-&gt;device(), &amp;fb, nullptr, &amp;m_framebuffers[i]) != VK_SUCCESS)&#10;            return false;&#10;    }&#10;    return true;&#10;}&#10;&#10;bool VulkanRenderer::createCommandPool() {&#10;    VkCommandPoolCreateInfo cp{VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO};&#10;    cp.flags            = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;&#10;    cp.queueFamilyIndex = m_context-&gt;graphicsQueueFamilyIndex();&#10;    return vkCreateCommandPool(m_context-&gt;device(), &amp;cp, nullptr, &amp;m_commandPool) == VK_SUCCESS;&#10;}&#10;&#10;bool VulkanRenderer::allocateCommandBuffers() {&#10;    m_commandBuffers.resize(m_framebuffers.size());&#10;    VkCommandBufferAllocateInfo abi{VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};&#10;    abi.commandPool        = m_commandPool;&#10;    abi.level              = VK_COMMAND_BUFFER_LEVEL_PRIMARY;&#10;    abi.commandBufferCount = static_cast&lt;uint32_t&gt;(m_commandBuffers.size());&#10;    return vkAllocateCommandBuffers(m_context-&gt;device(), &amp;abi, m_commandBuffers.data()) == VK_SUCCESS;&#10;}&#10;&#10;void VulkanRenderer::cleanupSwapchain() {&#10;    // destroy graphics pipeline first (it references the old render-pass)&#10;    destroyPipeline();&#10;&#10;    for (auto&amp; fb : m_framebuffers) vkDestroyFramebuffer(m_context-&gt;device(), fb, nullptr);&#10;    m_framebuffers.clear();&#10;    if (m_renderPass != VK_NULL_HANDLE) {&#10;        vkDestroyRenderPass(m_context-&gt;device(), m_renderPass, nullptr);&#10;        m_renderPass = VK_NULL_HANDLE;&#10;    }&#10;    for (auto&amp; iv : m_imageViews) vkDestroyImageView(m_context-&gt;device(), iv, nullptr);&#10;    m_imageViews.clear();&#10;    if (m_swapchain != VK_NULL_HANDLE) {&#10;        vkDestroySwapchainKHR(m_context-&gt;device(), m_swapchain, nullptr);&#10;        m_swapchain = VK_NULL_HANDLE;&#10;    }&#10;}&#10;&#10;bool VulkanRenderer::createPipeline(const PipelineCreateInfo&amp; createInfo) {&#10;    VkRenderPass renderPassToUse = createInfo.renderPass;&#10;    VkExtent2D extentToUse = createInfo.swapChainExtent;&#10;&#10;    // If no external render pass provided, create our own (fallback behavior)&#10;    if (renderPassToUse == VK_NULL_HANDLE) {&#10;        if (m_renderPass == VK_NULL_HANDLE) {&#10;            std::cerr &lt;&lt; &quot;Render pass is NULL in createPipeline, creating it now…&quot; &lt;&lt; std::endl;&#10;            if (!createRenderPass()) {&#10;                std::cerr &lt;&lt; &quot;Failed to create render pass in createPipeline().&quot; &lt;&lt; std::endl;&#10;                return false;&#10;            }&#10;        }&#10;        renderPassToUse = m_renderPass;&#10;        extentToUse = m_swapchainExtent;&#10;&#10;        // Ensure we have framebuffers (they depend on render pass)&#10;        if (m_framebuffers.empty()) {&#10;            std::cerr &lt;&lt; &quot;Framebuffers are empty, creating them now...&quot; &lt;&lt; std::endl;&#10;            if (!createFramebuffers()) {&#10;                std::cerr &lt;&lt; &quot;Failed to create framebuffers in createPipeline().&quot; &lt;&lt; std::endl;&#10;                return false;&#10;            }&#10;        }&#10;&#10;        // Ensure we have command buffers (they depend on framebuffers)&#10;        if (m_commandBuffers.empty()) {&#10;            std::cerr &lt;&lt; &quot;Command buffers are empty, creating them now...&quot; &lt;&lt; std::endl;&#10;            if (!allocateCommandBuffers()) {&#10;                std::cerr &lt;&lt; &quot;Failed to allocate command buffers in createPipeline().&quot; &lt;&lt; std::endl;&#10;                return false;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Destroy existing pipeline if it exists&#10;    destroyPipeline();&#10;&#10;    // Create shader modules&#10;    VkShaderModule vertexShaderModule = createShaderModule(createInfo.vertexSpirv);&#10;    VkShaderModule fragmentShaderModule = createShaderModule(createInfo.fragmentSpirv);&#10;&#10;    if (vertexShaderModule == VK_NULL_HANDLE || fragmentShaderModule == VK_NULL_HANDLE) {&#10;        if (vertexShaderModule != VK_NULL_HANDLE) vkDestroyShaderModule(m_context-&gt;device(), vertexShaderModule, nullptr);&#10;        if (fragmentShaderModule != VK_NULL_HANDLE) vkDestroyShaderModule(m_context-&gt;device(), fragmentShaderModule, nullptr);&#10;        std::cerr &lt;&lt; &quot;Failed to create shader modules.&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    // Shader stage creation&#10;    VkPipelineShaderStageCreateInfo vertShaderStageInfo{};&#10;    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;&#10;    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;&#10;    vertShaderStageInfo.module = vertexShaderModule;&#10;    vertShaderStageInfo.pName = &quot;main&quot;;&#10;&#10;    VkPipelineShaderStageCreateInfo fragShaderStageInfo{};&#10;    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;&#10;    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;&#10;    fragShaderStageInfo.module = fragmentShaderModule;&#10;    fragShaderStageInfo.pName = &quot;main&quot;;&#10;&#10;    VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};&#10;&#10;    // Vertex input (empty for simple triangle with hardcoded vertices)&#10;    VkPipelineVertexInputStateCreateInfo vertexInputInfo{};&#10;    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;&#10;    vertexInputInfo.vertexBindingDescriptionCount = 0;&#10;    vertexInputInfo.vertexAttributeDescriptionCount = 0;&#10;&#10;    // Input assembly&#10;    VkPipelineInputAssemblyStateCreateInfo inputAssembly{};&#10;    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;&#10;    inputAssembly.topology = createInfo.topology;&#10;    inputAssembly.primitiveRestartEnable = VK_FALSE;&#10;&#10;    // Use the provided extent instead of m_swapchainExtent&#10;    VkViewport viewport{};&#10;    viewport.x = 0.0f;&#10;    viewport.y = 0.0f;&#10;    viewport.width = (float)extentToUse.width;&#10;    viewport.height = (float)extentToUse.height;&#10;    viewport.minDepth = 0.0f;&#10;    viewport.maxDepth = 1.0f;&#10;&#10;    VkRect2D scissor{};&#10;    scissor.offset = {0, 0};&#10;    scissor.extent = extentToUse;&#10;&#10;    VkPipelineViewportStateCreateInfo viewportState{};&#10;    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;&#10;    viewportState.viewportCount = 1;&#10;    viewportState.pViewports = &amp;viewport;&#10;    viewportState.scissorCount = 1;&#10;    viewportState.pScissors = &amp;scissor;&#10;&#10;    // Rasterizer&#10;    VkPipelineRasterizationStateCreateInfo rasterizer{};&#10;    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;&#10;    rasterizer.depthClampEnable = VK_FALSE;&#10;    rasterizer.rasterizerDiscardEnable = VK_FALSE;&#10;    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;&#10;    rasterizer.lineWidth = 1.0f;&#10;    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;&#10;    rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;&#10;    rasterizer.depthBiasEnable = VK_FALSE;&#10;&#10;    // Multisampling&#10;    VkPipelineMultisampleStateCreateInfo multisampling{};&#10;    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;&#10;    multisampling.sampleShadingEnable = VK_FALSE;&#10;    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;&#10;&#10;    // Color blending&#10;    VkPipelineColorBlendAttachmentState colorBlendAttachment{};&#10;    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;&#10;    colorBlendAttachment.blendEnable = VK_FALSE;&#10;&#10;    VkPipelineColorBlendStateCreateInfo colorBlending{};&#10;    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;&#10;    colorBlending.logicOpEnable = VK_FALSE;&#10;    colorBlending.logicOp = VK_LOGIC_OP_COPY;&#10;    colorBlending.attachmentCount = 1;&#10;    colorBlending.pAttachments = &amp;colorBlendAttachment;&#10;&#10;    // Add dynamic state for viewport and scissor&#10;    VkDynamicState dynamicStates[] = {&#10;        VK_DYNAMIC_STATE_VIEWPORT,&#10;        VK_DYNAMIC_STATE_SCISSOR&#10;    };&#10;&#10;    VkPipelineDynamicStateCreateInfo dynamicState{};&#10;    dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;&#10;    dynamicState.dynamicStateCount = 2;&#10;    dynamicState.pDynamicStates = dynamicStates;&#10;&#10;    // Add depth/stencil state (even though we're not using depth)&#10;    VkPipelineDepthStencilStateCreateInfo depthStencil{};&#10;    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;&#10;    depthStencil.depthTestEnable = VK_FALSE;&#10;    depthStencil.depthWriteEnable = VK_FALSE;&#10;    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;&#10;    depthStencil.depthBoundsTestEnable = VK_FALSE;&#10;    depthStencil.stencilTestEnable = VK_FALSE;&#10;&#10;    // Pipeline layout&#10;    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};&#10;    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;&#10;    pipelineLayoutInfo.setLayoutCount = 0; // Explicitly set to 0&#10;    pipelineLayoutInfo.pSetLayouts = nullptr;&#10;    pipelineLayoutInfo.pushConstantRangeCount = 0;&#10;    pipelineLayoutInfo.pPushConstantRanges = nullptr;&#10;&#10;    if (vkCreatePipelineLayout(m_context-&gt;device(), &amp;pipelineLayoutInfo, nullptr, &amp;m_pipelineLayout) != VK_SUCCESS) {&#10;        vkDestroyShaderModule(m_context-&gt;device(), vertexShaderModule, nullptr);&#10;        vkDestroyShaderModule(m_context-&gt;device(), fragmentShaderModule, nullptr);&#10;        std::cerr &lt;&lt; &quot;Failed to create pipeline layout.&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    // Create graphics pipeline using the appropriate render pass&#10;    VkGraphicsPipelineCreateInfo pipelineInfo{};&#10;    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;&#10;    pipelineInfo.stageCount = 2;&#10;    pipelineInfo.pStages = shaderStages;&#10;    pipelineInfo.pVertexInputState = &amp;vertexInputInfo;&#10;    pipelineInfo.pInputAssemblyState = &amp;inputAssembly;&#10;    pipelineInfo.pViewportState = &amp;viewportState;&#10;    pipelineInfo.pRasterizationState = &amp;rasterizer;&#10;    pipelineInfo.pMultisampleState = &amp;multisampling;&#10;    pipelineInfo.pDepthStencilState = &amp;depthStencil;&#10;    pipelineInfo.pColorBlendState = &amp;colorBlending;&#10;    pipelineInfo.pDynamicState = &amp;dynamicState;&#10;    pipelineInfo.layout = m_pipelineLayout;&#10;    pipelineInfo.renderPass = renderPassToUse;  // Use the appropriate render pass&#10;    pipelineInfo.subpass = 0;&#10;    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;&#10;    pipelineInfo.basePipelineIndex = -1;&#10;&#10;    VkResult result = vkCreateGraphicsPipelines(&#10;        m_context-&gt;device(), VK_NULL_HANDLE, 1, &amp;pipelineInfo, nullptr, &amp;m_pipeline);&#10;&#10;    if (result != VK_SUCCESS) {&#10;        std::cerr &lt;&lt; &quot;Failed to create graphics pipeline. VkResult: &quot;&#10;                  &lt;&lt; result &lt;&lt; &quot; (&quot; &lt;&lt; vkResultToString(result) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;&#10;&#10;        // Print detailed error information&#10;        switch (result) {&#10;            case VK_ERROR_OUT_OF_HOST_MEMORY:&#10;                std::cerr &lt;&lt; &quot;Error: VK_ERROR_OUT_OF_HOST_MEMORY&quot; &lt;&lt; std::endl;&#10;                break;&#10;            case VK_ERROR_OUT_OF_DEVICE_MEMORY:&#10;                std::cerr &lt;&lt; &quot;Error: VK_ERROR_OUT_OF_DEVICE_MEMORY&quot; &lt;&lt; std::endl;&#10;                break;&#10;            case VK_ERROR_INVALID_SHADER_NV:&#10;                std::cerr &lt;&lt; &quot;Error: VK_ERROR_INVALID_SHADER_NV –&quot;&#10;                             &quot; invalid SPIR-V shader. Recompile with correct GLSL→SPIR-V flags.&quot;&#10;                          &lt;&lt; std::endl;&#10;                break;&#10;            default:&#10;                std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; vkResultToString(result) &lt;&lt; std::endl;&#10;                break;&#10;        }&#10;&#10;        // Print debug information about pipeline components&#10;        std::cerr &lt;&lt; &quot;Debug info:&quot; &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Device: &quot; &lt;&lt; (m_context-&gt;device() ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Render pass: &quot; &lt;&lt; (m_renderPass != VK_NULL_HANDLE ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Pipeline layout: &quot; &lt;&lt; (m_pipelineLayout != VK_NULL_HANDLE ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Vertex shader module: &quot; &lt;&lt; (vertexShaderModule != VK_NULL_HANDLE ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Fragment shader module: &quot; &lt;&lt; (fragmentShaderModule != VK_NULL_HANDLE ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Swapchain format: &quot; &lt;&lt; m_swapchainImageFormat &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Swapchain extent: &quot; &lt;&lt; m_swapchainExtent.width &lt;&lt; &quot;x&quot; &lt;&lt; m_swapchainExtent.height &lt;&lt; std::endl;&#10;&#10;        vkDestroyShaderModule(m_context-&gt;device(), vertexShaderModule, nullptr);&#10;        vkDestroyShaderModule(m_context-&gt;device(), fragmentShaderModule, nullptr);&#10;        return false;&#10;    }&#10;&#10;    // Clean up shader modules (they're no longer needed after pipeline creation)&#10;    vkDestroyShaderModule(m_context-&gt;device(), vertexShaderModule, nullptr);&#10;    vkDestroyShaderModule(m_context-&gt;device(), fragmentShaderModule, nullptr);&#10;&#10;    return true;&#10;}&#10;&#10;void VulkanRenderer::destroyPipeline() {&#10;    if (m_pipeline != VK_NULL_HANDLE) {&#10;        vkDestroyPipeline(m_context-&gt;device(), m_pipeline, nullptr);&#10;        m_pipeline = VK_NULL_HANDLE;&#10;    }&#10;    if (m_pipelineLayout != VK_NULL_HANDLE) {&#10;        vkDestroyPipelineLayout(m_context-&gt;device(), m_pipelineLayout, nullptr);&#10;        m_pipelineLayout = VK_NULL_HANDLE;&#10;    }&#10;}&#10;&#10;bool VulkanRenderer::createVertexBuffer() {&#10;    // Simple triangle vertices (position only, colors in shader)&#10;    const float vertices[] = {&#10;        0.0f, -0.5f,  // Top vertex&#10;        0.5f,  0.5f,  // Bottom right&#10;        -0.5f, 0.5f   // Bottom left&#10;    };&#10;&#10;    VkDeviceSize bufferSize = sizeof(vertices);&#10;&#10;    VkBufferCreateInfo bufferInfo{};&#10;    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;&#10;    bufferInfo.size = bufferSize;&#10;    bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;&#10;    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;&#10;&#10;    if (vkCreateBuffer(m_context-&gt;device(), &amp;bufferInfo, nullptr, &amp;m_vertexBuffer) != VK_SUCCESS) {&#10;        return false;&#10;    }&#10;&#10;    VkMemoryRequirements memRequirements;&#10;    vkGetBufferMemoryRequirements(m_context-&gt;device(), m_vertexBuffer, &amp;memRequirements);&#10;&#10;    VkMemoryAllocateInfo allocInfo{};&#10;    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;&#10;    allocInfo.allocationSize = memRequirements.size;&#10;    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits,&#10;        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);&#10;&#10;    if (vkAllocateMemory(m_context-&gt;device(), &amp;allocInfo, nullptr, &amp;m_vertexBufferMemory) != VK_SUCCESS) {&#10;        return false;&#10;    }&#10;&#10;    vkBindBufferMemory(m_context-&gt;device(), m_vertexBuffer, m_vertexBufferMemory, 0);&#10;&#10;    // Copy vertex data&#10;    void* data;&#10;    vkMapMemory(m_context-&gt;device(), m_vertexBufferMemory, 0, bufferSize, 0, &amp;data);&#10;    memcpy(data, vertices, (size_t) bufferSize);&#10;    vkUnmapMemory(m_context-&gt;device(), m_vertexBufferMemory);&#10;&#10;    return true;&#10;}&#10;&#10;VkShaderModule VulkanRenderer::createShaderModule(const std::vector&lt;uint32_t&gt;&amp; code) {&#10;    // Validate SPIR-V data before creating the module&#10;    if (code.empty()) {&#10;        std::cerr &lt;&lt; &quot;Error: SPIR-V code is empty!&quot; &lt;&lt; std::endl;&#10;        return VK_NULL_HANDLE;&#10;    }&#10;&#10;    // Check SPIR-V magic number&#10;    if (code[0] != 0x07230203) {&#10;        std::cerr &lt;&lt; &quot;Error: Invalid SPIR-V magic number. Expected: 0x07230203, got: 0x&quot;&#10;                  &lt;&lt; std::hex &lt;&lt; code[0] &lt;&lt; std::dec &lt;&lt; std::endl;&#10;        return VK_NULL_HANDLE;&#10;    }&#10;&#10;    // Check minimum size (header is at least 5 words)&#10;    if (code.size() &lt; 5) {&#10;        std::cerr &lt;&lt; &quot;Error: SPIR-V code too small. Size: &quot; &lt;&lt; code.size() &lt;&lt; &quot; words, minimum: 5&quot; &lt;&lt; std::endl;&#10;        return VK_NULL_HANDLE;&#10;    }&#10;&#10;    // Print SPIR-V header information for debugging&#10;    std::cout &lt;&lt; &quot;SPIR-V Debug Info:&quot; &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Magic number: 0x&quot; &lt;&lt; std::hex &lt;&lt; code[0] &lt;&lt; std::dec &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Version: &quot; &lt;&lt; code[1] &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Generator: 0x&quot; &lt;&lt; std::hex &lt;&lt; code[2] &lt;&lt; std::dec &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Bound: &quot; &lt;&lt; code[3] &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Schema: &quot; &lt;&lt; code[4] &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Total size: &quot; &lt;&lt; code.size() &lt;&lt; &quot; words (&quot; &lt;&lt; (code.size() * 4) &lt;&lt; &quot; bytes)&quot; &lt;&lt; std::endl;&#10;&#10;    VkShaderModuleCreateInfo createInfo{};&#10;    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;&#10;    createInfo.codeSize = code.size() * sizeof(uint32_t);&#10;    createInfo.pCode = code.data();&#10;&#10;    VkShaderModule shaderModule;&#10;    VkResult result = vkCreateShaderModule(m_context-&gt;device(), &amp;createInfo, nullptr, &amp;shaderModule);&#10;&#10;    if (result != VK_SUCCESS) {&#10;        std::cerr &lt;&lt; &quot;Failed to create shader module. VkResult: &quot; &lt;&lt; result&#10;                  &lt;&lt; &quot; (&quot; &lt;&lt; vkResultToString(result) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;Code size: &quot; &lt;&lt; createInfo.codeSize &lt;&lt; &quot; bytes.&quot; &lt;&lt; std::endl;&#10;        return VK_NULL_HANDLE;&#10;    }&#10;&#10;    std::cout &lt;&lt; &quot;Successfully created shader module&quot; &lt;&lt; std::endl;&#10;    return shaderModule;&#10;}&#10;&#10;uint32_t VulkanRenderer::findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {&#10;    VkPhysicalDeviceMemoryProperties memProperties;&#10;    vkGetPhysicalDeviceMemoryProperties(m_context-&gt;physicalDevice(), &amp;memProperties);&#10;&#10;    for (uint32_t i = 0; i &lt; memProperties.memoryTypeCount; i++) {&#10;        if ((typeFilter &amp; (1 &lt;&lt; i)) &amp;&amp; (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) {&#10;            return i;&#10;        }&#10;    }&#10;&#10;    throw std::runtime_error(&quot;failed to find suitable memory type!&quot;);&#10;}&#10;&#10;bool VulkanRenderer::createSyncObjects() {&#10;    VkDevice device = m_context-&gt;device();&#10;&#10;    m_imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);&#10;    m_renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);&#10;    m_inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);&#10;&#10;    VkSemaphoreCreateInfo semaphoreInfo{};&#10;    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;&#10;&#10;    VkFenceCreateInfo fenceInfo{};&#10;    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;&#10;    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT; // Start signaled&#10;&#10;    for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;        if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;m_imageAvailableSemaphores[i]) != VK_SUCCESS ||&#10;            vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;m_renderFinishedSemaphores[i]) != VK_SUCCESS ||&#10;            vkCreateFence(device, &amp;fenceInfo, nullptr, &amp;m_inFlightFences[i]) != VK_SUCCESS) {&#10;            std::cerr &lt;&lt; &quot;Failed to create synchronization objects for frame &quot; &lt;&lt; i &lt;&lt; std::endl;&#10;            return false;&#10;        }&#10;    }&#10;&#10;    return true;&#10;}&#10;&#10;void VulkanRenderer::recordCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex) {&#10;    // Begin command buffer recording&#10;    VkCommandBufferBeginInfo beginInfo{};&#10;    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;&#10;    beginInfo.flags = 0; // Optional&#10;    beginInfo.pInheritanceInfo = nullptr; // Optional&#10;&#10;    if (vkBeginCommandBuffer(commandBuffer, &amp;beginInfo) != VK_SUCCESS) {&#10;        throw std::runtime_error(&quot;failed to begin recording command buffer!&quot;);&#10;    }&#10;&#10;    // Ensure imageIndex is valid&#10;    if (imageIndex &gt;= m_framebuffers.size()) {&#10;        std::cerr &lt;&lt; &quot;Warning: imageIndex &quot; &lt;&lt; imageIndex &lt;&lt; &quot; &gt;= framebuffer count &quot; &lt;&lt; m_framebuffers.size() &lt;&lt; std::endl;&#10;        imageIndex = 0; // Fallback to first framebuffer&#10;    }&#10;&#10;    // Begin render pass&#10;    VkRenderPassBeginInfo renderPassInfo{};&#10;    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;&#10;    renderPassInfo.renderPass = m_renderPass;&#10;    renderPassInfo.framebuffer = m_framebuffers[imageIndex];&#10;    renderPassInfo.renderArea.offset = {0, 0};&#10;    renderPassInfo.renderArea.extent = m_swapchainExtent;&#10;&#10;    VkClearValue clearColor = {{{0.0f, 0.0f, 0.0f, 1.0f}}};&#10;    renderPassInfo.clearValueCount = 1;&#10;    renderPassInfo.pClearValues = &amp;clearColor;&#10;&#10;    vkCmdBeginRenderPass(commandBuffer, &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);&#10;&#10;    // Only bind pipeline and draw if we have a valid pipeline&#10;    if (m_pipeline != VK_NULL_HANDLE) {&#10;        // Bind graphics pipeline&#10;        vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline);&#10;&#10;        // Set viewport and scissor dynamically (good practice)&#10;        VkViewport viewport{};&#10;        viewport.x = 0.0f;&#10;        viewport.y = 0.0f;&#10;        viewport.width = static_cast&lt;float&gt;(m_swapchainExtent.width);&#10;        viewport.height = static_cast&lt;float&gt;(m_swapchainExtent.height);&#10;        viewport.minDepth = 0.0f;&#10;        viewport.maxDepth = 1.0f;&#10;        vkCmdSetViewport(commandBuffer, 0, 1, &amp;viewport);&#10;&#10;        VkRect2D scissor{};&#10;        scissor.offset = {0, 0};&#10;        scissor.extent = m_swapchainExtent;&#10;        vkCmdSetScissor(commandBuffer, 0, 1, &amp;scissor);&#10;&#10;        // Draw the triangle (3 vertices, no vertex buffer needed as vertices are hardcoded in shader)&#10;        vkCmdDraw(commandBuffer, 3, 1, 0, 0);&#10;    }&#10;&#10;    // End render pass&#10;    vkCmdEndRenderPass(commandBuffer);&#10;&#10;    // End command buffer recording&#10;    if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {&#10;        throw std::runtime_error(&quot;failed to record command buffer!&quot;);&#10;    }&#10;}&#10;&#10;} // namespace VulkanCore&#10;" />
              <option name="updatedContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;// src/VulkanCore/Private/VulkanRenderer.cpp&#10;&#10;// src/VulkanCore/Private/VulkanRenderer.cpp&#10;&#10;#include &quot;../Public/VulkanRenderer.h&quot;&#10;#include &lt;QVulkanWindow&gt;&#10;#include &lt;QVulkanInstance&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;iostream&gt;&#10;&#10;namespace VulkanCore {&#10;&#10;// Helpers for swapchain setup&#10;static VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector&lt;VkSurfaceFormatKHR&gt;&amp; formats) {&#10;    for (auto&amp; fmt : formats) {&#10;        if (fmt.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp;&#10;            fmt.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)&#10;            return fmt;&#10;    }&#10;    return formats[0];&#10;}&#10;&#10;static VkPresentModeKHR choosePresentMode(const std::vector&lt;VkPresentModeKHR&gt;&amp; modes) {&#10;    for (auto&amp; mode : modes) {&#10;        if (mode == VK_PRESENT_MODE_MAILBOX_KHR)&#10;            return mode;&#10;    }&#10;    return VK_PRESENT_MODE_FIFO_KHR;&#10;}&#10;&#10;static VkExtent2D chooseExtent(const VkSurfaceCapabilitiesKHR&amp; caps, QVulkanWindow* window) {&#10;    if (caps.currentExtent.width != UINT32_MAX)&#10;        return caps.currentExtent;&#10;    // fall back to window size&#10;    return {&#10;        static_cast&lt;uint32_t&gt;(window-&gt;width()),&#10;        static_cast&lt;uint32_t&gt;(window-&gt;height())&#10;    };&#10;}&#10;&#10;// Add this near the top of the file (inside namespace) to decode VkResult:&#10;static const char* vkResultToString(VkResult res) {&#10;    switch (res) {&#10;        case VK_SUCCESS:                        return &quot;VK_SUCCESS&quot;;&#10;        case VK_NOT_READY:                      return &quot;VK_NOT_READY&quot;;&#10;        case VK_TIMEOUT:                        return &quot;VK_TIMEOUT&quot;;&#10;        case VK_EVENT_SET:                      return &quot;VK_EVENT_SET&quot;;&#10;        case VK_EVENT_RESET:                    return &quot;VK_EVENT_RESET&quot;;&#10;        case VK_INCOMPLETE:                     return &quot;VK_INCOMPLETE&quot;;&#10;        case VK_ERROR_OUT_OF_HOST_MEMORY:       return &quot;VK_ERROR_OUT_OF_HOST_MEMORY&quot;;&#10;        case VK_ERROR_OUT_OF_DEVICE_MEMORY:     return &quot;VK_ERROR_OUT_OF_DEVICE_MEMORY&quot;;&#10;        case VK_ERROR_INITIALIZATION_FAILED:    return &quot;VK_ERROR_INITIALIZATION_FAILED&quot;;&#10;        case VK_ERROR_DEVICE_LOST:              return &quot;VK_ERROR_DEVICE_LOST&quot;;&#10;        case VK_ERROR_MEMORY_MAP_FAILED:        return &quot;VK_ERROR_MEMORY_MAP_FAILED&quot;;&#10;        case VK_ERROR_LAYER_NOT_PRESENT:        return &quot;VK_ERROR_LAYER_NOT_PRESENT&quot;;&#10;        case VK_ERROR_EXTENSION_NOT_PRESENT:    return &quot;VK_ERROR_EXTENSION_NOT_PRESENT&quot;;&#10;        case VK_ERROR_FEATURE_NOT_PRESENT:      return &quot;VK_ERROR_FEATURE_NOT_PRESENT&quot;;&#10;        case VK_ERROR_INCOMPATIBLE_DRIVER:      return &quot;VK_ERROR_INCOMPATIBLE_DRIVER&quot;;&#10;        case VK_ERROR_TOO_MANY_OBJECTS:         return &quot;VK_ERROR_TOO_MANY_OBJECTS&quot;;&#10;        case VK_ERROR_FORMAT_NOT_SUPPORTED:     return &quot;VK_ERROR_FORMAT_NOT_SUPPORTED&quot;;&#10;        case VK_ERROR_FRAGMENTED_POOL:          return &quot;VK_ERROR_FRAGMENTED_POOL&quot;;&#10;        case VK_ERROR_OUT_OF_POOL_MEMORY:       return &quot;VK_ERROR_OUT_OF_POOL_MEMORY&quot;;&#10;        case VK_ERROR_INVALID_EXTERNAL_HANDLE:  return &quot;VK_ERROR_INVALID_EXTERNAL_HANDLE&quot;;&#10;        case VK_ERROR_FRAGMENTATION:            return &quot;VK_ERROR_FRAGMENTATION&quot;;&#10;        case VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: return &quot;VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS&quot;;&#10;        case VK_ERROR_SURFACE_LOST_KHR:         return &quot;VK_ERROR_SURFACE_LOST_KHR&quot;;&#10;        case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR: return &quot;VK_ERROR_NATIVE_WINDOW_IN_USE_KHR&quot;;&#10;        case VK_SUBOPTIMAL_KHR:                 return &quot;VK_SUBOPTIMAL_KHR&quot;;&#10;        case VK_ERROR_OUT_OF_DATE_KHR:          return &quot;VK_ERROR_OUT_OF_DATE_KHR&quot;;&#10;        case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR: return &quot;VK_ERROR_INCOMPATIBLE_DISPLAY_KHR&quot;;&#10;        case VK_ERROR_VALIDATION_FAILED_EXT:    return &quot;VK_ERROR_VALIDATION_FAILED_EXT&quot;;&#10;        case VK_ERROR_UNKNOWN:                  return &quot;VK_ERROR_UNKNOWN/VK_ERROR_INVALID_SHADER_NV&quot;;&#10;        case VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: return &quot;VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT&quot;;&#10;        case VK_ERROR_NOT_PERMITTED_EXT:        return &quot;VK_ERROR_NOT_PERMITTED_EXT&quot;;&#10;        case VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT: return &quot;VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT&quot;;&#10;        default:                                return &quot;UNKNOWN_VK_RESULT&quot;;&#10;    }&#10;}&#10;&#10;VulkanRenderer::VulkanRenderer(std::shared_ptr&lt;IVulkanContext&gt; context)&#10;    : m_context(std::move(context))&#10;{}&#10;&#10;VulkanRenderer::~VulkanRenderer() {&#10;    cleanup();&#10;}&#10;&#10;bool VulkanRenderer::initialize(void* nativeWindowHandle) {&#10;    m_window = static_cast&lt;QVulkanWindow*&gt;(nativeWindowHandle);&#10;&#10;    if (!createSurface())        return false;&#10;    if (!createSwapchain())      return false;&#10;    if (!createImageViews())     return false;&#10;    // Don't create render pass here - Qt lifecycle will invalidate it&#10;    // Create it on-demand in createPipeline() instead&#10;    // if (!createRenderPass())     return false;&#10;    if (!createCommandPool())    return false;&#10;    if (!createVertexBuffer())   return false;&#10;    if (!createSyncObjects())    return false;&#10;&#10;    return true;&#10;}&#10;&#10;void VulkanRenderer::cleanup() {&#10;    waitIdle();&#10;&#10;    // Cleanup synchronization objects&#10;    for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;        if (i &lt; m_imageAvailableSemaphores.size()) {&#10;            vkDestroySemaphore(m_context-&gt;device(), m_imageAvailableSemaphores[i], nullptr);&#10;        }&#10;        if (i &lt; m_renderFinishedSemaphores.size()) {&#10;            vkDestroySemaphore(m_context-&gt;device(), m_renderFinishedSemaphores[i], nullptr);&#10;        }&#10;        if (i &lt; m_inFlightFences.size()) {&#10;            vkDestroyFence(m_context-&gt;device(), m_inFlightFences[i], nullptr);&#10;        }&#10;    }&#10;    // Clear so we don't double‐destroy on a second cleanup&#10;    m_imageAvailableSemaphores.clear();&#10;    m_renderFinishedSemaphores.clear();&#10;    m_inFlightFences.clear();&#10;&#10;    // Cleanup pipeline&#10;    destroyPipeline();&#10;&#10;    // Cleanup vertex buffer&#10;    if (m_vertexBuffer != VK_NULL_HANDLE) {&#10;        vkDestroyBuffer(m_context-&gt;device(), m_vertexBuffer, nullptr);&#10;        m_vertexBuffer = VK_NULL_HANDLE;&#10;    }&#10;    if (m_vertexBufferMemory != VK_NULL_HANDLE) {&#10;        vkFreeMemory(m_context-&gt;device(), m_vertexBufferMemory, nullptr);&#10;        m_vertexBufferMemory = VK_NULL_HANDLE;&#10;    }&#10;&#10;    cleanupSwapchain();&#10;&#10;    // Remove manual destroy of a Qt-owned surface:&#10;    m_surface = VK_NULL_HANDLE;&#10;&#10;    if (m_commandPool != VK_NULL_HANDLE) {&#10;        vkDestroyCommandPool(m_context-&gt;device(), m_commandPool, nullptr);&#10;        m_commandPool = VK_NULL_HANDLE;&#10;    }&#10;}&#10;&#10;void VulkanRenderer::drawFrame(const std::function&lt;void(VkCommandBuffer)&gt;&amp; recordCommands) {&#10;    // When using Qt's QVulkanWindow, we need to work within Qt's rendering framework&#10;    // Qt will call our renderer through the QVulkanWindowRenderer interface&#10;    // For now, we'll use a simplified approach that works with Qt's command buffer&#10;&#10;    // Get the device from our context for basic operations&#10;    VkDevice device = m_context-&gt;device();&#10;&#10;    // For Qt integration, the actual command buffer recording should happen&#10;    // in the QVulkanWindowRenderer's startNextFrame method&#10;    // This method serves as a bridge between the two systems&#10;&#10;    // We can still call the recordCommands function, but we need a valid command buffer&#10;    // In a proper Qt integration, this would be provided by Qt's renderer&#10;    if (!m_commandBuffers.empty()) {&#10;        VkCommandBuffer cmd = m_commandBuffers[0]; // Use first available command buffer&#10;&#10;        VkCommandBufferBeginInfo bi{VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};&#10;        bi.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;&#10;        vkBeginCommandBuffer(cmd, &amp;bi);&#10;&#10;        recordCommands(cmd);&#10;&#10;        vkEndCommandBuffer(cmd);&#10;&#10;        // Submit the command buffer&#10;        VkSubmitInfo si{VK_STRUCTURE_TYPE_SUBMIT_INFO};&#10;        si.commandBufferCount = 1;&#10;        si.pCommandBuffers = &amp;cmd;&#10;&#10;        vkQueueSubmit(m_context-&gt;graphicsQueue(), 1, &amp;si, VK_NULL_HANDLE);&#10;        vkQueueWaitIdle(m_context-&gt;graphicsQueue());&#10;    }&#10;}&#10;&#10;void VulkanRenderer::waitIdle() {&#10;    vkDeviceWaitIdle(m_context-&gt;device());&#10;}&#10;&#10;bool VulkanRenderer::createSurface() {&#10;    // Qt manages the surface internally, we can get it through the Vulkan instance&#10;    m_surface = QVulkanInstance::surfaceForWindow(m_window);&#10;    return m_surface != VK_NULL_HANDLE;&#10;}&#10;&#10;bool VulkanRenderer::createSwapchain() {&#10;    VkPhysicalDevice phys = m_context-&gt;physicalDevice();&#10;    VkSurfaceCapabilitiesKHR caps;&#10;    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys, m_surface, &amp;caps);&#10;&#10;    uint32_t fc=0;&#10;    vkGetPhysicalDeviceSurfaceFormatsKHR(phys, m_surface, &amp;fc, nullptr);&#10;    std::vector&lt;VkSurfaceFormatKHR&gt; fmts(fc);&#10;    vkGetPhysicalDeviceSurfaceFormatsKHR(phys, m_surface, &amp;fc, fmts.data());&#10;&#10;    uint32_t pm=0;&#10;    vkGetPhysicalDeviceSurfacePresentModesKHR(phys, m_surface, &amp;pm, nullptr);&#10;    std::vector&lt;VkPresentModeKHR&gt; pms(pm);&#10;    vkGetPhysicalDeviceSurfacePresentModesKHR(phys, m_surface, &amp;pm, pms.data());&#10;&#10;    auto sf = chooseSwapSurfaceFormat(fmts);&#10;    auto pmode = choosePresentMode(pms);&#10;    m_swapchainExtent = chooseExtent(caps, m_window);&#10;&#10;    // Store the swapchain format for consistent use&#10;    m_swapchainImageFormat = sf.format;&#10;&#10;    uint32_t ic = caps.minImageCount + 1;&#10;    if (caps.maxImageCount &gt; 0 &amp;&amp; ic &gt; caps.maxImageCount)&#10;        ic = caps.maxImageCount;&#10;&#10;    VkSwapchainCreateInfoKHR sci{VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR};&#10;    sci.surface            = m_surface;&#10;    sci.minImageCount      = ic;&#10;    sci.imageFormat        = sf.format;&#10;    sci.imageColorSpace    = sf.colorSpace;&#10;    sci.imageExtent        = m_swapchainExtent;&#10;    sci.imageArrayLayers   = 1;&#10;    sci.imageUsage         = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;&#10;    sci.preTransform       = caps.currentTransform;&#10;    sci.compositeAlpha     = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;&#10;    sci.presentMode        = pmode;&#10;    sci.clipped            = VK_TRUE;&#10;    sci.oldSwapchain       = VK_NULL_HANDLE;&#10;&#10;    if (vkCreateSwapchainKHR(m_context-&gt;device(), &amp;sci, nullptr, &amp;m_swapchain) != VK_SUCCESS)&#10;        return false;&#10;&#10;    uint32_t cnt;&#10;    vkGetSwapchainImagesKHR(m_context-&gt;device(), m_swapchain, &amp;cnt, nullptr);&#10;    m_swapchainImages.resize(cnt);&#10;    vkGetSwapchainImagesKHR(m_context-&gt;device(), m_swapchain, &amp;cnt, m_swapchainImages.data());&#10;    return true;&#10;}&#10;&#10;bool VulkanRenderer::createImageViews() {&#10;    m_imageViews.resize(m_swapchainImages.size());&#10;    for (size_t i=0; i&lt;m_swapchainImages.size(); ++i) {&#10;        VkImageViewCreateInfo iv{VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};&#10;        iv.image            = m_swapchainImages[i];&#10;        iv.viewType         = VK_IMAGE_VIEW_TYPE_2D;&#10;        iv.format           = m_swapchainImageFormat; // Use actual swapchain format&#10;        iv.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0,1, 0,1};&#10;        if (vkCreateImageView(m_context-&gt;device(), &amp;iv, nullptr, &amp;m_imageViews[i]) != VK_SUCCESS)&#10;            return false;&#10;    }&#10;    return true;&#10;}&#10;&#10;bool VulkanRenderer::createRenderPass() {&#10;    VkAttachmentDescription ad{};&#10;    ad.format        = m_swapchainImageFormat; // Use actual swapchain format&#10;    ad.samples       = VK_SAMPLE_COUNT_1_BIT;&#10;    ad.loadOp        = VK_ATTACHMENT_LOAD_OP_CLEAR;&#10;    ad.storeOp       = VK_ATTACHMENT_STORE_OP_STORE;&#10;    ad.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;  // Add this&#10;    ad.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; // Add this&#10;    ad.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;&#10;    ad.finalLayout   = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;&#10;&#10;    VkAttachmentReference ar{0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};&#10;&#10;    VkSubpassDescription sp{};&#10;    sp.pipelineBindPoint    = VK_PIPELINE_BIND_POINT_GRAPHICS;&#10;    sp.colorAttachmentCount = 1;&#10;    sp.pColorAttachments    = &amp;ar;&#10;&#10;    // add subpass dependency for layout transitions&#10;    VkSubpassDependency dep{};&#10;    dep.srcSubpass      = VK_SUBPASS_EXTERNAL;&#10;    dep.dstSubpass      = 0;&#10;    dep.srcStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;&#10;    dep.dstStageMask    = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;&#10;    dep.srcAccessMask   = 0;&#10;    dep.dstAccessMask   = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;&#10;&#10;    VkRenderPassCreateInfo rp{VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO};&#10;    rp.attachmentCount  = 1;&#10;    rp.pAttachments     = &amp;ad;&#10;    rp.subpassCount     = 1;&#10;    rp.pSubpasses       = &amp;sp;&#10;    rp.dependencyCount  = 1;  // This was missing!&#10;    rp.pDependencies    = &amp;dep;&#10;&#10;    VkResult res = vkCreateRenderPass(m_context-&gt;device(), &amp;rp, nullptr, &amp;m_renderPass);&#10;    if (res != VK_SUCCESS) {&#10;        std::cerr &lt;&lt; &quot;Failed to create render pass. VkResult: &quot; &lt;&lt; res &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;    return true;&#10;}&#10;&#10;bool VulkanRenderer::createFramebuffers() {&#10;    m_framebuffers.resize(m_imageViews.size());&#10;    for (size_t i=0; i&lt;m_imageViews.size(); ++i) {&#10;        VkFramebufferCreateInfo fb{VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO};&#10;        fb.renderPass      = m_renderPass;&#10;        fb.attachmentCount = 1;&#10;        fb.pAttachments    = &amp;m_imageViews[i];&#10;        fb.width           = m_swapchainExtent.width;&#10;        fb.height          = m_swapchainExtent.height;&#10;        fb.layers          = 1;&#10;        if (vkCreateFramebuffer(m_context-&gt;device(), &amp;fb, nullptr, &amp;m_framebuffers[i]) != VK_SUCCESS)&#10;            return false;&#10;    }&#10;    return true;&#10;}&#10;&#10;bool VulkanRenderer::createCommandPool() {&#10;    VkCommandPoolCreateInfo cp{VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO};&#10;    cp.flags            = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;&#10;    cp.queueFamilyIndex = m_context-&gt;graphicsQueueFamilyIndex();&#10;    return vkCreateCommandPool(m_context-&gt;device(), &amp;cp, nullptr, &amp;m_commandPool) == VK_SUCCESS;&#10;}&#10;&#10;bool VulkanRenderer::allocateCommandBuffers() {&#10;    m_commandBuffers.resize(m_framebuffers.size());&#10;    VkCommandBufferAllocateInfo abi{VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};&#10;    abi.commandPool        = m_commandPool;&#10;    abi.level              = VK_COMMAND_BUFFER_LEVEL_PRIMARY;&#10;    abi.commandBufferCount = static_cast&lt;uint32_t&gt;(m_commandBuffers.size());&#10;    return vkAllocateCommandBuffers(m_context-&gt;device(), &amp;abi, m_commandBuffers.data()) == VK_SUCCESS;&#10;}&#10;&#10;void VulkanRenderer::cleanupSwapchain() {&#10;    // destroy graphics pipeline first (it references the old render-pass)&#10;    destroyPipeline();&#10;&#10;    for (auto&amp; fb : m_framebuffers) vkDestroyFramebuffer(m_context-&gt;device(), fb, nullptr);&#10;    m_framebuffers.clear();&#10;    if (m_renderPass != VK_NULL_HANDLE) {&#10;        vkDestroyRenderPass(m_context-&gt;device(), m_renderPass, nullptr);&#10;        m_renderPass = VK_NULL_HANDLE;&#10;    }&#10;    for (auto&amp; iv : m_imageViews) vkDestroyImageView(m_context-&gt;device(), iv, nullptr);&#10;    m_imageViews.clear();&#10;    if (m_swapchain != VK_NULL_HANDLE) {&#10;        vkDestroySwapchainKHR(m_context-&gt;device(), m_swapchain, nullptr);&#10;        m_swapchain = VK_NULL_HANDLE;&#10;    }&#10;}&#10;&#10;bool VulkanRenderer::createPipeline(const PipelineCreateInfo&amp; createInfo) {&#10;    VkRenderPass renderPassToUse = createInfo.renderPass;&#10;    VkExtent2D extentToUse = createInfo.swapChainExtent;&#10;    &#10;    // If external render pass provided (Qt integration), use it directly&#10;    if (renderPassToUse != VK_NULL_HANDLE) {&#10;        std::cout &lt;&lt; &quot;Using Qt's render pass for pipeline creation&quot; &lt;&lt; std::endl;&#10;    } else {&#10;        // Fallback to internal render pass creation&#10;        if (m_renderPass == VK_NULL_HANDLE) {&#10;            std::cerr &lt;&lt; &quot;Render pass is NULL in createPipeline, creating it now…&quot; &lt;&lt; std::endl;&#10;            if (!createRenderPass()) {&#10;                std::cerr &lt;&lt; &quot;Failed to create render pass in createPipeline().&quot; &lt;&lt; std::endl;&#10;                return false;&#10;            }&#10;        }&#10;        renderPassToUse = m_renderPass;&#10;        extentToUse = m_swapchainExtent;&#10;&#10;        // Ensure we have framebuffers (they depend on render pass)&#10;        if (m_framebuffers.empty()) {&#10;            std::cerr &lt;&lt; &quot;Framebuffers are empty, creating them now...&quot; &lt;&lt; std::endl;&#10;            if (!createFramebuffers()) {&#10;                std::cerr &lt;&lt; &quot;Failed to create framebuffers in createPipeline().&quot; &lt;&lt; std::endl;&#10;                return false;&#10;            }&#10;        }&#10;&#10;        // Ensure we have command buffers (they depend on framebuffers)&#10;        if (m_commandBuffers.empty()) {&#10;            std::cerr &lt;&lt; &quot;Command buffers are empty, creating them now...&quot; &lt;&lt; std::endl;&#10;            if (!allocateCommandBuffers()) {&#10;                std::cerr &lt;&lt; &quot;Failed to allocate command buffers in createPipeline().&quot; &lt;&lt; std::endl;&#10;                return false;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Destroy existing pipeline if it exists&#10;    destroyPipeline();&#10;&#10;    // Create shader modules&#10;    VkShaderModule vertexShaderModule = createShaderModule(createInfo.vertexSpirv);&#10;    VkShaderModule fragmentShaderModule = createShaderModule(createInfo.fragmentSpirv);&#10;&#10;    if (vertexShaderModule == VK_NULL_HANDLE || fragmentShaderModule == VK_NULL_HANDLE) {&#10;        if (vertexShaderModule != VK_NULL_HANDLE) vkDestroyShaderModule(m_context-&gt;device(), vertexShaderModule, nullptr);&#10;        if (fragmentShaderModule != VK_NULL_HANDLE) vkDestroyShaderModule(m_context-&gt;device(), fragmentShaderModule, nullptr);&#10;        std::cerr &lt;&lt; &quot;Failed to create shader modules.&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    // Shader stage creation&#10;    VkPipelineShaderStageCreateInfo vertShaderStageInfo{};&#10;    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;&#10;    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;&#10;    vertShaderStageInfo.module = vertexShaderModule;&#10;    vertShaderStageInfo.pName = &quot;main&quot;;&#10;&#10;    VkPipelineShaderStageCreateInfo fragShaderStageInfo{};&#10;    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;&#10;    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;&#10;    fragShaderStageInfo.module = fragmentShaderModule;&#10;    fragShaderStageInfo.pName = &quot;main&quot;;&#10;&#10;    VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};&#10;&#10;    // CRITICAL FIX: Vertex input state for hardcoded vertices (no vertex buffers)&#10;    // The shader uses gl_VertexIndex to access hardcoded vertex arrays&#10;    VkPipelineVertexInputStateCreateInfo vertexInputInfo{};&#10;    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;&#10;    vertexInputInfo.vertexBindingDescriptionCount = 0;    // No vertex buffers&#10;    vertexInputInfo.pVertexBindingDescriptions = nullptr;&#10;    vertexInputInfo.vertexAttributeDescriptionCount = 0;  // No vertex attributes&#10;    vertexInputInfo.pVertexAttributeDescriptions = nullptr;&#10;&#10;    // Input assembly&#10;    VkPipelineInputAssemblyStateCreateInfo inputAssembly{};&#10;    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;&#10;    inputAssembly.topology = createInfo.topology;&#10;    inputAssembly.primitiveRestartEnable = VK_FALSE;&#10;&#10;    // Viewport state - use provided extent&#10;    VkViewport viewport{};&#10;    viewport.x = 0.0f;&#10;    viewport.y = 0.0f;&#10;    viewport.width = static_cast&lt;float&gt;(extentToUse.width);&#10;    viewport.height = static_cast&lt;float&gt;(extentToUse.height);&#10;    viewport.minDepth = 0.0f;&#10;    viewport.maxDepth = 1.0f;&#10;&#10;    VkRect2D scissor{};&#10;    scissor.offset = {0, 0};&#10;    scissor.extent = extentToUse;&#10;&#10;    VkPipelineViewportStateCreateInfo viewportState{};&#10;    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;&#10;    viewportState.viewportCount = 1;&#10;    viewportState.pViewports = &amp;viewport;&#10;    viewportState.scissorCount = 1;&#10;    viewportState.pScissors = &amp;scissor;&#10;&#10;    // Rasterizer - match tutorial settings&#10;    VkPipelineRasterizationStateCreateInfo rasterizer{};&#10;    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;&#10;    rasterizer.depthClampEnable = VK_FALSE;&#10;    rasterizer.rasterizerDiscardEnable = VK_FALSE;&#10;    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;&#10;    rasterizer.lineWidth = 1.0f;&#10;    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;&#10;    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE; // IMPORTANT: Match shader winding&#10;    rasterizer.depthBiasEnable = VK_FALSE;&#10;&#10;    // Multisampling&#10;    VkPipelineMultisampleStateCreateInfo multisampling{};&#10;    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;&#10;    multisampling.sampleShadingEnable = VK_FALSE;&#10;    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;&#10;&#10;    // Color blending - enable proper color output&#10;    VkPipelineColorBlendAttachmentState colorBlendAttachment{};&#10;    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | &#10;                                         VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;&#10;    colorBlendAttachment.blendEnable = VK_FALSE;&#10;&#10;    VkPipelineColorBlendStateCreateInfo colorBlending{};&#10;    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;&#10;    colorBlending.logicOpEnable = VK_FALSE;&#10;    colorBlending.logicOp = VK_LOGIC_OP_COPY;&#10;    colorBlending.attachmentCount = 1;&#10;    colorBlending.pAttachments = &amp;colorBlendAttachment;&#10;&#10;    // Dynamic state for viewport and scissor&#10;    VkDynamicState dynamicStates[] = {&#10;        VK_DYNAMIC_STATE_VIEWPORT,&#10;        VK_DYNAMIC_STATE_SCISSOR&#10;    };&#10;&#10;    VkPipelineDynamicStateCreateInfo dynamicState{};&#10;    dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;&#10;    dynamicState.dynamicStateCount = 2;&#10;    dynamicState.pDynamicStates = dynamicStates;&#10;&#10;    // Depth/stencil state&#10;    VkPipelineDepthStencilStateCreateInfo depthStencil{};&#10;    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;&#10;    depthStencil.depthTestEnable = VK_FALSE;&#10;    depthStencil.depthWriteEnable = VK_FALSE;&#10;    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;&#10;    depthStencil.depthBoundsTestEnable = VK_FALSE;&#10;    depthStencil.stencilTestEnable = VK_FALSE;&#10;&#10;    // Pipeline layout&#10;    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};&#10;    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;&#10;    pipelineLayoutInfo.setLayoutCount = 0;&#10;    pipelineLayoutInfo.pSetLayouts = nullptr;&#10;    pipelineLayoutInfo.pushConstantRangeCount = 0;&#10;    pipelineLayoutInfo.pPushConstantRanges = nullptr;&#10;&#10;    if (vkCreatePipelineLayout(m_context-&gt;device(), &amp;pipelineLayoutInfo, nullptr, &amp;m_pipelineLayout) != VK_SUCCESS) {&#10;        vkDestroyShaderModule(m_context-&gt;device(), vertexShaderModule, nullptr);&#10;        vkDestroyShaderModule(m_context-&gt;device(), fragmentShaderModule, nullptr);&#10;        std::cerr &lt;&lt; &quot;Failed to create pipeline layout.&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    // Create graphics pipeline using the appropriate render pass&#10;    VkGraphicsPipelineCreateInfo pipelineInfo{};&#10;    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;&#10;    pipelineInfo.stageCount = 2;&#10;    pipelineInfo.pStages = shaderStages;&#10;    pipelineInfo.pVertexInputState = &amp;vertexInputInfo;&#10;    pipelineInfo.pInputAssemblyState = &amp;inputAssembly;&#10;    pipelineInfo.pViewportState = &amp;viewportState;&#10;    pipelineInfo.pRasterizationState = &amp;rasterizer;&#10;    pipelineInfo.pMultisampleState = &amp;multisampling;&#10;    pipelineInfo.pDepthStencilState = &amp;depthStencil;&#10;    pipelineInfo.pColorBlendState = &amp;colorBlending;&#10;    pipelineInfo.pDynamicState = &amp;dynamicState;&#10;    pipelineInfo.layout = m_pipelineLayout;&#10;    pipelineInfo.renderPass = renderPassToUse;  // Use the appropriate render pass&#10;    pipelineInfo.subpass = 0;&#10;    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;&#10;    pipelineInfo.basePipelineIndex = -1;&#10;&#10;    VkResult result = vkCreateGraphicsPipelines(&#10;        m_context-&gt;device(), VK_NULL_HANDLE, 1, &amp;pipelineInfo, nullptr, &amp;m_pipeline);&#10;&#10;    if (result != VK_SUCCESS) {&#10;        std::cerr &lt;&lt; &quot;Failed to create graphics pipeline. VkResult: &quot;&#10;                  &lt;&lt; result &lt;&lt; &quot; (&quot; &lt;&lt; vkResultToString(result) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;&#10;&#10;        // Print detailed error information&#10;        switch (result) {&#10;            case VK_ERROR_OUT_OF_HOST_MEMORY:&#10;                std::cerr &lt;&lt; &quot;Error: VK_ERROR_OUT_OF_HOST_MEMORY&quot; &lt;&lt; std::endl;&#10;                break;&#10;            case VK_ERROR_OUT_OF_DEVICE_MEMORY:&#10;                std::cerr &lt;&lt; &quot;Error: VK_ERROR_OUT_OF_DEVICE_MEMORY&quot; &lt;&lt; std::endl;&#10;                break;&#10;            case VK_ERROR_INVALID_SHADER_NV:&#10;                std::cerr &lt;&lt; &quot;Error: VK_ERROR_INVALID_SHADER_NV –&quot;&#10;                             &quot; invalid SPIR-V shader. Recompile with correct GLSL→SPIR-V flags.&quot;&#10;                          &lt;&lt; std::endl;&#10;                break;&#10;            default:&#10;                std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; vkResultToString(result) &lt;&lt; std::endl;&#10;                break;&#10;        }&#10;&#10;        // Print debug information about pipeline components&#10;        std::cerr &lt;&lt; &quot;Debug info:&quot; &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Device: &quot; &lt;&lt; (m_context-&gt;device() ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Render pass: &quot; &lt;&lt; (m_renderPass != VK_NULL_HANDLE ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Pipeline layout: &quot; &lt;&lt; (m_pipelineLayout != VK_NULL_HANDLE ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Vertex shader module: &quot; &lt;&lt; (vertexShaderModule != VK_NULL_HANDLE ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Fragment shader module: &quot; &lt;&lt; (fragmentShaderModule != VK_NULL_HANDLE ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Swapchain format: &quot; &lt;&lt; m_swapchainImageFormat &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;  Swapchain extent: &quot; &lt;&lt; m_swapchainExtent.width &lt;&lt; &quot;x&quot; &lt;&lt; m_swapchainExtent.height &lt;&lt; std::endl;&#10;&#10;        vkDestroyShaderModule(m_context-&gt;device(), vertexShaderModule, nullptr);&#10;        vkDestroyShaderModule(m_context-&gt;device(), fragmentShaderModule, nullptr);&#10;        return false;&#10;    }&#10;&#10;    std::cout &lt;&lt; &quot;Successfully created graphics pipeline with render pass: &quot; &#10;              &lt;&lt; (renderPassToUse != VK_NULL_HANDLE ? &quot;Valid&quot; : &quot;NULL&quot;) &lt;&lt; std::endl;&#10;&#10;    // Clean up shader modules&#10;    vkDestroyShaderModule(m_context-&gt;device(), vertexShaderModule, nullptr);&#10;    vkDestroyShaderModule(m_context-&gt;device(), fragmentShaderModule, nullptr);&#10;&#10;    return true;&#10;}&#10;&#10;void VulkanRenderer::destroyPipeline() {&#10;    if (m_pipeline != VK_NULL_HANDLE) {&#10;        vkDestroyPipeline(m_context-&gt;device(), m_pipeline, nullptr);&#10;        m_pipeline = VK_NULL_HANDLE;&#10;    }&#10;    if (m_pipelineLayout != VK_NULL_HANDLE) {&#10;        vkDestroyPipelineLayout(m_context-&gt;device(), m_pipelineLayout, nullptr);&#10;        m_pipelineLayout = VK_NULL_HANDLE;&#10;    }&#10;}&#10;&#10;bool VulkanRenderer::createVertexBuffer() {&#10;    // Simple triangle vertices (position only, colors in shader)&#10;    const float vertices[] = {&#10;        0.0f, -0.5f,  // Top vertex&#10;        0.5f,  0.5f,  // Bottom right&#10;        -0.5f, 0.5f   // Bottom left&#10;    };&#10;&#10;    VkDeviceSize bufferSize = sizeof(vertices);&#10;&#10;    VkBufferCreateInfo bufferInfo{};&#10;    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;&#10;    bufferInfo.size = bufferSize;&#10;    bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;&#10;    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;&#10;&#10;    if (vkCreateBuffer(m_context-&gt;device(), &amp;bufferInfo, nullptr, &amp;m_vertexBuffer) != VK_SUCCESS) {&#10;        return false;&#10;    }&#10;&#10;    VkMemoryRequirements memRequirements;&#10;    vkGetBufferMemoryRequirements(m_context-&gt;device(), m_vertexBuffer, &amp;memRequirements);&#10;&#10;    VkMemoryAllocateInfo allocInfo{};&#10;    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;&#10;    allocInfo.allocationSize = memRequirements.size;&#10;    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits,&#10;        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);&#10;&#10;    if (vkAllocateMemory(m_context-&gt;device(), &amp;allocInfo, nullptr, &amp;m_vertexBufferMemory) != VK_SUCCESS) {&#10;        return false;&#10;    }&#10;&#10;    vkBindBufferMemory(m_context-&gt;device(), m_vertexBuffer, m_vertexBufferMemory, 0);&#10;&#10;    // Copy vertex data&#10;    void* data;&#10;    vkMapMemory(m_context-&gt;device(), m_vertexBufferMemory, 0, bufferSize, 0, &amp;data);&#10;    memcpy(data, vertices, (size_t) bufferSize);&#10;    vkUnmapMemory(m_context-&gt;device(), m_vertexBufferMemory);&#10;&#10;    return true;&#10;}&#10;&#10;VkShaderModule VulkanRenderer::createShaderModule(const std::vector&lt;uint32_t&gt;&amp; code) {&#10;    // Validate SPIR-V data before creating the module&#10;    if (code.empty()) {&#10;        std::cerr &lt;&lt; &quot;Error: SPIR-V code is empty!&quot; &lt;&lt; std::endl;&#10;        return VK_NULL_HANDLE;&#10;    }&#10;&#10;    // Check SPIR-V magic number&#10;    if (code[0] != 0x07230203) {&#10;        std::cerr &lt;&lt; &quot;Error: Invalid SPIR-V magic number. Expected: 0x07230203, got: 0x&quot;&#10;                  &lt;&lt; std::hex &lt;&lt; code[0] &lt;&lt; std::dec &lt;&lt; std::endl;&#10;        return VK_NULL_HANDLE;&#10;    }&#10;&#10;    // Check minimum size (header is at least 5 words)&#10;    if (code.size() &lt; 5) {&#10;        std::cerr &lt;&lt; &quot;Error: SPIR-V code too small. Size: &quot; &lt;&lt; code.size() &lt;&lt; &quot; words, minimum: 5&quot; &lt;&lt; std::endl;&#10;        return VK_NULL_HANDLE;&#10;    }&#10;&#10;    // Print SPIR-V header information for debugging&#10;    std::cout &lt;&lt; &quot;SPIR-V Debug Info:&quot; &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Magic number: 0x&quot; &lt;&lt; std::hex &lt;&lt; code[0] &lt;&lt; std::dec &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Version: &quot; &lt;&lt; code[1] &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Generator: 0x&quot; &lt;&lt; std::hex &lt;&lt; code[2] &lt;&lt; std::dec &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Bound: &quot; &lt;&lt; code[3] &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Schema: &quot; &lt;&lt; code[4] &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; &quot;  Total size: &quot; &lt;&lt; code.size() &lt;&lt; &quot; words (&quot; &lt;&lt; (code.size() * 4) &lt;&lt; &quot; bytes)&quot; &lt;&lt; std::endl;&#10;&#10;    VkShaderModuleCreateInfo createInfo{};&#10;    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;&#10;    createInfo.codeSize = code.size() * sizeof(uint32_t);&#10;    createInfo.pCode = code.data();&#10;&#10;    VkShaderModule shaderModule;&#10;    VkResult result = vkCreateShaderModule(m_context-&gt;device(), &amp;createInfo, nullptr, &amp;shaderModule);&#10;&#10;    if (result != VK_SUCCESS) {&#10;        std::cerr &lt;&lt; &quot;Failed to create shader module. VkResult: &quot; &lt;&lt; result&#10;                  &lt;&lt; &quot; (&quot; &lt;&lt; vkResultToString(result) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;&#10;        std::cerr &lt;&lt; &quot;Code size: &quot; &lt;&lt; createInfo.codeSize &lt;&lt; &quot; bytes.&quot; &lt;&lt; std::endl;&#10;        return VK_NULL_HANDLE;&#10;    }&#10;&#10;    std::cout &lt;&lt; &quot;Successfully created shader module&quot; &lt;&lt; std::endl;&#10;    return shaderModule;&#10;}&#10;&#10;uint32_t VulkanRenderer::findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {&#10;    VkPhysicalDeviceMemoryProperties memProperties;&#10;    vkGetPhysicalDeviceMemoryProperties(m_context-&gt;physicalDevice(), &amp;memProperties);&#10;&#10;    for (uint32_t i = 0; i &lt; memProperties.memoryTypeCount; i++) {&#10;        if ((typeFilter &amp; (1 &lt;&lt; i)) &amp;&amp; (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) {&#10;            return i;&#10;        }&#10;    }&#10;&#10;    throw std::runtime_error(&quot;failed to find suitable memory type!&quot;);&#10;}&#10;&#10;bool VulkanRenderer::createSyncObjects() {&#10;    VkDevice device = m_context-&gt;device();&#10;&#10;    m_imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);&#10;    m_renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);&#10;    m_inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);&#10;&#10;    VkSemaphoreCreateInfo semaphoreInfo{};&#10;    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;&#10;&#10;    VkFenceCreateInfo fenceInfo{};&#10;    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;&#10;    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT; // Start signaled&#10;&#10;    for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {&#10;        if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;m_imageAvailableSemaphores[i]) != VK_SUCCESS ||&#10;            vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;m_renderFinishedSemaphores[i]) != VK_SUCCESS ||&#10;            vkCreateFence(device, &amp;fenceInfo, nullptr, &amp;m_inFlightFences[i]) != VK_SUCCESS) {&#10;            std::cerr &lt;&lt; &quot;Failed to create synchronization objects for frame &quot; &lt;&lt; i &lt;&lt; std::endl;&#10;            return false;&#10;        }&#10;    }&#10;&#10;    return true;&#10;}&#10;&#10;void VulkanRenderer::recordCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex) {&#10;    // Begin command buffer recording&#10;    VkCommandBufferBeginInfo beginInfo{};&#10;    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;&#10;    beginInfo.flags = 0; // Optional&#10;    beginInfo.pInheritanceInfo = nullptr; // Optional&#10;&#10;    if (vkBeginCommandBuffer(commandBuffer, &amp;beginInfo) != VK_SUCCESS) {&#10;        throw std::runtime_error(&quot;failed to begin recording command buffer!&quot;);&#10;    }&#10;&#10;    // Ensure imageIndex is valid&#10;    if (imageIndex &gt;= m_framebuffers.size()) {&#10;        std::cerr &lt;&lt; &quot;Warning: imageIndex &quot; &lt;&lt; imageIndex &lt;&lt; &quot; &gt;= framebuffer count &quot; &lt;&lt; m_framebuffers.size() &lt;&lt; std::endl;&#10;        imageIndex = 0; // Fallback to first framebuffer&#10;    }&#10;&#10;    // Begin render pass&#10;    VkRenderPassBeginInfo renderPassInfo{};&#10;    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;&#10;    renderPassInfo.renderPass = m_renderPass;&#10;    renderPassInfo.framebuffer = m_framebuffers[imageIndex];&#10;    renderPassInfo.renderArea.offset = {0, 0};&#10;    renderPassInfo.renderArea.extent = m_swapchainExtent;&#10;&#10;    VkClearValue clearColor = {{{0.0f, 0.0f, 0.0f, 1.0f}}};&#10;    renderPassInfo.clearValueCount = 1;&#10;    renderPassInfo.pClearValues = &amp;clearColor;&#10;&#10;    vkCmdBeginRenderPass(commandBuffer, &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);&#10;&#10;    // Only bind pipeline and draw if we have a valid pipeline&#10;    if (m_pipeline != VK_NULL_HANDLE) {&#10;        // Bind graphics pipeline&#10;        vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline);&#10;&#10;        // Set viewport and scissor dynamically (good practice)&#10;        VkViewport viewport{};&#10;        viewport.x = 0.0f;&#10;        viewport.y = 0.0f;&#10;        viewport.width = static_cast&lt;float&gt;(m_swapchainExtent.width);&#10;        viewport.height = static_cast&lt;float&gt;(m_swapchainExtent.height);&#10;        viewport.minDepth = 0.0f;&#10;        viewport.maxDepth = 1.0f;&#10;        vkCmdSetViewport(commandBuffer, 0, 1, &amp;viewport);&#10;&#10;        VkRect2D scissor{};&#10;        scissor.offset = {0, 0};&#10;        scissor.extent = m_swapchainExtent;&#10;        vkCmdSetScissor(commandBuffer, 0, 1, &amp;scissor);&#10;&#10;        // Draw the triangle (3 vertices, no vertex buffer needed as vertices are hardcoded in shader)&#10;        vkCmdDraw(commandBuffer, 3, 1, 0, 0);&#10;    }&#10;&#10;    // End render pass&#10;    vkCmdEndRenderPass(commandBuffer);&#10;&#10;    // End command buffer recording&#10;    if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {&#10;        throw std::runtime_error(&quot;failed to record command buffer!&quot;);&#10;    }&#10;}&#10;&#10;} // namespace VulkanCore&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/VulkanCore/Public/IVulkanContext.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/VulkanCore/Public/IVulkanContext.h" />
              <option name="originalContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;#ifndef IVULKANCONTEXT_H&#10;#define IVULKANCONTEXT_H&#10;&#10;#include &lt;vulkan/vulkan.h&gt;&#10;#include &lt;string&gt;&#10;#include &lt;memory&gt;&#10;namespace VulkanCore {&#10;&#10;    class IVulkanContext {&#10;    public:&#10;        virtual ~IVulkanContext() = default;&#10;        virtual bool     initialize(const std::string&amp; applicationName) = 0;&#10;" />
              <option name="updatedContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;#ifndef IVULKANCONTEXT_H&#10;#define IVULKANCONTEXT_H&#10;&#10;#include &lt;vulkan/vulkan.h&gt;&#10;#include &lt;string&gt;&#10;#include &lt;memory&gt;&#10;namespace VulkanCore {&#10;&#10;    class IVulkanContext {&#10;    public:&#10;        virtual ~IVulkanContext() = default;&#10;        virtual bool     initialize(const std::string&amp; applicationName) = 0;&#10;        virtual bool     initializeWithExistingInstance(VkInstance existingInstance) = 0;&#10;        virtual void     cleanup() = 0;&#10;        virtual VkInstance       instance() const = 0;&#10;        virtual VkDevice         device() const = 0;&#10;        virtual VkPhysicalDevice physicalDevice() const = 0;&#10;        virtual VkQueue          graphicsQueue() const = 0;&#10;        virtual uint32_t         graphicsQueueFamilyIndex() const = 0;&#10;    };&#10;&#10;    // Factory to create the default VulkanContext&#10;    std::shared_ptr&lt;IVulkanContext&gt; createVulkanContext();&#10;&#10;} // namespace VulkanCore&#10;&#10;&#10;#endif //IVULKANCONTEXT_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/VulkanCore/Public/MainWindow.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/VulkanCore/Public/MainWindow.h" />
              <option name="updatedContent" value="#ifndef MAINWINDOW_H&#10;#define MAINWINDOW_H&#10;&#10;#include &lt;QMainWindow&gt;&#10;#include &lt;QVulkanWindow&gt;&#10;&#10;class MainWindow : public QMainWindow {&#10;    Q_OBJECT&#10;&#10;public:&#10;    explicit MainWindow(QWidget* parent = nullptr);&#10;&#10;private:&#10;    QVulkanWindow* m_vulkanWindow;&#10;&#10;    void loadShader(const QString&amp; filePath, const QString&amp; shaderType);&#10;};&#10;&#10;#endif // MAINWINDOW_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/VulkanCore/Public/QtVulkanWindow.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/VulkanCore/Public/QtVulkanWindow.h" />
              <option name="originalContent" value="//&#10;// Created by charlie on 8/2/25.&#10;//&#10;&#10;#ifndef QTVULKANWINDOW_H&#10;#define QTVULKANWINDOW_H&#10;&#10;&#10;#include &lt;QVulkanWindow&gt;&#10;&#10;namespace VulkanCore {&#10;&#10;    class QtVulkanWindow : public QVulkanWindow {&#10;    public:&#10;        QVulkanWindowRenderer* createRenderer() override;&#10;" />
              <option name="updatedContent" value="//&#10;// Created by charlie on 8/2/25.&#10;//&#10;&#10;#ifndef QTVULKANWINDOW_H&#10;#define QTVULKANWINDOW_H&#10;&#10;&#10;#include &lt;QVulkanWindow&gt;&#10;&#10;namespace VulkanCore {&#10;&#10;    class QtVulkanWindow : public QVulkanWindow {&#10;    public:&#10;        QVulkanWindowRenderer* createRenderer() override;&#10;&#10;        // Shader loading interface&#10;        bool loadShadersFromFiles(const QString&amp; vertexShaderPath, const QString&amp; fragmentShaderPath);&#10;&#10;    private:&#10;        class VulkanWindowRenderer* m_renderer = nullptr;&#10;    };&#10;&#10;} // namespace VulkanCore&#10;&#10;#endif //QTVULKANWINDOW_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/VulkanCore/Public/VulkanRenderer.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/VulkanCore/Public/VulkanRenderer.h" />
              <option name="originalContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;#ifndef VULKANRENDERER_H&#10;#define VULKANRENDERER_H&#10;&#10;#include &quot;IVulkanContext.h&quot;&#10;#include &lt;functional&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;vulkan/vulkan.h&gt;&#10;#include &lt;QVulkanWindow&gt;&#10;&#10;namespace VulkanCore {&#10;&#10;    struct PipelineCreateInfo {&#10;        std::vector&lt;uint32_t&gt; vertexSpirv;&#10;        std::vector&lt;uint32_t&gt; fragmentSpirv;&#10;        VkPrimitiveTopology topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;&#10;    };&#10;&#10;    class VulkanRenderer {&#10;    public:&#10;        explicit VulkanRenderer(std::shared_ptr&lt;IVulkanContext&gt; context);&#10;        ~VulkanRenderer();&#10;&#10;        bool initialize(void* nativeWindowHandle);&#10;        void cleanup();&#10;&#10;        // Pipeline management&#10;        bool createPipeline(const PipelineCreateInfo&amp; createInfo);&#10;        void destroyPipeline();&#10;&#10;        void drawFrame(const std::function&lt;void(VkCommandBuffer)&gt;&amp; recordCommands);&#10;        void waitIdle();&#10;&#10;        // Getters for pipeline components&#10;        VkPipeline getPipeline() const { return m_pipeline; }&#10;        VkPipelineLayout getPipelineLayout() const { return m_pipelineLayout; }&#10;&#10;    private:&#10;        std::shared_ptr&lt;IVulkanContext&gt; m_context;&#10;        QVulkanWindow*                  m_window{nullptr};&#10;&#10;        VkSurfaceKHR                    m_surface{VK_NULL_HANDLE};&#10;        VkSwapchainKHR                  m_swapchain{VK_NULL_HANDLE};&#10;        std::vector&lt;VkImage&gt;            m_swapchainImages;&#10;        VkExtent2D                      m_swapchainExtent{};&#10;        VkFormat                        m_swapchainImageFormat{VK_FORMAT_UNDEFINED};&#10;        std::vector&lt;VkImageView&gt;        m_imageViews;&#10;        VkRenderPass                    m_renderPass{VK_NULL_HANDLE};&#10;        std::vector&lt;VkFramebuffer&gt;      m_framebuffers;&#10;        VkCommandPool                   m_commandPool{VK_NULL_HANDLE};&#10;        std::vector&lt;VkCommandBuffer&gt;    m_commandBuffers;&#10;&#10;        // Pipeline components&#10;        VkPipelineLayout                m_pipelineLayout{VK_NULL_HANDLE};&#10;        VkPipeline                      m_pipeline{VK_NULL_HANDLE};&#10;&#10;        // Vertex buffer for a simple triangle&#10;        VkBuffer                        m_vertexBuffer{VK_NULL_HANDLE};&#10;        VkDeviceMemory                  m_vertexBufferMemory{VK_NULL_HANDLE};&#10;&#10;        // Synchronization objects&#10;        static const int                MAX_FRAMES_IN_FLIGHT = 2;&#10;        std::vector&lt;VkSemaphore&gt;        m_imageAvailableSemaphores;&#10;        std::vector&lt;VkSemaphore&gt;        m_renderFinishedSemaphores;&#10;        std::vector&lt;VkFence&gt;            m_inFlightFences;&#10;        uint32_t                        m_currentFrame{0};&#10;&#10;        bool createSurface();&#10;        bool createSwapchain();&#10;        bool createImageViews();&#10;        bool createRenderPass();&#10;        bool createFramebuffers();&#10;        bool createCommandPool();&#10;        bool allocateCommandBuffers();&#10;        bool createVertexBuffer();&#10;        bool createSyncObjects();&#10;        void cleanupSwapchain();&#10;&#10;        VkShaderModule createShaderModule(const std::vector&lt;uint32_t&gt;&amp; code);&#10;        uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties);&#10;        void recordCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex);&#10;    };&#10;&#10;} // namespace VulkanCore&#10;&#10;&#10;#endif //VULKANRENDERER_H&#10;" />
              <option name="updatedContent" value="//&#10;// Created by charlie on 8/1/25.&#10;//&#10;&#10;#ifndef VULKANRENDERER_H&#10;#define VULKANRENDERER_H&#10;&#10;#include &quot;IVulkanContext.h&quot;&#10;#include &lt;functional&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;vulkan/vulkan.h&gt;&#10;#include &lt;QVulkanWindow&gt;&#10;&#10;namespace VulkanCore {&#10;&#10;    struct PipelineCreateInfo {&#10;        std::vector&lt;uint32_t&gt; vertexSpirv;&#10;        std::vector&lt;uint32_t&gt; fragmentSpirv;&#10;        VkPrimitiveTopology topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;&#10;        VkRenderPass renderPass = VK_NULL_HANDLE;  // Allow external render pass&#10;        VkExtent2D swapChainExtent = {800, 600};   // Default size&#10;    };&#10;&#10;    class VulkanRenderer {&#10;    public:&#10;        explicit VulkanRenderer(std::shared_ptr&lt;IVulkanContext&gt; context);&#10;        ~VulkanRenderer();&#10;&#10;        bool initialize(void* nativeWindowHandle);&#10;        void cleanup();&#10;&#10;        // Pipeline management&#10;        bool createPipeline(const PipelineCreateInfo&amp; createInfo);&#10;        void destroyPipeline();&#10;&#10;        void drawFrame(const std::function&lt;void(VkCommandBuffer)&gt;&amp; recordCommands);&#10;        void waitIdle();&#10;&#10;        // Command buffer recording for Qt integration&#10;        void recordCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex);&#10;&#10;        // Getters for pipeline components&#10;        VkPipeline getPipeline() const { return m_pipeline; }&#10;        VkPipelineLayout getPipelineLayout() const { return m_pipelineLayout; }&#10;&#10;    private:&#10;        std::shared_ptr&lt;IVulkanContext&gt; m_context;&#10;        QVulkanWindow*                  m_window{nullptr};&#10;&#10;        VkSurfaceKHR                    m_surface{VK_NULL_HANDLE};&#10;        VkSwapchainKHR                  m_swapchain{VK_NULL_HANDLE};&#10;        std::vector&lt;VkImage&gt;            m_swapchainImages;&#10;        VkExtent2D                      m_swapchainExtent{};&#10;        VkFormat                        m_swapchainImageFormat{VK_FORMAT_UNDEFINED};&#10;        std::vector&lt;VkImageView&gt;        m_imageViews;&#10;        VkRenderPass                    m_renderPass{VK_NULL_HANDLE};&#10;        std::vector&lt;VkFramebuffer&gt;      m_framebuffers;&#10;        VkCommandPool                   m_commandPool{VK_NULL_HANDLE};&#10;        std::vector&lt;VkCommandBuffer&gt;    m_commandBuffers;&#10;&#10;        // Pipeline components&#10;        VkPipelineLayout                m_pipelineLayout{VK_NULL_HANDLE};&#10;        VkPipeline                      m_pipeline{VK_NULL_HANDLE};&#10;&#10;        // Vertex buffer for a simple triangle&#10;        VkBuffer                        m_vertexBuffer{VK_NULL_HANDLE};&#10;        VkDeviceMemory                  m_vertexBufferMemory{VK_NULL_HANDLE};&#10;&#10;        // Synchronization objects&#10;        static const int                MAX_FRAMES_IN_FLIGHT = 2;&#10;        std::vector&lt;VkSemaphore&gt;        m_imageAvailableSemaphores;&#10;        std::vector&lt;VkSemaphore&gt;        m_renderFinishedSemaphores;&#10;        std::vector&lt;VkFence&gt;            m_inFlightFences;&#10;        uint32_t                        m_currentFrame{0};&#10;&#10;        bool createSurface();&#10;        bool createSwapchain();&#10;        bool createImageViews();&#10;        bool createRenderPass();&#10;        bool createFramebuffers();&#10;        bool createCommandPool();&#10;        bool allocateCommandBuffers();&#10;        bool createVertexBuffer();&#10;        bool createSyncObjects();&#10;        void cleanupSwapchain();&#10;&#10;        VkShaderModule createShaderModule(const std::vector&lt;uint32_t&gt;&amp; code);&#10;        uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties);&#10;    };&#10;&#10;} // namespace VulkanCore&#10;&#10;&#10;#endif //VULKANRENDERER_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/VulkanPipeline.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/VulkanPipeline.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>